Here’s what I changed in the **schema** and which tests those changes support. No code—just the “what & why”.

# 1) Moving-average valuation now uses **net unit cost** (price − per-unit discount)

**Where:** inside `trg_stock_valuation_after_transaction` (the big AFTER INSERT trigger on `inventory_transactions`).
**What changed:** every time the trigger looked up the unit cost from `purchase_items`, it used to divide **purchase\_price** by the UoM factor. I changed that to divide **(purchase\_price − item\_discount)** by the factor. This happens in **three** places in the trigger: two spots when computing `unit_value` for purchases and one spot when computing `total_value` for purchases.

**Why / which tests:**

* ✅ **P1 — Create a purchase (no payments):** Ensures `v_stock_on_hand.unit_value` becomes **95.0** for Widget A (100 − 5) instead of 100, matching the test’s expectation.
* Indirectly makes the valuation math correct for any scenario that depends on net purchase price.

# 2) Valuation “dirty window” also tracks item-discount edits

**Where:** `trg_mark_dirty_on_purchase_item_price_change` (the AFTER UPDATE trigger on `purchase_items`).
**What changed:** I added `item_discount` to the list of columns that mark a product as “valuation\_dirty” when changed (previously it reacted to price/UoM changes only).

**Why / which tests:**

* ✅ **P10 — Back-dated insertion marks valuation dirty (sanity):** This keeps the “recalc window” accurate not only when price/UoM changes, but also when a discount changes, so rebuild tools know to revalue from the earliest affected date.

# 3) (Already present but critical to your tests) Payment roll-up & method guards

**Where:** `trg_paid_from_purchase_payments_*` and `trg_pp_method_checks_*`.
**What they do:**

* Roll up `purchases.paid_amount` and `payment_status` whenever a row in `purchase_payments` is inserted/updated/deleted (clamped at ≥0).
* Enforce method-specific fields for **Bank Transfer**, **Cheque**, and **Cash Deposit** (e.g., require company bank account, instrument number, correct instrument\_type, and vendor destination account when money goes out).

**Why / which tests:**

* ✅ **P2 — Create purchase with initial cash payment:** header becomes paid and the required fields are enforced; `v_bank_ledger_ext` shows `amount_out=200`.
* ✅ **P3 — Cheque, then clear:** insert requires cheque fields; later changing `clearing_state` doesn’t alter sums, as expected.

# 4) (Already present and used) Bank ledger views (with vendor account)

**Where:** `v_bank_ledger` and `v_bank_ledger_ext`.
**What they do:** Expose unified in/out flows, with `v_bank_ledger_ext` also showing `vendor_bank_account_id`.

**Why / which tests:**

* ✅ **P2** and **P4** use these views to assert `amount_out` (payments) and `amount_in` (vendor refunds) respectively.

# 5) (Already present and used) Purchase returns valuation

**Where:** `purchase_return_valuations` view.
**What it does:** Computes return value using **(purchase\_price − item\_discount) × qty** for the returned `purchase_items` line.

**Why / which tests:**

* ✅ **P4 — Return with refund now:** Confirms the return valuation is **3 × (100−5) = 285**, then posts a **negative** payment for that amount.

# 6) (Already present and used) Vendor credit ledger + roll-up to purchase header

**Where:** `vendor_advances` table, `trg_vendor_advances_no_overdraw` guard, and `trg_adv_applied_from_vendor_*` roll-up triggers.
**What they do:**

* Prevent over-applying vendor credit.
* Keep `purchases.advance_payment_applied` in sync when credit is applied to a purchase.

**Why / which tests:**

* ✅ **P5 — Return with credit note:** records +200 to vendor credit (no payment row).
* ✅ **P6 — Apply vendor credit:** increases `advance_payment_applied`, decreases vendor credit balance.

# 7) (Already present and used) Purchase UoM enforcement = **base UoM only**

**Where:** `trg_purchase_items_base_only_ins/upd`.
**What they do:** Abort if a purchase item isn’t in the product’s base UoM.

**Why / which tests:**

* ✅ **P8 — UoM enforcement:** Attempting to buy “Box” for Widget A fails with “Purchases must use the product base UoM”.

# 8) (Already present and used) Inventory reference validation & integrity

**Where:** `trg_inventory_ref_validate`.
**What it does:** Validates reference table/id, ensures product/UoM matches the referenced line, and that sales inventory references real **sales** (not quotations).

**Why / which tests:**

* ✅ **P9 — Edit purchase:** When you rebuild only the `purchase` inventory rows for that purchase, the **`purchase_return`** rows remain intact, and the trigger ensures the new rows still reference the correct items.

---

### TL;DR

* The **only functional changes** you needed to pass the failing purchase test were:

  1. **Use (purchase\_price − item\_discount)** for all purchase-side unit cost pulls in the valuation trigger.
  2. Mark valuations dirty if **item\_discount** changes.
* Everything else in the schema that your tests assert against (payment roll-ups, method guards, bank ledger, returns valuation, vendor credit roll-ups, base-UoM enforcement, inventory reference checks) was already in place and is what makes the other tests pass.
