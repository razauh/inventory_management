
3) App code: where to put what
3.1 inventory_service.py (new — the brain)
Functions

post_inventory_for_purchase(conn, purchase_id)
Insert inventory_transactions rows (transaction_type='purchase'), set txn_seq 1..N for items.

post_inventory_for_sale(conn, sale_id)
Insert rows for sale items ('sale') with txn_seq.

post_inventory_for_sale_return(conn, sale_id, lines)
Insert 'sale_return' rows; set txn_seq after any original sale rows on the same date.

rebuild_valuation(conn, product_id: int, from_date: str)
Algorithm (inside one transaction):

DELETE FROM stock_valuation_history WHERE product_id=? AND DATE(valuation_date) >= DATE(?)

Stream all inventory_transactions for that product from from_date onward:
ORDER BY date, txn_seq, posted_at, transaction_id

Carry (qty_base, unit_cost_base); on purchase, recalc weighted-avg using purchase price in base UoM; on sale/purchase_return subtract qty; on sale_return/adjustment add qty.

Insert a snapshot row per transaction.

rebuild_dirty_now(conn)

Read all rows from valuation_dirty.

For each product, pick the earliest from_date.

Call rebuild_valuation(conn, product_id, from_date).

DELETE FROM valuation_dirty WHERE product_id = ?.

Unit-test this module. It’s pure logic and easy to test with fixtures.

3.2 sales_repo.py and purchase_repo.py (thin wrappers)
After posting headers+items, call the relevant post_inventory_*.

Immediately call inventory_service.rebuild_dirty_now(conn); this keeps the system consistent after each operation.

3.3 UI/controller (e.g., sales/controller.py)
Wrap posting + rebuild in a single progress step: “Posting and recalculating costs…”.

If a long rebuild occurs (many transactions), show a spinner.

4) Operational rules (so things stay sane)
Always set txn_seq. For a given sale_id or purchase_id, use 1..N by line order. If multiple documents share the same date, txn_seq ensures deterministic ordering across all rows for that product/date.

Never change header date after posting without also updating inventory_transactions.date. Easiest rule: lock header dates after posting. If you must allow edits, update the corresponding inventory_transactions rows and rely on the triggers to mark dirty; your app will rebuild.

Discourage UoM factor edits once a product has transactions. If you do allow them, expect a full-history rebuild for that product (trigger 2.5 handles the flagging).

5) Quick smoke tests (do these once)
Back-dated purchase affects past COGS

Post: Jan 05 buy 10 @ 10; Jan 06 sell 5; Jan 07 buy 10 @ 20.

Insert Jan 04 buy 10 @ 8.

Confirm valuation_dirty got a row; after rebuild_dirty_now(), check sale_item_cogs for Jan 06 — COGS must reflect the new (lower) average.

Edit purchase price

Change a purchase_items.purchase_price.

Ensure dirty is flagged and rebuild fixes averages.

Delete an old txn

Delete an early purchase row; dirty → rebuild → all later averages/COGS update.