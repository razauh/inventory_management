inventory_management/modules/customer/form.py
```
from __future__ import annotations

import re
from typing import Callable, Optional

from PySide6.QtWidgets import (
    QDialog,
    QFormLayout,
    QDialogButtonBox,
    QVBoxLayout,
    QLineEdit,
    QPlainTextEdit,
    QCheckBox,
    QMessageBox,
)

from ...utils.validators import non_empty


class CustomerForm(QDialog):
    """
    Customer create/edit form.

    Enhancements:
      - Active toggle (schema: customers.is_active) — defaults to ON.
      - Required fields: name, contact info.
      - Whitespace normalization: trims and tidies multi-line inputs.
      - Optional dedup hint: pass a `dup_check` callable to warn if an active
        customer with the same name exists (non-blocking, consistent with vendor side).

    Args:
        parent: Qt parent
        initial: optional dict with keys like
                 {customer_id, name, contact_info, address, is_active}
        dup_check: optional callable (name: str, current_id: Optional[int]) -> bool
                   Return True if another ACTIVE customer with the same name exists.
                   The form will warn but will not block submission.
    """

    def __init__(
        self,
        parent=None,
        initial: dict | None = None,
        dup_check: Optional[Callable[[str, Optional[int]], bool]] = None,
    ):
        super().__init__(parent)
        self.setWindowTitle("Customer")
        self.setModal(True)

        self._dup_check = dup_check
        self._initial = initial or {}

        # --- Fields ---
        self.name = QLineEdit()
        self.contact = QPlainTextEdit()
        self.contact.setPlaceholderText("Phone, email, etc.")
        self.addr = QPlainTextEdit()
        self.addr.setPlaceholderText("Address (optional)")

        self.is_active = QCheckBox("Active")
        self.is_active.setChecked(True)  # default ON

        # --- Layout ---
        form = QFormLayout()
        form.addRow("Name*", self.name)
        form.addRow("Contact Info*", self.contact)
        form.addRow("Address", self.addr)
        form.addRow("", self.is_active)

        root = QVBoxLayout(self)
        root.addLayout(form)

        self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        root.addWidget(self.buttons)

        # --- Initial values ---
        if initial:
            self.name.setText(initial.get("name", "") or "")
            self.contact.setPlainText(initial.get("contact_info", "") or "")
            self.addr.setPlainText(initial.get("address", "") or "")
            ia = initial.get("is_active")
            if ia is not None:
                # Accept 1/0, True/False
                self.is_active.setChecked(bool(ia))

        self._payload = None

    # ---------------- helpers ----------------

    @staticmethod
    def _collapse_spaces(line: str) -> str:
        # Collapse runs of whitespace inside a line to a single space
        return re.sub(r"\s+", " ", line).strip()

    def _norm_multiline(self, text: str) -> str:
        """
        Normalize multi-line text:
          - strip each line
          - collapse runs of spaces on each line
          - remove leading/trailing blank lines
        """
        if text is None:
            return ""
        lines = [self._collapse_spaces(l) for l in text.splitlines()]
        # Trim leading/trailing empty lines
        while lines and lines[0] == "":
            lines.pop(0)
        while lines and lines[-1] == "":
            lines.pop()
        return "\n".join(lines).strip()

    # ---------------- API ----------------

    def get_payload(self) -> dict | None:
        # Validate required
        if not non_empty(self.name.text()):
            self.name.setFocus()
            return None
        if not non_empty(self.contact.toPlainText()):
            self.contact.setFocus()
            return None

        # Normalize
        name = self._collapse_spaces(self.name.text())
        contact_info = self._norm_multiline(self.contact.toPlainText())
        address_norm = self._norm_multiline(self.addr.toPlainText())
        address = address_norm if address_norm else None
        is_active = 1 if self.is_active.isChecked() else 0

        # Optional dedup *warning* (non-blocking)
        if self._dup_check:
            current_id = self._initial.get("customer_id")
            try:
                if self._dup_check(name, current_id):
                    QMessageBox.warning(
                        self,
                        "Possible Duplicate",
                        (
                            "An active customer with the same name already exists.\n\n"
                            "You can still proceed — this is just a heads-up."
                        ),
                    )
            except Exception:
                # If the callback fails, we do not block the user.
                pass

        return {
            "name": name,
            "contact_info": contact_info,
            "address": address,          # optional
            "is_active": is_active,      # schema toggle
        }

    def accept(self):
        p = self.get_payload()
        if p is None:
            return
        self._payload = p
        super().accept()

    def payload(self):
        return self._payload

```

inventory_management/modules/customer/__init__.py
```
# /home/pc/Desktop/inventory_management/modules/customer/__init__.py

from .actions import (
    ActionResult,
    receive_payment,
    record_advance,
    apply_advance,
    open_payment_history,
)
from .controller import CustomerController
from .details import CustomerDetails
from .form import CustomerForm
from .history import CustomerHistoryService, get_customer_history_service
from .model import CustomersTableModel
from .view import CustomerView

__all__ = [
    # actions
    "ActionResult",
    "receive_payment",
    "record_advance",
    "apply_advance",
    "open_payment_history",
    # widgets/controllers
    "CustomerController",
    "CustomerView",
    "CustomerDetails",
    "CustomerForm",
    "CustomersTableModel",
    # history service
    "CustomerHistoryService",
    "get_customer_history_service",
]

```

inventory_management/modules/customer/controller.py
```
from __future__ import annotations

import sqlite3
from typing import Any, Optional, Dict, List

from PySide6.QtCore import Qt, QSortFilterProxyModel, QRegularExpression
from PySide6.QtWidgets import QWidget

from ..base_module import BaseModule
from .view import CustomerView
from .form import CustomerForm
from .model import CustomersTableModel
from ...database.repositories.customers_repo import CustomersRepo
from ...utils.ui_helpers import info


class CustomerController(BaseModule):
    """
    Customers controller with payment/credit actions and enriched details.

    Key behavior:
      - Loads active customers by default (customers.is_active = 1).
      - Right pane shows core fields + credit balance + recent activity.
      - Action buttons (Receive Payment, Record Advance, Apply Advance, Payment History)
        are disabled for inactive customers (history is allowed even if inactive).
      - Receipts enforce sale_id refers to a real SALE (not quotation) for this customer.
      - UI and actions are imported lazily to keep startup fast.

    Refactor:
      - Introduces _preflight() and _lazy_attr() to remove repeated boilerplate
        across payment/credit/history action handlers.
      - Adds local adapters for bank accounts and customer sales to support dialogs.
    """

    def __init__(self, conn: sqlite3.Connection):
        self.conn = conn
        self.repo = CustomersRepo(conn)
        self.view = CustomerView()
        self._wire()
        self._reload()

    # ------------------------------------------------------------------ #
    # BaseModule API
    # ------------------------------------------------------------------ #

    def get_widget(self) -> QWidget:
        return self.view

    # ------------------------------------------------------------------ #
    # Wiring & model
    # ------------------------------------------------------------------ #

    def _wire(self):
        self.view.btn_add.clicked.connect(self._add)
        self.view.btn_edit.clicked.connect(self._edit)
        # self.view.btn_del.clicked.connect(self._delete)
        self.view.search.textChanged.connect(self._apply_filter)

        # Payments/credit/history actions
        self.view.btn_receive_payment.clicked.connect(self._on_receive_payment)
        self.view.btn_record_advance.clicked.connect(self._on_record_advance)
        self.view.btn_apply_advance.clicked.connect(self._on_apply_advance)
        self.view.btn_payment_history.clicked.connect(self._on_payment_history)

        # Optional: Update Clearing button (wire only if present on the view)
        if hasattr(self.view, "btn_update_clearing"):
            self.view.btn_update_clearing.clicked.connect(self._on_update_clearing)

    def _build_model(self):
        # Active-only by default
        rows = self.repo.list_customers(active_only=True)
        self.base = CustomersTableModel(rows)

        self.proxy = QSortFilterProxyModel(self.view)
        self.proxy.setSourceModel(self.base)
        self.proxy.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.proxy.setFilterKeyColumn(-1)
        self.view.table.setModel(self.proxy)
        self.view.table.resizeColumnsToContents()

        # selection model is NEW after setModel → connect every time (no disconnects)
        sel = self.view.table.selectionModel()
        sel.selectionChanged.connect(self._update_details)

    def _reload(self):
        self._build_model()
        if self.proxy.rowCount() > 0:
            self.view.table.selectRow(0)
        # ensure right pane updates even if no selection event fired yet
        self._update_details()

    # ------------------------------------------------------------------ #
    # Helpers: selection & details
    # ------------------------------------------------------------------ #

    def _apply_filter(self, text: str):
        # Client-side filter (fast, preserves existing UX).
        self.proxy.setFilterRegularExpression(QRegularExpression(text))

    def _selected_id(self) -> int | None:
        idxs = self.view.table.selectionModel().selectedRows()
        if not idxs:
            return None
        src = self.proxy.mapToSource(idxs[0])
        return self.base.at(src.row()).customer_id

    def _current_row(self) -> dict | None:
        cid = self._selected_id()
        cust = self.repo.get(cid) if cid else None
        return cust.__dict__ if cust else None

    def _db_path_from_conn(self) -> Optional[str]:
        """
        Resolve the file path for the 'main' database. Returns None for in-memory DB.
        """
        row = self.conn.execute("PRAGMA database_list;").fetchone()
        # row: (seq, name, file)
        if not row:
            return None
        _, name, path = row
        return path if name == "main" and path else None

    def _fetch_is_active(self, customer_id: int) -> int:
        r = self.conn.execute(
            "SELECT is_active FROM customers WHERE customer_id=?",
            (customer_id,),
        ).fetchone()
        return int(r["is_active"]) if r and r["is_active"] is not None else 1

    def _details_enrichment(self, customer_id: int) -> Dict[str, Any]:
        """
        Compute credit balance & activity snapshot directly via SQL.
        """
        # credit balance
        bal_row = self.conn.execute(
            "SELECT balance FROM v_customer_advance_balance WHERE customer_id=?",
            (customer_id,),
        ).fetchone()
        credit_balance = float(bal_row["balance"]) if bal_row else 0.0

        # sales count + open due sum (use calculated_total_amount, and subtract advance_payment_applied)
        summary_row = self.conn.execute(
            """
            SELECT
              COUNT(*) AS sales_count,
              COALESCE(SUM(
                CASE
                  WHEN (
                    COALESCE(sdt.calculated_total_amount, s.total_amount)
                    - COALESCE(s.paid_amount, 0)
                    - COALESCE(s.advance_payment_applied, 0)
                  ) > 0
                  THEN (
                    COALESCE(sdt.calculated_total_amount, s.total_amount)
                    - COALESCE(s.paid_amount, 0)
                    - COALESCE(s.advance_payment_applied, 0)
                  )
                  ELSE 0
                END
              ), 0.0) AS open_due_sum
            FROM sales s
            LEFT JOIN sale_detailed_totals sdt ON sdt.sale_id = s.sale_id
            WHERE s.customer_id = ? AND s.doc_type = 'sale';
            """,
            (customer_id,),
        ).fetchone()
        sales_count = int(summary_row["sales_count"] if summary_row else 0)
        open_due_sum = float(summary_row["open_due_sum"] if summary_row else 0.0)

        # recent activity dates
        last_sale_date = self.conn.execute(
            "SELECT MAX(date) AS d FROM sales WHERE customer_id=? AND doc_type='sale';",
            (customer_id,),
        ).fetchone()
        last_payment_date = self.conn.execute(
            """
            SELECT MAX(sp.date) AS d
            FROM sale_payments sp
            JOIN sales s ON s.sale_id = sp.sale_id
            WHERE s.customer_id = ?;
            """,
            (customer_id,),
        ).fetchone()
        last_advance_date = self.conn.execute(
            "SELECT MAX(tx_date) AS d FROM customer_advances WHERE customer_id=?;",
            (customer_id,),
        ).fetchone()

        return {
            "credit_balance": credit_balance,
            "sales_count": sales_count,
            "open_due_sum": open_due_sum,
            "last_sale_date": last_sale_date["d"] if last_sale_date and last_sale_date["d"] else None,
            "last_payment_date": last_payment_date["d"] if last_payment_date and last_payment_date["d"] else None,
            "last_advance_date": last_advance_date["d"] if last_advance_date and last_advance_date["d"] else None,
        }

    def _update_details(self, *args):
        payload = self._current_row()
        if not payload:
            self.view.details.set_data(None)
            # disable actions if nothing selected
            self._set_actions_enabled(False)
            return

        cid = int(payload["customer_id"])
        # add is_active + enrichment (credit & activity)
        try:
            is_active = self._fetch_is_active(cid)
        except sqlite3.Error:
            is_active = 1

        payload["is_active"] = is_active
        try:
            payload.update(self._details_enrichment(cid))
        except sqlite3.Error:
            # Non-fatal; keep basic payload
            pass

        self.view.details.set_data(payload)
        # enable/disable action buttons based on active flag
        self._set_actions_enabled(bool(is_active))

    def _set_actions_enabled(self, enabled: bool):
        # Editing customer info follows the same active flag
        self.view.btn_edit.setEnabled(enabled)
        # Optional delete remains unchanged/commented in base code.
        self.view.btn_receive_payment.setEnabled(enabled)
        self.view.btn_record_advance.setEnabled(enabled)
        self.view.btn_apply_advance.setEnabled(enabled)
        # History is allowed as long as something is selected
        self.view.btn_payment_history.setEnabled(True if self._selected_id() else False)
        # Optional clearing button mirrors enabled state (if present)
        if hasattr(self.view, "btn_update_clearing"):
            self.view.btn_update_clearing.setEnabled(enabled)

    # ------------------------------------------------------------------ #
    # Small helpers to reduce repetition
    # ------------------------------------------------------------------ #

    def _preflight(self, *, require_active: bool = True, require_file_db: bool = True) -> tuple[Optional[int], Optional[str]]:
        """
        Common pre-checks for action handlers.

        Returns (customer_id, db_path). Any None means the caller should bail.
        - require_active: ensure selected customer is active
        - require_file_db: ensure database is file-backed (payments/credits need this)
        """
        cid = self._selected_id()
        if not cid:
            info(self.view, "Select", "Please select a customer first.")
            return None, None

        if require_active and not self._fetch_is_active(cid):
            info(self.view, "Inactive", "This customer is inactive. Enable the customer to proceed.")
            return None, None

        db_path: Optional[str]
        if require_file_db:
            db_path = self._ensure_db_path_or_toast()
            if not db_path:
                return None, None
        else:
            db_path = self._db_path_from_conn() or ":memory:"

        return cid, db_path

    def _lazy_attr(self, dotted: str, *, toast_title: str, on_fail: str) -> Any | None:
        """
        Lazy-import a symbol using a dotted path (e.g., 'pkg.mod.func' or 'pkg.mod.Class').
        Shows a toast if import fails and returns None.
        """
        try:
            module_path, attr_name = dotted.rsplit(".", 1)
            mod = __import__(module_path, fromlist=[attr_name])
            return getattr(mod, attr_name)
        except Exception as e:
            info(self.view, toast_title, f"{on_fail} ({e})")
            return None

    # ------------------------------------------------------------------ #
    # CRUD (unchanged behavior)
    # ------------------------------------------------------------------ #

    def _add(self):
        dlg = CustomerForm(self.view)
        if not dlg.exec():
            return
        p = dlg.payload()
        if not p:
            return
        cid = self.repo.create(**p)
        info(self.view, "Saved", f"Customer #{cid} created.")
        self._reload()

    def _edit(self):
        cid = self._selected_id()
        if not cid:
            info(self.view, "Select", "Please select a customer to edit.")
            return
        current = self.repo.get(cid)
        dlg = CustomerForm(self.view, initial=current.__dict__)
        if not dlg.exec():
            return
        p = dlg.payload()
        if not p:
            return
        self.repo.update(cid, **p)
        info(self.view, "Saved", f"Customer #{cid} updated.")
        self._reload()

    def _delete(self):
        cid = self._selected_id()
        if not cid:
            info(self.view, "Select", "Please select a customer to delete.")
            return
        self.repo.delete(cid)
        info(self.view, "Deleted", f"Customer #{cid} removed.")
        self._reload()

    # ------------------------------------------------------------------ #
    # Adapters required by dialogs
    # ------------------------------------------------------------------ #

    def _list_company_bank_accounts(self) -> List[Dict[str, Any]]:
        """
        Return active company bank accounts as [{id, name}].
        """
        rows = self.conn.execute(
            """
            SELECT account_id AS id,
                   COALESCE(label, bank_name || ' ' || account_no) AS name
            FROM company_bank_accounts
            WHERE is_active = 1
            ORDER BY name ASC;
            """
        ).fetchall()
        return [dict(r) for r in rows]

    def _list_sales_for_customer(self, customer_id: int) -> List[Dict[str, Any]]:
        """
        Return sales for a customer with totals/paid to compute remaining.
        """
        rows = self.conn.execute(
            """
            SELECT
              s.sale_id,
              s.doc_no,
              s.date,
              COALESCE(sdt.calculated_total_amount, s.total_amount) AS total,
              COALESCE(s.paid_amount, 0.0) AS paid
            FROM sales s
            LEFT JOIN sale_detailed_totals sdt ON sdt.sale_id = s.sale_id
            WHERE s.customer_id = ? AND s.doc_type = 'sale'
            ORDER BY s.date DESC, s.sale_id DESC;
            """,
            (customer_id,),
        ).fetchall()
        return [dict(r) for r in rows]

    def _eligible_sales_for_application(self, customer_id: int) -> List[Dict[str, Any]]:
        """
        Return list of sales with remaining due > 0 for the customer.
        (Used to seed 'apply advance' UI when needed.)
        """
        rows = self.conn.execute(
            """
            SELECT
              s.sale_id,
              s.date,
              COALESCE(sdt.calculated_total_amount, s.total_amount) AS total_calc,
              COALESCE(s.paid_amount, 0) AS paid_amount
            FROM sales s
            LEFT JOIN sale_detailed_totals sdt ON sdt.sale_id = s.sale_id
            WHERE s.customer_id = ? AND s.doc_type = 'sale'
            ORDER BY s.date DESC, s.sale_id DESC;
            """,
            (customer_id,),
        ).fetchall()

        out: List[Dict[str, Any]] = []
        for r in rows:
            remaining = float(r["total_calc"] or 0.0) - float(r["paid_amount"] or 0.0)
            if remaining > 0:
                out.append(
                    {
                        "sale_id": r["sale_id"],
                        "date": r["date"],
                        "remaining_due": remaining,
                        "total": float(r["total_calc"] or 0.0),
                        "paid": float(r["paid_amount"] or 0.0),
                    }
                )
        return out

    # ------------------------------------------------------------------ #
    # Payment / Credit Actions
    # ------------------------------------------------------------------ #

    def _ensure_db_path_or_toast(self) -> Optional[str]:
        db_path = self._db_path_from_conn()
        if not db_path:
            info(
                self.view,
                "Unavailable",
                "This action requires a file-backed database. In-memory databases are not supported for payments.",
            )
            return None
        return db_path

    def _sale_belongs_to_customer_and_is_sale(self, sale_id: str, customer_id: int) -> bool:
        row = self.conn.execute(
            "SELECT customer_id, doc_type FROM sales WHERE sale_id = ?;",
            (sale_id,),
        ).fetchone()
        if not row:
            return False
        return int(row["customer_id"]) == int(customer_id) and row["doc_type"] == "sale"

    # -- Receive Payment --

    def _on_receive_payment(self):
        cid, db_path = self._preflight(require_active=True, require_file_db=True)
        if not cid or not db_path:
            return

        # Use local dialog to gather payload so the user can PICK the sale (legacy UX).
        open_payment_or_advance_form = self._lazy_attr(
            "inventory_management.modules.customer.receipt_dialog.open_payment_or_advance_form",
            toast_title="Unavailable",
            on_fail="Receipt dialog is not available.",
        )
        if not open_payment_or_advance_form:
            return

        form_defaults = {
            "list_company_bank_accounts": self._list_company_bank_accounts,
            "list_sales_for_customer": self._list_sales_for_customer,
            "customer_display": str(cid),
        }
        payload = open_payment_or_advance_form(
            mode="receipt",
            customer_id=cid,
            sale_id=None,           # allow the dialog to present the sale picker (legacy UX)
            defaults=form_defaults,
        )
        if not payload:
            return  # cancelled

        sale_id = payload.get("sale_id")
        if not sale_id:
            info(self.view, "Required", "Please select a sale to receive payment.")
            return

        # Guard: must be a real SALE for this customer (not a quotation)
        if not self._sale_belongs_to_customer_and_is_sale(sale_id, cid):
            info(self.view, "Invalid", "Payments can only be recorded against SALES belonging to this customer.")
            return

        # Persist via the actions layer (no additional UI)
        receive_payment = self._lazy_attr(
            "inventory_management.modules.customer.actions.receive_payment",
            toast_title="Error",
            on_fail="Could not load actions.receive_payment",
        )
        if not receive_payment:
            return

        result = receive_payment(
            db_path=db_path,
            sale_id=str(sale_id),
            customer_id=cid,
            with_ui=False,
            form_defaults=payload,  # already validated by dialog; actions will recheck required keys
        )
        if not result or not result.success:
            info(self.view, "Not saved", (result.message if result else "Unknown error"))
            return

        info(self.view, "Saved", f"Payment #{result.id} recorded.")
        self._reload()

    # -- Record Advance (Deposit / Credit) --

    def _on_record_advance(self):
        cid, db_path = self._preflight(require_active=True, require_file_db=True)
        if not cid or not db_path:
            return

        record_customer_advance = self._lazy_attr(
            "inventory_management.modules.customer.actions.record_customer_advance",
            toast_title="Error",
            on_fail="Could not load actions.record_customer_advance",
        )
        if not record_customer_advance:
            return

        form_defaults = {
            # Optional: you can pass today() or created_by here if desired
            "customer_display": str(cid),
        }
        result = record_customer_advance(
            db_path=db_path,
            customer_id=cid,
            with_ui=True,
            form_defaults=form_defaults,
        )
        if not result or not result.success:
            if result and result.message:
                info(self.view, "Not saved", result.message)
            return

        info(self.view, "Saved", f"Advance #{result.id} recorded.")
        self._reload()

    # -- Apply Advance to a Sale --

    def _on_apply_advance(self):
        cid, db_path = self._preflight(require_active=True, require_file_db=True)
        if not cid or not db_path:
            return

        apply_customer_advance = self._lazy_attr(
            "inventory_management.modules.customer.actions.apply_customer_advance",
            toast_title="Error",
            on_fail="Could not load actions.apply_customer_advance",
        )
        if not apply_customer_advance:
            return

        # Provide sales list; dialog may also query via adapter
        form_defaults = {
            "sales": self._eligible_sales_for_application(cid),
            "list_sales_for_customer": self._list_sales_for_customer,
            "customer_display": str(cid),
        }
        result = apply_customer_advance(
            db_path=db_path,
            customer_id=cid,
            sale_id=None,           # allow dialog to select the sale
            with_ui=True,
            form_defaults=form_defaults,
        )
        if not result or not result.success:
            if result and result.message:
                info(self.view, "Not saved", result.message)
            return

        info(self.view, "Saved", f"Advance application #{result.id} recorded.")
        self._reload()

    # -- Update Clearing (optional button) --

    def _on_update_clearing(self):
        """
        Optional handler for a 'Update Clearing' toolbar button if your view provides it.
        Implement a tiny prompt dialog to collect payment_id, state, cleared_date, notes.
        """
        cid, db_path = self._preflight(require_active=True, require_file_db=True)
        if not cid or not db_path:
            return

        # Small, generic prompt utility could live elsewhere; for now, import lazily if you have one.
        # Expect a dict like: {"payment_id": int, "clearing_state": str, "cleared_date": str|None, "notes": str|None}
        prompt_update = self._lazy_attr(
            "inventory_management.modules.shared.prompts.prompt_update_clearing",  # hypothetical optional prompt
            toast_title="Unavailable",
            on_fail="Clearing prompt is not available.",
        )
        if not prompt_update:
            return
        data = prompt_update(parent=self.view)
        if not data:
            return

        update_receipt_clearing = self._lazy_attr(
            "inventory_management.modules.customer.actions.update_receipt_clearing",
            toast_title="Error",
            on_fail="Could not load actions.update_receipt_clearing",
        )
        if not update_receipt_clearing:
            return

        result = update_receipt_clearing(
            db_path=db_path,
            payment_id=int(data.get("payment_id")),
            clearing_state=str(data.get("clearing_state")),
            cleared_date=data.get("cleared_date"),
            notes=data.get("notes"),
        )
        if not result or not result.success:
            info(self.view, "Not updated", (result.message if result else "Unknown error"))
            return

        info(self.view, "Updated", result.message or "Receipt clearing updated.")
        self._reload()

    # -- Payment / Credit History --

    def _on_payment_history(self):
        # History is allowed even if customer is inactive; file DB not strictly required
        cid, db_path = self._preflight(require_active=False, require_file_db=False)
        if not cid:
            return

        open_payment_history = self._lazy_attr(
            "inventory_management.modules.customer.actions.open_payment_history",
            toast_title="Error",
            on_fail="Could not load actions.open_payment_history",
        )
        if not open_payment_history:
            return

        result = open_payment_history(
            db_path=db_path or ":memory:",
            customer_id=cid,
            with_ui=True,
        )
        if result and result.message:
            # Optionally surface a non-fatal message (e.g., UI fallback not available)
            info(self.view, "Info", result.message)

```

inventory_management/modules/customer/payment_history_view.py
```
# inventory_management/modules/customer/payment_history_view.py
from __future__ import annotations

from typing import Any, Dict, Iterable, List, Optional, Tuple

try:
    # Per project standard: PySide6
    from PySide6.QtCore import Qt
    from PySide6.QtGui import QAction
    from PySide6.QtWidgets import (
        QApplication,
        QDialog,
        QDialogButtonBox,
        QHeaderView,
        QLabel,
        QTableWidget,
        QTableWidgetItem,
        QTabWidget,
        QVBoxLayout,
        QWidget,
    )
except Exception:  # pragma: no cover
    raise


# -----------------------------
# i18n shim
# -----------------------------
def _t(s: str) -> str:
    return s


# -----------------------------
# Public API
# -----------------------------
def open_customer_history(*, customer_id: int, history: Dict[str, Any]) -> None:
    """
    Local, read-only window for customer payment/advance history.

    Parameters
    ----------
    customer_id : int
        Customer identifier (display-only).
    history : dict
        Payload produced by CustomerHistoryService.full_history(customer_id).
        This viewer is resilient: it will create one tab per key whose value is a list[dict],
        and render columns based on dict keys found.
    """
    app = QApplication.instance()
    owns_app = app is None
    if owns_app:
        app = QApplication([])

    dlg = _CustomerHistoryDialog(customer_id=customer_id, history=history or {})
    dlg.exec()

    if owns_app:
        app.quit()


# -----------------------------
# Dialog
# -----------------------------
class _CustomerHistoryDialog(QDialog):
    """
    Thin, read-only viewer for history payloads.
    Creates tabs automatically for each list[dict] in the payload.
    """

    # Preferred tabs order (if present)
    _PREFERRED_ORDER = [
        "sale_payments",          # receipts/refunds against sales
        "customer_advances",      # advances ledger (grants/applies)
        "sales",                  # sales headers
        "invoices",               # any synonym your service might provide
        "receipts",               # alternate naming
        "refunds",
        "allocations",
        "summary",                # will be computed locally if present as dict/list
    ]

    def __init__(self, *, customer_id: int, history: Dict[str, Any]) -> None:
        super().__init__(None)
        self.setWindowTitle(_t(f"Customer History — #{customer_id}"))
        self.setModal(True)
        self.resize(980, 620)

        self._customer_id = customer_id
        self._history = history or {}

        outer = QVBoxLayout(self)

        # Header
        outer.addWidget(QLabel(_t(f"Customer ID: {customer_id}")))
        self._hint = QLabel(_t("Read-only view. Columns are inferred from data."))
        self._hint.setStyleSheet("color:#666;")
        outer.addWidget(self._hint)

        # Tabs
        self.tabs = QTabWidget()
        outer.addWidget(self.tabs, 1)

        # Build tabs from history
        self._build_tabs_from_history()

        # Footer buttons
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Close)
        self.buttonBox.rejected.connect(self.reject)
        self.buttonBox.accepted.connect(self.accept)  # not shown, but keeps symmetry
        outer.addWidget(self.buttonBox)

        # Context/header actions (optional light feature)
        self._add_header_actions()

    # ---- helpers ------------------------------------------------------------

    def _add_header_actions(self) -> None:
        # Add a "Resize Columns" action to quickly fit columns per tab
        act_resize = QAction(_t("Resize Columns to Contents"), self)
        act_resize.triggered.connect(self._resize_current_tab_columns)
        self.addAction(act_resize)
        self.setContextMenuPolicy(Qt.ActionsContextMenu)

    def _resize_current_tab_columns(self) -> None:
        w = self.tabs.currentWidget()
        if isinstance(w, _TablePage):
            w.resize_columns()

    def _build_tabs_from_history(self) -> None:
        # Identify list[dict] entries and optional summaries
        tables: List[Tuple[str, List[Dict[str, Any]]]] = []
        extras: List[Tuple[str, Any]] = []

        for key, val in (self._history or {}).items():
            if isinstance(val, list) and all(isinstance(x, dict) for x in val):
                tables.append((key, val))
            else:
                extras.append((key, val))

        # Sort tables: preferred keys first, then alphabetically
        def _sort_key(kv: Tuple[str, List[Dict[str, Any]]]) -> Tuple[int, str]:
            key = kv[0]
            try:
                pref_idx = self._PREFERRED_ORDER.index(key)
            except ValueError:
                pref_idx = len(self._PREFERRED_ORDER) + 1
            return (pref_idx, key.lower())

        tables.sort(key=_sort_key)

        # Create a tab for each table
        for key, rows in tables:
            title = self._pretty_title(key)
            page = _TablePage(title=title, rows=rows)
            self.tabs.addTab(page, title)

        # Add a summary tab if any basic stats are useful
        summary_widget = self._build_summary_widget(tables, extras)
        if summary_widget is not None:
            self.tabs.addTab(summary_widget, _t("Summary"))

        # If nothing tabbed, show a fallback message
        if self.tabs.count() == 0:
            empty = QWidget()
            lay = QVBoxLayout(empty)
            msg = QLabel(_t("No tabular history found to display."))
            msg.setAlignment(Qt.AlignCenter)
            lay.addWidget(msg)
            self.tabs.addTab(empty, _t("History"))

    def _build_summary_widget(
        self,
        tables: List[Tuple[str, List[Dict[str, Any]]]],
        extras: List[Tuple[str, Any]],
    ) -> Optional[QWidget]:
        """
        Very light summary: counts per table and presence of known keys.
        (Avoids making assumptions about sign conventions.)
        """
        if not tables and not extras:
            return None

        w = QWidget()
        lay = QVBoxLayout(w)
        lay.setContentsMargins(12, 12, 12, 12)

        # Counts per table
        if tables:
            lay.addWidget(QLabel("<b>" + _t("Sections") + "</b>"))
            for key, rows in tables:
                lay.addWidget(QLabel(f"• {self._pretty_title(key)} — {len(rows)} {_t('row(s)')}"))

        # Known fields presence (helps debugging payload shape)
        known_sets = []
        for key, rows in tables:
            headers = _collect_headers(rows)
            # show up to 10 headers to keep it compact
            sample = ", ".join(list(headers)[:10])
            known_sets.append(f"{self._pretty_title(key)}: {sample}")
        if known_sets:
            lay.addSpacing(8)
            lay.addWidget(QLabel("<b>" + _t("Detected Columns") + "</b>"))
            for line in known_sets:
                lab = QLabel(line)
                lab.setStyleSheet("color:#666;")
                lay.addWidget(lab)

        lay.addStretch(1)
        return w

    @staticmethod
    def _pretty_title(key: str) -> str:
        k = key.replace("_", " ").strip()
        # Title case but keep common acronyms sensible
        k = " ".join(w.upper() if w in {"id", "uid"} else (w.capitalize()) for w in k.split())
        return k


# -----------------------------
# Table Page
# -----------------------------
class _TablePage(QWidget):
    """
    Displays a list[dict] in a QTableWidget (read-only).
    Columns are inferred from union of keys in the first N rows.
    """

    def __init__(self, *, title: str, rows: List[Dict[str, Any]], sample_for_headers: int = 100) -> None:
        super().__init__(None)
        self._title = title
        self._rows = rows or []
        self._headers = list(_collect_headers(self._rows[:sample_for_headers]))
        self._build()

    def _build(self) -> None:
        lay = QVBoxLayout(self)
        self.table = QTableWidget()
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setSelectionMode(QTableWidget.SingleSelection)
        self.table.setAlternatingRowColors(True)
        self.table.verticalHeader().setVisible(False)

        # Setup columns
        self.table.setColumnCount(len(self._headers))
        self.table.setHorizontalHeaderLabels([self._pretty_header(h) for h in self._headers])
        self._populate()

        # Sizing
        hh = self.table.horizontalHeader()
        hh.setSectionResizeMode(QHeaderView.ResizeToContents)
        hh.setStretchLastSection(True)

        lay.addWidget(self.table, 1)

        # Footer note
        hint = QLabel(_t("Tip: right-click anywhere to 'Resize Columns to Contents'."))
        hint.setStyleSheet("color:#666;")
        lay.addWidget(hint)

    def _populate(self) -> None:
        self.table.setRowCount(len(self._rows))
        for r, row in enumerate(self._rows):
            for c, key in enumerate(self._headers):
                val = row.get(key, "")
                item = QTableWidgetItem(self._fmt(val))
                # Alignment: numeric → right, date-ish → center, text → left
                if _is_number(val):
                    item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                elif _looks_like_date(str(val)):
                    item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
                else:
                    item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
                self.table.setItem(r, c, item)

    def resize_columns(self) -> None:
        self.table.resizeColumnsToContents()

    @staticmethod
    def _pretty_header(k: str) -> str:
        k = k.replace("_", " ").strip()
        return " ".join(w.upper() if w in {"id", "uid"} else (w.capitalize()) for w in k.split())

    @staticmethod
    def _fmt(v: Any) -> str:
        if v is None:
            return ""
        if isinstance(v, float):
            return f"{v:.2f}"
        return str(v)


# -----------------------------
# Utilities
# -----------------------------
def _collect_headers(rows: Iterable[Dict[str, Any]]) -> List[str]:
    headers: List[str] = []
    seen = set()
    for row in rows:
        for k in row.keys():
            if k not in seen:
                seen.add(k)
                headers.append(k)
    return headers


def _is_number(v: Any) -> bool:
    try:
        float(v)
        return True
    except Exception:
        return False


def _looks_like_date(s: str) -> bool:
    # Very light heuristic: YYYY-MM-DD (10 chars) or similar; avoid strict parsing to keep it fast/safe
    s = s.strip()
    if len(s) == 10 and s[4] == "-" and s[7] == "-":
        return True
    return False

```

inventory_management/modules/customer/view.py
```
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLineEdit,
    QLabel,
    QSplitter,
    QCheckBox,
    QTabWidget,
)
from PySide6.QtCore import Qt

from ...widgets.table_view import TableView
from .details import CustomerDetails


class CustomerView(QWidget):
    """
    Customers view:
      - Toolbar: Add, Edit, Receive Payment, Record Advance, Apply Advance, Payment History
      - Search box + 'Show inactive' toggle
      - Split: table (left) + tabs (right) -> Details / History
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        root = QVBoxLayout(self)

        # ---- Toolbar: actions + search -----------------------------------
        bar = QHBoxLayout()

        # CRUD
        self.btn_add = QPushButton("Add")
        self.btn_edit = QPushButton("Edit")
        # self.btn_del = QPushButton("Delete")
        bar.addWidget(self.btn_add)
        bar.addWidget(self.btn_edit)
        # bar.addWidget(self.btn_del)

        # Payments / Credits
        self.btn_receive_payment = QPushButton("Receive Payment")
        self.btn_record_advance = QPushButton("Record Advance")
        self.btn_apply_advance = QPushButton("Apply Advance")
        self.btn_payment_history = QPushButton("Payment History")

        bar.addWidget(self.btn_receive_payment)
        bar.addWidget(self.btn_record_advance)
        bar.addWidget(self.btn_apply_advance)
        bar.addWidget(self.btn_payment_history)

        bar.addStretch(1)

        # Search + Show inactive
        bar.addWidget(QLabel("Search:"))
        self.search = QLineEdit()
        self.search.setPlaceholderText("Search customers (name, id, contact, address)…")
        bar.addWidget(self.search, 2)

        self.chk_show_inactive = QCheckBox("Show inactive")
        bar.addWidget(self.chk_show_inactive)

        root.addLayout(bar)

        # ---- Main split: table (left) + tabs (right) ----------------------
        split = QSplitter(Qt.Horizontal)

        # Left: customers table
        self.table = TableView()
        split.addWidget(self.table)

        # Right: tabs -> Details / History
        self.tabs = QTabWidget()
        # Details tab (keep attribute name for controller compatibility)
        self.details = CustomerDetails()
        self.tabs.addTab(self.details, "Details")

        # History tab (compact, optional use)
        self.history_panel = QWidget()
        v_hist = QVBoxLayout(self.history_panel)
        self.history_hint = QLabel(
            "History shows receipts and advances for the selected customer.\n"
            "Tip: Use the toolbar’s ‘Payment History’ to open the full view."
        )
        self.history_hint.setWordWrap(True)
        v_hist.addWidget(self.history_hint)

        # Optional compact table (controller may populate later)
        self.history_table = TableView()
        v_hist.addWidget(self.history_table)
        self.tabs.addTab(self.history_panel, "History")

        split.addWidget(self.tabs)

        split.setStretchFactor(0, 3)
        split.setStretchFactor(1, 2)
        root.addWidget(split, 1)

```

inventory_management/modules/customer/history.py
```
from __future__ import annotations

import sqlite3
from pathlib import Path
from typing import Any, Dict, List, Optional


class CustomerHistoryService:
    """
    Presenter/service for assembling customer financial history for the UI.

    Pulls data from:
      - sales (doc_type='sale') + sale_items (+ products, uoms) and sale_detailed_totals view
      - sale_payments
      - customer_advances (+ v_customer_advance_balance)

    Returns structured dictionaries to keep the UI layer simple.
    """

    def __init__(self, db_path: str | Path):
        self.db_path = str(db_path)

    # --------------------------------------------------------------------- #
    # Internals
    # --------------------------------------------------------------------- #

    def _connect(self) -> sqlite3.Connection:
        con = sqlite3.connect(self.db_path)
        con.row_factory = sqlite3.Row
        con.execute("PRAGMA foreign_keys=ON;")
        return con

    @staticmethod
    def _rowdict(row: sqlite3.Row | None) -> Dict[str, Any] | None:
        return dict(row) if row is not None else None

    @staticmethod
    def _rowsdict(rows: List[sqlite3.Row]) -> List[Dict[str, Any]]:
        return [dict(r) for r in rows]

    @staticmethod
    def _clamp_non_negative(x: float) -> float:
        return x if x > 0 else 0.0

    # --------------------------------------------------------------------- #
    # Public API
    # --------------------------------------------------------------------- #

    def sales_with_items(self, customer_id: int) -> List[Dict[str, Any]]:
        """
        Returns sales for the customer with header totals (both header + calc view),
        computed remaining due, and an embedded list of line items.

        remaining_due formula:
            remaining_due = calculated_total_amount - paid_amount - advance_payment_applied   (clamped at >= 0)
        """
        with self._connect() as con:
            sales = con.execute(
                """
                SELECT
                    s.sale_id,
                    s.customer_id,
                    s.date,
                    s.total_amount,
                    s.paid_amount,
                    s.advance_payment_applied,
                    s.payment_status,
                    s.order_discount,
                    s.notes,
                    s.created_by,
                    s.source_type,
                    s.source_id,
                    COALESCE(sdt.subtotal_before_order_discount, 0.0) AS subtotal_before_order_discount,
                    COALESCE(sdt.calculated_total_amount, s.total_amount) AS calculated_total_amount
                FROM sales s
                LEFT JOIN sale_detailed_totals sdt ON sdt.sale_id = s.sale_id
                WHERE s.customer_id = ?
                  AND s.doc_type = 'sale'
                ORDER BY s.date ASC, s.sale_id ASC;
                """,
                (customer_id,),
            ).fetchall()

            if not sales:
                return []

            sale_ids = [row["sale_id"] for row in sales]
            # Build a parameterized IN clause safely
            placeholders = ",".join(["?"] * len(sale_ids))

            items = con.execute(
                f"""
                SELECT
                    si.item_id,
                    si.sale_id,
                    si.product_id,
                    p.name AS product_name,
                    si.quantity,
                    si.uom_id,
                    u.unit_name AS uom_name,
                    si.unit_price,
                    si.item_discount
                FROM sale_items si
                JOIN products p ON p.product_id = si.product_id
                JOIN uoms u     ON u.uom_id     = si.uom_id
                WHERE si.sale_id IN ({placeholders})
                ORDER BY si.sale_id ASC, si.item_id ASC;
                """,
                sale_ids,
            ).fetchall()

        # Group items by sale_id
        items_by_sale: Dict[str, List[Dict[str, Any]]] = {}
        for r in items:
            items_by_sale.setdefault(r["sale_id"], []).append(dict(r))

        # Compute remaining due using calculated_total_amount - paid_amount - advance_payment_applied
        result: List[Dict[str, Any]] = []
        for s in sales:
            calc_total = float(s["calculated_total_amount"] or 0.0)
            paid = float(s["paid_amount"] or 0.0)
            adv_applied = float(s["advance_payment_applied"] or 0.0)
            remaining_due = self._clamp_non_negative(calc_total - paid - adv_applied)
            header_total = float(s["total_amount"] or 0.0)
            result.append(
                {
                    **dict(s),
                    "items": items_by_sale.get(s["sale_id"], []),
                    "remaining_due": remaining_due,
                    "header_vs_calc_delta": round(header_total - calc_total, 6),
                }
            )
        return result

    def sale_payments(self, customer_id: int) -> List[Dict[str, Any]]:
        """
        Returns sale payments for all sales of the given customer (chronological).
        """
        with self._connect() as con:
            rows = con.execute(
                """
                SELECT
                    sp.payment_id,
                    sp.sale_id,
                    sp.date,
                    sp.amount,
                    sp.method,
                    sp.bank_account_id,
                    sp.instrument_type,
                    sp.instrument_no,
                    sp.instrument_date,
                    sp.deposited_date,
                    sp.cleared_date,
                    sp.clearing_state,
                    sp.ref_no,
                    sp.notes,
                    sp.created_by
                FROM sale_payments sp
                JOIN sales s ON s.sale_id = sp.sale_id
                WHERE s.customer_id = ?
                ORDER BY sp.date ASC, sp.payment_id ASC;
                """,
                (customer_id,),
            ).fetchall()
        return self._rowsdict(rows)

    def advances_ledger(self, customer_id: int) -> Dict[str, Any]:
        """
        Returns:
          - 'entries': the raw customer_advances entries for the customer
          - 'balance': current balance from v_customer_advance_balance
        """
        with self._connect() as con:
            entries = con.execute(
                """
                SELECT
                    tx_id,
                    customer_id,
                    tx_date,
                    amount,
                    source_type,
                    source_id,
                    notes,
                    created_by
                FROM customer_advances
                WHERE customer_id = ?
                ORDER BY tx_date ASC, tx_id ASC;
                """,
                (customer_id,),
            ).fetchall()

            bal_row = con.execute(
                """
                SELECT balance
                FROM v_customer_advance_balance
                WHERE customer_id = ?;
                """,
                (customer_id,),
            ).fetchone()

        return {
            "entries": self._rowsdict(entries),
            "balance": float(bal_row["balance"]) if bal_row is not None else 0.0,
        }

    def timeline(self, customer_id: int) -> List[Dict[str, Any]]:
        """
        Builds a unified chronological timeline of financial events for the customer:
          - 'sale'            (amount = calculated_total_amount, remaining_due included)
          - 'receipt'         (sale payment; amount = payment amount > 0)
          - 'advance'         (customer deposit/credit; amount = +ve)
          - 'advance_applied' (credit applied to sale; amount = negative)
        """
        sales = self.sales_with_items(customer_id)
        payments = self.sale_payments(customer_id)
        advances = self.advances_ledger(customer_id)

        events: List[Dict[str, Any]] = []

        for s in sales:
            events.append(
                {
                    "kind": "sale",
                    "date": s["date"],
                    "id": s["sale_id"],
                    "sale_id": s["sale_id"],
                    "amount": float(s["calculated_total_amount"] or 0.0),
                    "remaining_due": float(s["remaining_due"] or 0.0),
                    "payment_status": s["payment_status"],
                    "items": s["items"],
                    "notes": s.get("notes"),
                }
            )

        for p in payments:
            events.append(
                {
                    "kind": "receipt",
                    "date": p["date"],
                    "id": p["payment_id"],
                    "sale_id": p["sale_id"],
                    "amount": float(p["amount"] or 0.0),  # > 0 under current business rules
                    "method": p["method"],
                    "clearing_state": p["clearing_state"],
                    "instrument_no": p["instrument_no"],
                    "notes": p.get("notes"),
                }
            )

        for a in advances["entries"]:
            kind = "advance_applied" if a["source_type"] == "applied_to_sale" else "advance"
            events.append(
                {
                    "kind": kind,
                    "date": a["tx_date"],
                    "id": a["tx_id"],
                    "sale_id": a.get("source_id"),
                    "amount": float(a["amount"] or 0.0),  # +ve deposit, -ve application
                    "notes": a.get("notes"),
                }
            )

        # chronological sort; for same day, put sale first, then receipts, then advances, then applications
        order = {"sale": 0, "receipt": 1, "advance": 2, "advance_applied": 3}
        events.sort(key=lambda e: (e["date"] or "", order.get(e["kind"], 99), str(e.get("id", ""))))
        return events

    def overview(self, customer_id: int) -> Dict[str, Any]:
        """
        High-level snapshot for the UI:
          - balance (credit) from v_customer_advance_balance
          - sales count & open due sum (based on calculated totals)
          - last activity dates
        """
        sales = self.sales_with_items(customer_id)
        advances = self.advances_ledger(customer_id)
        payments = self.sale_payments(customer_id)

        open_due_sum = sum(float(s["remaining_due"] or 0.0) for s in sales)
        last_sale_date = sales[-1]["date"] if sales else None
        last_payment_date = payments[-1]["date"] if payments else None
        last_advance_date = advances["entries"][-1]["tx_date"] if advances["entries"] else None

        return {
            "customer_id": customer_id,
            "credit_balance": float(advances["balance"]),
            "sales_count": len(sales),
            "open_due_sum": open_due_sum,
            "last_sale_date": last_sale_date,
            "last_payment_date": last_payment_date,
            "last_advance_date": last_advance_date,
        }

    def full_history(self, customer_id: int) -> Dict[str, Any]:
        """
        Complete payload for UI screens:
          - sales (with items & remaining due)
          - payments
          - advances (+balance)
          - timeline (merged)
          - overview
        """
        sales = self.sales_with_items(customer_id)
        payments = self.sale_payments(customer_id)
        advances = self.advances_ledger(customer_id)
        timeline = self.timeline(customer_id)
        summary = self.overview(customer_id)

        return {
            "summary": summary,
            "sales": sales,
            "payments": payments,
            "advances": advances,
            "timeline": timeline,
        }


# Convenience factory
def get_customer_history_service(db_path: str | Path) -> CustomerHistoryService:
    return CustomerHistoryService(db_path)

```

inventory_management/modules/customer/model.py
```
from PySide6.QtCore import QAbstractTableModel, Qt, QModelIndex
from ...database.repositories.customers_repo import Customer


class CustomersTableModel(QAbstractTableModel):
    """
    Table model for customers with an extra 'Active' column.

    - Backward compatible: if a Customer row lacks `is_active`, we assume active (1).
    - Exposes a custom role (IS_ACTIVE_ROLE) to help external views delegate styling/filtering.
    """

    # Columns shown in the table
    HEADERS = ["ID", "Name", "Contact", "Address", "Active"]

    # Custom role to query active flag (int: 1 or 0)
    IS_ACTIVE_ROLE = Qt.UserRole + 1

    def __init__(self, rows: list[Customer]):
        super().__init__()
        self._rows = rows

    # --- Qt model basics ----------------------------------------------------

    def rowCount(self, parent=QModelIndex()):
        return len(self._rows)

    def columnCount(self, parent=QModelIndex()):
        return len(self.HEADERS)

    def _active_text(self, row_obj: Customer) -> str:
        """
        Produce human-friendly Active/Inactive text.
        Falls back to 'Active' when the attribute is missing (old dataclass).
        """
        val = getattr(row_obj, "is_active", 1)
        try:
            is_active = bool(int(val))  # handles 1/0/'1'/'0'
        except Exception:
            is_active = bool(val)       # handles True/False
        return "Active" if is_active else "Inactive"

    def _active_flag(self, row_obj: Customer) -> int:
        """Return 1 or 0 for active flag."""
        val = getattr(row_obj, "is_active", 1)
        try:
            return 1 if int(val) != 0 else 0
        except Exception:
            return 1 if bool(val) else 0

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None

        r = self._rows[index.row()]
        c = index.column()

        if role in (Qt.DisplayRole, Qt.EditRole):
            values = [
                r.customer_id,
                r.name,
                r.contact_info,
                (r.address or ""),
                self._active_text(r),
            ]
            return values[c]

        # Expose raw active flag via a custom role for easy filtering/styling
        if role == self.IS_ACTIVE_ROLE:
            return self._active_flag(r)

        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.HEADERS[section]
        return super().headerData(section, orientation, role)

    # --- helpers ------------------------------------------------------------

    def at(self, row: int) -> Customer:
        return self._rows[row]

    def replace(self, rows: list[Customer]):
        self.beginResetModel()
        self._rows = rows
        self.endResetModel()

```

inventory_management/modules/customer/actions.py
```
# /home/pc/Desktop/inventory_management/modules/customer/actions.py
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Any, Callable, Dict, Optional

import sqlite3


@dataclass
class ActionResult:
    success: bool
    id: Optional[int] = None        # created tx/payment id (if any)
    message: Optional[str] = None   # user-facing message
    payload: Optional[dict] = None  # any extra data (echoed form, history, etc.)


# ------- dependency factories (DI-friendly) ---------------------------------

def _get_sale_payments_repo(db_path: str | Path):
    # Lazy import to keep UI/server startup fast
    from inventory_management.database.repositories.sale_payments_repo import (
        SalePaymentsRepo,
    )
    return SalePaymentsRepo(db_path)


def _get_customer_advances_repo(db_path: str | Path):
    from inventory_management.database.repositories.customer_advances_repo import (
        CustomerAdvancesRepo,
    )
    return CustomerAdvancesRepo(db_path)


def _get_customer_history_service(db_path: str | Path):
    from inventory_management.modules.customer.history import (
        CustomerHistoryService,
    )
    return CustomerHistoryService(db_path)


# ======================= Actions: Receive Payment ============================

def receive_payment(
    *,
    db_path: str | Path,
    sale_id: str,
    customer_id: int,
    created_by: Optional[int] = None,
    # If you already collected fields in your UI, pass them here and set with_ui=False
    form_defaults: Optional[Dict[str, Any]] = None,
    with_ui: bool = True,
    # DI overrides (useful for tests)
    repo_factory: Callable[[str | Path], Any] = _get_sale_payments_repo,
) -> ActionResult:
    """
    Receive a customer payment against a SALE (not a quotation).

    If with_ui=True (default), tries local dialog first:
        inventory_management.modules.customer.receipt_dialog.open_payment_or_advance_form(mode="receipt", ...)
    Fallback (legacy) if local dialog unavailable:
        inventory_management.modules.payments.ui.customer_receipt_form.open_receipt_form(...)

    Otherwise (with_ui=False), uses `form_defaults` directly.
    """
    # 1) Collect data (UI or provided)
    form_data: Optional[Dict[str, Any]] = None
    if with_ui:
        # Prefer the new local dialog
        try:
            from inventory_management.modules.customer.receipt_dialog import (  # type: ignore
                open_payment_or_advance_form,
            )
            form_data = open_payment_or_advance_form(
                mode="receipt",
                customer_id=customer_id,
                sale_id=sale_id,
                defaults=form_defaults or {},
            )
        except ImportError:
            # Fallback to legacy payments UI
            try:
                from inventory_management.modules.payments.ui.customer_receipt_form import (  # type: ignore
                    open_receipt_form,
                )
            except ImportError:
                return ActionResult(
                    success=False,
                    message=(
                        "Receipt form UI is unavailable. "
                        "Either enable 'modules.customer.receipt_dialog' or legacy "
                        "'modules.payments.ui.customer_receipt_form', "
                        "or call with with_ui=False and pass `form_defaults`."
                    ),
                )
            form_data = open_receipt_form(sale_id=sale_id, customer_id=customer_id, defaults=form_defaults or {})

        if not form_data:
            return ActionResult(success=False, message="Payment cancelled by user.", payload=None)
    else:
        if not form_defaults:
            return ActionResult(success=False, message="Missing form_defaults while with_ui=False.")
        form_data = dict(form_defaults)

    # Ensure required fields exist; repo will perform deeper validation
    required = ("amount", "method")
    missing = [k for k in required if k not in form_data or form_data[k] is None]
    if missing:
        return ActionResult(success=False, message=f"Missing required fields: {', '.join(missing)}", payload=form_data)

    # 2) Persist via repo (soft validations mirror DB triggers)
    repo = repo_factory(db_path)
    try:
        payment_id = repo.record_payment(
            sale_id=sale_id,
            amount=float(form_data["amount"]),
            method=str(form_data["method"]),
            date=form_data.get("date"),
            bank_account_id=form_data.get("bank_account_id"),
            instrument_type=form_data.get("instrument_type"),
            instrument_no=form_data.get("instrument_no"),
            instrument_date=form_data.get("instrument_date"),
            deposited_date=form_data.get("deposited_date"),
            cleared_date=form_data.get("cleared_date"),
            clearing_state=form_data.get("clearing_state"),
            ref_no=form_data.get("ref_no"),
            notes=form_data.get("notes"),
            created_by=created_by or form_data.get("created_by"),
        )
        return ActionResult(success=True, id=payment_id, message="Payment recorded.", payload=form_data)
    except (ValueError, sqlite3.IntegrityError) as e:
        return ActionResult(success=False, message=str(e), payload=form_data)


# ======================= Actions: Advances (Credit) ==========================
# Existing non-UI actions (kept for backward compatibility)

def record_advance(
    *,
    db_path: str | Path,
    customer_id: int,
    amount: float,
    date: Optional[str] = None,   # 'YYYY-MM-DD'
    notes: Optional[str] = None,
    created_by: Optional[int] = None,
    repo_factory: Callable[[str | Path], Any] = _get_customer_advances_repo,
) -> ActionResult:
    """
    Record a customer deposit/advance (adds credit). amount must be > 0.
    """
    repo = repo_factory(db_path)
    try:
        tx_id = repo.grant_credit(
            customer_id=customer_id,
            amount=amount,
            date=date,
            notes=notes,
            created_by=created_by,
        )
        return ActionResult(success=True, id=tx_id, message="Advance recorded.")
    except (ValueError, sqlite3.IntegrityError) as e:
        return ActionResult(success=False, message=str(e))


def apply_advance(
    *,
    db_path: str | Path,
    customer_id: int,
    sale_id: str,
    amount_to_apply: float,              # positive in UI; repo writes negative
    date: Optional[str] = None,
    notes: Optional[str] = None,
    created_by: Optional[int] = None,
    repo_factory: Callable[[str | Path], Any] = _get_customer_advances_repo,
) -> ActionResult:
    """
    Apply customer credit to a sale.

    The UI supplies a positive amount; the repository (CustomerAdvancesRepo)
    validates against the sale's remaining due and records the application
    as a NEGATIVE amount in the ledger. Do not negate here.
    """
    if amount_to_apply is None or amount_to_apply <= 0:
        return ActionResult(success=False, message="Amount to apply must be > 0.")
    repo = repo_factory(db_path)
    try:
        tx_id = repo.apply_credit_to_sale(
            customer_id=customer_id,
            sale_id=sale_id,
            amount=float(amount_to_apply),   # pass positive; repo stores negative
            date=date,
            notes=notes,
            created_by=created_by,
        )
        return ActionResult(success=True, id=tx_id, message="Advance applied to sale.")
    except (ValueError, sqlite3.IntegrityError) as e:
        return ActionResult(success=False, message=str(e))


# ======================= NEW: UI-enabled Advance Helpers =====================

def record_customer_advance(
    *,
    db_path: str | Path,
    customer_id: int,
    # If you already collected fields in your UI, pass them here and set with_ui=False
    form_defaults: Optional[Dict[str, Any]] = None,
    with_ui: bool = True,
    repo_factory: Callable[[str | Path], Any] = _get_customer_advances_repo,
) -> ActionResult:
    """
    Record a customer advance via UI or direct payload.

    UI path (preferred):
        inventory_management.modules.customer.receipt_dialog.open_payment_or_advance_form(mode="advance", ...)

    Non-UI path:
        Uses `form_defaults` as payload to CustomerAdvancesRepo.grant_credit(...)
    """
    form_data: Optional[Dict[str, Any]] = None
    if with_ui:
        try:
            from inventory_management.modules.customer.receipt_dialog import (  # type: ignore
                open_payment_or_advance_form,
            )
        except ImportError:
            return ActionResult(
                success=False,
                message=(
                    "Advance form UI is unavailable. "
                    "Enable 'modules.customer.receipt_dialog' or call with with_ui=False and pass `form_defaults`."
                ),
            )
        form_data = open_payment_or_advance_form(
            mode="advance",
            customer_id=customer_id,
            sale_id=None,
            defaults=form_defaults or {},
        )
        if not form_data:
            return ActionResult(success=False, message="Advance entry cancelled by user.", payload=None)
    else:
        if not form_defaults:
            return ActionResult(success=False, message="Missing form_defaults while with_ui=False.")
        form_data = dict(form_defaults)

    # required: amount (>0)
    if "amount" not in form_data or form_data["amount"] is None or float(form_data["amount"]) <= 0:
        return ActionResult(success=False, message="Amount must be greater than zero.", payload=form_data)

    repo = repo_factory(db_path)
    try:
        tx_id = repo.grant_credit(
            customer_id=customer_id,
            amount=float(form_data["amount"]),
            date=form_data.get("date"),
            notes=form_data.get("notes"),
            created_by=form_data.get("created_by"),
        )
        return ActionResult(success=True, id=tx_id, message="Advance recorded.", payload=form_data)
    except (ValueError, sqlite3.IntegrityError) as e:
        return ActionResult(success=False, message=str(e), payload=form_data)


def apply_customer_advance(
    *,
    db_path: str | Path,
    customer_id: int,
    sale_id: Optional[str] = None,           # may be chosen in UI if None
    # If you already collected fields in your UI, pass them here and set with_ui=False
    form_defaults: Optional[Dict[str, Any]] = None,
    with_ui: bool = True,
    repo_factory: Callable[[str | Path], Any] = _get_customer_advances_repo,
) -> ActionResult:
    """
    Apply an existing customer advance to a sale via UI or direct payload.

    UI path (preferred):
        inventory_management.modules.customer.receipt_dialog.open_payment_or_advance_form(mode="apply_advance", ...)

    Non-UI path:
        Uses `form_defaults` as payload to CustomerAdvancesRepo.apply_credit_to_sale(...)
    """
    form_data: Optional[Dict[str, Any]] = None
    if with_ui:
        try:
            from inventory_management.modules.customer.receipt_dialog import (  # type: ignore
                open_payment_or_advance_form,
            )
        except ImportError:
            return ActionResult(
                success=False,
                message=(
                    "Apply-advance UI is unavailable. "
                    "Enable 'modules.customer.receipt_dialog' or call with with_ui=False and pass `form_defaults`."
                ),
            )
        form_data = open_payment_or_advance_form(
            mode="apply_advance",
            customer_id=customer_id,
            sale_id=sale_id,
            defaults=form_defaults or {},
        )
        if not form_data:
            return ActionResult(success=False, message="Apply advance cancelled by user.", payload=None)
    else:
        if not form_defaults:
            return ActionResult(success=False, message="Missing form_defaults while with_ui=False.")
        form_data = dict(form_defaults)

    # required: sale_id, amount (>0)
    sid = form_data.get("sale_id") or sale_id
    if not sid:
        return ActionResult(success=False, message="Missing sale_id for applying advance.", payload=form_data)
    if "amount" not in form_data or form_data["amount"] is None or float(form_data["amount"]) <= 0:
        return ActionResult(success=False, message="Amount must be greater than zero.", payload=form_data)

    repo = repo_factory(db_path)
    try:
        tx_id = repo.apply_credit_to_sale(
            customer_id=customer_id,
            sale_id=str(sid),
            amount=float(form_data["amount"]),   # positive; repo stores negative
            date=form_data.get("date"),
            notes=form_data.get("notes"),
            created_by=form_data.get("created_by"),
        )
        return ActionResult(success=True, id=tx_id, message="Advance applied to sale.", payload=form_data)
    except (ValueError, sqlite3.IntegrityError) as e:
        return ActionResult(success=False, message=str(e), payload=form_data)


# ======================= NEW: Payments Clearing Lifecycle ====================

def update_receipt_clearing(
    *,
    db_path: str | Path,
    payment_id: int,
    clearing_state: str,                 # 'posted' | 'pending' | 'cleared' | 'bounced'
    cleared_date: Optional[str] = None,  # 'YYYY-MM-DD' or None
    notes: Optional[str] = None,
    repo_factory: Callable[[str | Path], Any] = _get_sale_payments_repo,
) -> ActionResult:
    """
    Update the clearing lifecycle for an existing sale payment (receipt).
    """
    repo = repo_factory(db_path)
    try:
        updated = repo.update_clearing_state(
            payment_id=payment_id,
            clearing_state=clearing_state,
            cleared_date=cleared_date,
            notes=notes,
        )
        if updated <= 0:
            return ActionResult(success=False, message="No receipt updated.")
        return ActionResult(success=True, message="Receipt clearing updated.")
    except (ValueError, sqlite3.IntegrityError) as e:
        return ActionResult(success=False, message=str(e))


# ======================= Actions: History (Presenter) ========================

def open_payment_history(
    *,
    db_path: str | Path,
    customer_id: int,
    with_ui: bool = True,
) -> ActionResult:
    """
    Builds the customer's payment/credit history and (optionally) opens a UI view.

    If with_ui=True, it first tries local:
        inventory_management.modules.customer.payment_history_view.open_customer_history(...)
    Fallback (legacy) if local unavailable:
        inventory_management.modules.payments.ui.payment_history_view.open_customer_history(...)
    """
    history_service = _get_customer_history_service(db_path)
    history_payload = history_service.full_history(customer_id)

    if not with_ui:
        return ActionResult(success=True, payload=history_payload)

    # Try to open the local UI first.
    try:
        from inventory_management.modules.customer.payment_history_view import (  # type: ignore
            open_customer_history,
        )
        open_customer_history(customer_id=customer_id, history=history_payload)
        return ActionResult(success=True, message="History view opened.", payload=None)
    except ImportError:
        pass

    # Fallback to legacy payments UI.
    try:
        from inventory_management.modules.payments.ui.payment_history_view import (  # type: ignore
            open_customer_history as open_customer_history_legacy,
        )
    except ImportError:
        # No UI available — still succeed and return the payload for the caller/UI to use.
        return ActionResult(
            success=True,
            message=(
                "History view UI is unavailable; returning data payload only. "
                "Enable 'modules.customer.payment_history_view' or legacy "
                "'modules.payments.ui.payment_history_view' to open the window."
            ),
            payload=history_payload,
        )

    open_customer_history_legacy(customer_id=customer_id, history=history_payload)
    return ActionResult(success=True, message="History view opened.", payload=None)

```

inventory_management/modules/customer/details.py
```
from PySide6.QtWidgets import QWidget, QVBoxLayout, QGroupBox, QFormLayout, QLabel


class CustomerDetails(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        # --- Basic info ---
        box_basic = QGroupBox("Customer Details")
        f_basic = QFormLayout(box_basic)

        self.lab_id = QLabel("-")
        self.lab_name = QLabel("-")
        self.lab_contact = QLabel("-")
        self.lab_address = QLabel("-")
        self.lab_address.setWordWrap(True)

        f_basic.addRow("ID:", self.lab_id)
        f_basic.addRow("Name:", self.lab_name)
        f_basic.addRow("Contact:", self.lab_contact)
        f_basic.addRow("Address:", self.lab_address)

        # --- Financial snapshot ---
        box_fin = QGroupBox("Financial Snapshot")
        f_fin = QFormLayout(box_fin)

        self.lab_status = QLabel("-")             # Active / Inactive
        self.lab_credit = QLabel("-")             # v_customer_advance_balance
        self.lab_last_sale = QLabel("-")          # last sale date
        self.lab_last_payment = QLabel("-")       # last payment date
        self.lab_outstanding = QLabel("-")        # sum of (total - paid - applied advances), provided by caller

        f_fin.addRow("Status:", self.lab_status)
        f_fin.addRow("Credit Balance:", self.lab_credit)
        f_fin.addRow("Last Sale:", self.lab_last_sale)
        f_fin.addRow("Last Payment:", self.lab_last_payment)
        f_fin.addRow("Outstanding Receivables:", self.lab_outstanding)

        # Root layout
        root = QVBoxLayout(self)
        root.addWidget(box_basic)
        root.addWidget(box_fin)

    # ---------------- helpers ----------------

    @staticmethod
    def _fmt_money(val) -> str:
        if val is None:
            return "-"
        try:
            return f"{float(val):,.2f}"
        except Exception:
            return str(val)

    @staticmethod
    def _fmt_text(val) -> str:
        return "-" if val is None or val == "" else str(val)

    # ---------------- API ----------------

    def clear(self):
        # basic
        self.lab_id.setText("-")
        self.lab_name.setText("-")
        self.lab_contact.setText("-")
        self.lab_address.setText("-")
        # financial
        self.lab_status.setText("-")
        self.lab_credit.setText("-")
        self.lab_last_sale.setText("-")
        self.lab_last_payment.setText("-")
        self.lab_outstanding.setText("-")

    def set_data(self, row: dict | None):
        """
        Expects an optional payload dict (from controller) containing:
          - customer_id, name, contact_info, address
          - is_active (0/1)
          - credit_balance (float)
          - last_sale_date (YYYY-MM-DD or None)
          - last_payment_date (YYYY-MM-DD or None)
          - open_due_sum (float)  # sum over sales: total − paid − applied advances
        All fields are optional; UI falls back gracefully.
        """
        if not row:
            self.clear()
            return

        # Basic
        self.lab_id.setText(self._fmt_text(row.get("customer_id")))
        self.lab_name.setText(self._fmt_text(row.get("name")))
        self.lab_contact.setText(self._fmt_text(row.get("contact_info")))
        self.lab_address.setText(self._fmt_text(row.get("address")))

        # Financial snapshot
        is_active = row.get("is_active")
        status_text = "Active" if (is_active == 1 or is_active is True) else ("Inactive" if is_active is not None else "-")
        self.lab_status.setText(status_text)

        self.lab_credit.setText(self._fmt_money(row.get("credit_balance")))
        self.lab_last_sale.setText(self._fmt_text(row.get("last_sale_date")))
        self.lab_last_payment.setText(self._fmt_text(row.get("last_payment_date")))

        # Outstanding receivables (sum of sales: total − paid − applied advances)
        # Value should be provided by controller/service as 'open_due_sum'.
        self.lab_outstanding.setText(self._fmt_money(row.get("open_due_sum")))

```

inventory_management/modules/customer/receipt_dialog.py
```
# inventory_management/modules/customer/receipt_dialog.py
from __future__ import annotations

from typing import Callable, Optional, Literal

try:
    # Prefer PySide6 per project spec
    from PySide6.QtCore import Qt, QDate
    from PySide6.QtGui import QIntValidator, QKeySequence
    from PySide6.QtWidgets import (
        QApplication,
        QComboBox,
        QDateEdit,
        QDialog,
        QDialogButtonBox,
        QDoubleSpinBox,
        QFormLayout,
        QHBoxLayout,
        QLabel,
        QLineEdit,
        QMessageBox,
        QPlainTextEdit,
        QPushButton,
        QVBoxLayout,
        QWidget,
        QStackedWidget,
        QTabBar,
    )
except Exception:  # pragma: no cover
    raise

# -----------------------------
# i18n shim
# -----------------------------
def _t(s: str) -> str:
    return s

# -----------------------------
# Canonical constants & matrices
# -----------------------------
METHODS = [
    "Cash",
    "Bank Transfer",
    "Card",
    "Cheque",
    "Cash Deposit",
    "Other",
]

INSTRUMENT_TYPES = [
    "online",
    "cross_cheque",
    "cash_deposit",
    "pay_order",
    "other",
]

CLEARING_STATES = ["posted", "pending", "cleared", "bounced"]

METHOD_TO_FORCED_INSTRUMENT = {
    "Cash": "other",
    "Bank Transfer": "online",
    "Card": "other",
    "Cheque": "cross_cheque",
    "Cash Deposit": "cash_deposit",
    "Other": "other",
}

METHOD_TO_DEFAULT_CLEARING = {
    "Cash": "posted",
    "Bank Transfer": "posted",
    "Card": "posted",
    "Cheque": "pending",
    "Cash Deposit": "pending",
    "Other": "posted",
}

METHODS_REQUIRE_BANK = {"Bank Transfer", "Cheque", "Cash Deposit"}
METHODS_REQUIRE_INSTR_NO = {"Bank Transfer", "Cheque", "Cash Deposit"}

# -----------------------------
# Public APIs
# -----------------------------
def open_payment_or_advance_form(
    *,
    mode: Literal["receipt", "advance", "apply_advance"],
    customer_id: int,
    sale_id: Optional[str] = None,
    defaults: dict | None = None,
) -> dict | None:
    """
    Unified money-in dialog for customers with three modes:
      - "receipt": capture sale payment → payload for SalePaymentsRepo.record_payment(...)
      - "advance": record customer advance → payload for CustomerAdvancesRepo.grant_credit(...)
      - "apply_advance": apply advance to a sale → payload for CustomerAdvancesRepo.apply_credit_to_sale(...)
    """
    app = QApplication.instance()
    owns_app = app is None
    if owns_app:
        app = QApplication([])

    dlg = _CustomerMoneyDialog(mode=mode, customer_id=customer_id, sale_id=sale_id, defaults=defaults or {})
    result = dlg.exec()
    payload = dlg.payload() if result == QDialog.Accepted else None

    if owns_app:
        app.quit()
    return payload


def open_receipt_form(
    *,
    sale_id: str,
    customer_id: int,
    defaults: dict | None = None,
) -> dict | None:
    """
    Backward-compatible API for legacy callers.
    """
    return open_payment_or_advance_form(
        mode="receipt",
        customer_id=customer_id,
        sale_id=sale_id,
        defaults=defaults or {},
    )

# -----------------------------
# Dialog Implementation (3 pages via QStackedWidget)
# -----------------------------
class _CustomerMoneyDialog(QDialog):
    """
    One dialog with three pages:
      - Receipt (existing behavior preserved)
      - Record Advance
      - Apply Advance
    Returns a payload tailored to the selected mode.
    """

    PAGE_RECEIPT = 0
    PAGE_ADVANCE = 1
    PAGE_APPLY = 2

    def __init__(self, *, mode: str, customer_id: int, sale_id: Optional[str], defaults: dict) -> None:
        super().__init__(None)
        self.setWindowTitle(_t("Customer Money"))
        self.setModal(True)

        # --- common state ---
        self._payload: Optional[dict] = None
        self._customer_id = int(customer_id)
        self._locked_sale_id = str(sale_id) if sale_id is not None else None
        self._defaults = defaults or {}

        # --- adapters via defaults (all optional) ---
        self._list_sales_for_customer: Optional[Callable[[int], list]] = self._defaults.get("list_sales_for_customer")
        self._sales_seed: Optional[list] = self._defaults.get("sales")
        self._list_company_bank_accounts: Optional[Callable[[], list]] = self._defaults.get("list_company_bank_accounts")
        self._today: Optional[Callable[[], str]] = self._defaults.get("today")
        self._get_available_advance: Optional[Callable[[int], float]] = self._defaults.get("get_available_advance")
        self._get_sale_due: Optional[Callable[[str], float]] = self._defaults.get("get_sale_due")

        # --- Prefills shared for receipt page ---
        self._prefill_method: Optional[str] = self._defaults.get("method")
        self._prefill_amount: Optional[float] = self._defaults.get("amount")
        self._prefill_date: Optional[str] = self._defaults.get("date")
        self._prefill_bank_id: Optional[int] = self._defaults.get("bank_account_id")
        self._prefill_instrument_type: Optional[str] = self._defaults.get("instrument_type")
        self._prefill_instrument_no: Optional[str] = self._defaults.get("instrument_no")
        self._prefill_instrument_date: Optional[str] = self._defaults.get("instrument_date")
        self._prefill_deposited_date: Optional[str] = self._defaults.get("deposited_date")
        self._prefill_clearing_state: Optional[str] = self._defaults.get("clearing_state")
        self._prefill_cleared_date: Optional[str] = self._defaults.get("cleared_date")
        self._prefill_ref_no: Optional[str] = self._defaults.get("ref_no")
        self._prefill_notes: Optional[str] = self._defaults.get("notes")
        self._prefill_created_by: Optional[int] = self._defaults.get("created_by")
        self._customer_display: Optional[str] = self._defaults.get("customer_display")

        # build UI
        self._build_ui()

        # initial page
        initial = {
            "receipt": self.PAGE_RECEIPT,
            "advance": self.PAGE_ADVANCE,
            "apply_advance": self.PAGE_APPLY,
        }.get(mode, self.PAGE_RECEIPT)
        self.pageStack.setCurrentIndex(initial)
        self.tabBar.setCurrentIndex(initial)
        self._sync_window_title()

        # load data and prefills
        self._load_sales()
        self._load_bank_accounts()
        self._apply_prefills_receipt()
        self._lock_sale_if_needed()
        self._on_method_changed()    # sets defaults for instrument/clearing
        self._update_hint()
        self._validate_live()        # receipt page
        self._validate_live_advance()
        self._validate_live_apply()

    # ---------- overall layout ----------
    def _build_ui(self) -> None:
        outer = QVBoxLayout(self)

        # Tab-like bar controlling a stacked widget
        self.tabBar = QTabBar()
        self.tabBar.addTab(_t("Receipt"))
        self.tabBar.addTab(_t("Record Advance"))
        self.tabBar.addTab(_t("Apply Advance"))
        self.tabBar.currentChanged.connect(self._on_tab_changed)
        outer.addWidget(self.tabBar)

        self.pageStack = QStackedWidget()
        outer.addWidget(self.pageStack, 1)

        # Build three pages
        self.page_receipt = QWidget()
        self._build_receipt_page(self.page_receipt)
        self.pageStack.addWidget(self.page_receipt)

        self.page_advance = QWidget()
        self._build_advance_page(self.page_advance)
        self.pageStack.addWidget(self.page_advance)

        self.page_apply = QWidget()
        self._build_apply_page(self.page_apply)
        self.pageStack.addWidget(self.page_apply)

        # Common hint/error/buttons
        self.hintLabel = QLabel("")
        self.hintLabel.setWordWrap(True)
        self.hintLabel.setStyleSheet("color: #666;")
        outer.addWidget(self.hintLabel)

        self.errorLabel = QLabel("")
        self.errorLabel.setStyleSheet("color: #b00020;")
        outer.addWidget(self.errorLabel)

        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        self.saveBtn: QPushButton = self.buttonBox.button(QDialogButtonBox.Save)
        self.cancelBtn: QPushButton = self.buttonBox.button(QDialogButtonBox.Cancel)
        self.saveBtn.setDefault(True)
        self.saveBtn.setShortcut(QKeySequence("Alt+S"))
        self.cancelBtn.setShortcut(QKeySequence("Alt+C"))
        self.saveBtn.clicked.connect(self._on_save)
        self.cancelBtn.clicked.connect(self.reject)
        outer.addWidget(self.buttonBox)

    # ---------- Receipt Page (existing behavior) ----------
    def _build_receipt_page(self, page: QWidget) -> None:
        form = QFormLayout(page)

        # Sale row
        self.salePicker = QComboBox()
        self.saleRemainingLabel = QLabel("")
        sale_row = QWidget()
        h = QHBoxLayout(sale_row)
        h.addWidget(self.salePicker, 1)
        h.addWidget(self.saleRemainingLabel, 0, Qt.AlignRight)
        lbl_sale = QLabel(_t("Sale"))
        lbl_sale.setBuddy(self.salePicker)
        form.addRow(lbl_sale, sale_row)

        # Customer label
        self.customerLabel = QLabel(_t("Customer: ") + (str(self._customer_display or self._customer_id)))
        form.addRow(QLabel(""), self.customerLabel)

        # Method
        self.methodCombo = QComboBox()
        for m in METHODS:
            self.methodCombo.addItem(m)
        form.addRow(QLabel(_t("Method")), self.methodCombo)

        # Amount
        self.amountEdit = QDoubleSpinBox()
        self.amountEdit.setDecimals(2)
        self.amountEdit.setRange(-1_000_000_000.00, 1_000_000_000.00)
        self.amountEdit.setSingleStep(1.00)
        lbl_amount = QLabel(_t("Amount"))
        lbl_amount.setBuddy(self.amountEdit)
        form.addRow(lbl_amount, self.amountEdit)

        # Date
        self.dateEdit = QDateEdit()
        self.dateEdit.setCalendarPopup(True)
        self.dateEdit.setDisplayFormat("yyyy-MM-dd")
        self.dateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Date")), self.dateEdit)

        # Company bank
        self.bankAccountCombo = QComboBox()
        lbl_bank = QLabel(_t("Company Bank"))
        lbl_bank.setBuddy(self.bankAccountCombo)
        form.addRow(lbl_bank, self.bankAccountCombo)

        # Instrument type
        self.instrumentTypeCombo = QComboBox()
        for t in INSTRUMENT_TYPES:
            self.instrumentTypeCombo.addItem(t)
        form.addRow(QLabel(_t("Instrument Type")), self.instrumentTypeCombo)

        # Instrument no
        self.instrumentNoEdit = QLineEdit()
        lbl_insno = QLabel(_t("Instrument No"))
        lbl_insno.setBuddy(self.instrumentNoEdit)
        form.addRow(lbl_insno, self.instrumentNoEdit)

        # Instrument date
        self.instrumentDateEdit = QDateEdit()
        self.instrumentDateEdit.setCalendarPopup(True)
        self.instrumentDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.instrumentDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Instrument Date")), self.instrumentDateEdit)

        # Deposited date
        self.depositedDateEdit = QDateEdit()
        self.depositedDateEdit.setCalendarPopup(True)
        self.depositedDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.depositedDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Deposited Date")), self.depositedDateEdit)

        # Clearing state
        self.clearingStateCombo = QComboBox()
        for s in CLEARING_STATES:
            self.clearingStateCombo.addItem(s)
        form.addRow(QLabel(_t("Clearing State")), self.clearingStateCombo)

        # Cleared date
        self.clearedDateEdit = QDateEdit()
        self.clearedDateEdit.setCalendarPopup(True)
        self.clearedDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.clearedDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Cleared Date")), self.clearedDateEdit)

        # Ref / Notes / Created by
        self.refNoEdit = QLineEdit()
        form.addRow(QLabel(_t("Ref No")), self.refNoEdit)

        self.notesEdit = QPlainTextEdit()
        self.notesEdit.setPlaceholderText(_t("Optional notes"))
        self.notesEdit.setFixedHeight(80)
        form.addRow(QLabel(_t("Notes")), self.notesEdit)

        self.createdByEdit = QLineEdit()
        self.createdByEdit.setValidator(QIntValidator())
        form.addRow(QLabel(_t("Created By")), self.createdByEdit)

        # For toggling required asterisks
        self._label_map = {
            self.bankAccountCombo: lbl_bank,
            self.instrumentNoEdit: lbl_insno,
            self.amountEdit: lbl_amount,
        }

        # wire
        self.salePicker.currentIndexChanged.connect(self._update_remaining)
        self.methodCombo.currentIndexChanged.connect(self._on_method_changed)
        self.clearingStateCombo.currentIndexChanged.connect(self._on_clearing_changed)
        self.amountEdit.valueChanged.connect(self._validate_live)
        self.bankAccountCombo.currentIndexChanged.connect(self._validate_live)
        self.instrumentNoEdit.textChanged.connect(self._validate_live)
        self.instrumentTypeCombo.currentIndexChanged.connect(self._validate_live)
        self.clearedDateEdit.dateChanged.connect(self._validate_live)

    # ---------- Record Advance Page ----------
    def _build_advance_page(self, page: QWidget) -> None:
        form = QFormLayout(page)

        # Customer label
        self.customerLabel2 = QLabel(_t("Customer: ") + (str(self._customer_display or self._customer_id)))
        form.addRow(QLabel(""), self.customerLabel2)

        # Amount (>0)
        self.advAmountEdit = QDoubleSpinBox()
        self.advAmountEdit.setDecimals(2)
        self.advAmountEdit.setRange(0.00, 1_000_000_000.00)
        self.advAmountEdit.setSingleStep(1.00)
        form.addRow(QLabel(_t("Amount *")), self.advAmountEdit)

        # Date
        self.advDateEdit = QDateEdit()
        self.advDateEdit.setCalendarPopup(True)
        self.advDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.advDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Date")), self.advDateEdit)

        # Notes / Created by
        self.advNotesEdit = QPlainTextEdit()
        self.advNotesEdit.setPlaceholderText(_t("Optional notes"))
        self.advNotesEdit.setFixedHeight(80)
        form.addRow(QLabel(_t("Notes")), self.advNotesEdit)

        self.advCreatedByEdit = QLineEdit()
        self.advCreatedByEdit.setValidator(QIntValidator())
        form.addRow(QLabel(_t("Created By")), self.advCreatedByEdit)

        # available credit (if adapter provided)
        self.availableLabel = QLabel("")
        form.addRow(QLabel(_t("Available Credit")), self.availableLabel)

        # wire
        self.advAmountEdit.valueChanged.connect(self._validate_live_advance)

    # ---------- Apply Advance Page ----------
    def _build_apply_page(self, page: QWidget) -> None:
        form = QFormLayout(page)

        # Sale pick (or preselected)
        self.applySalePicker = QComboBox()
        lbl_sale2 = QLabel(_t("Sale *"))
        lbl_sale2.setBuddy(self.applySalePicker)
        form.addRow(lbl_sale2, self.applySalePicker)

        self.applySaleRemainingLabel = QLabel("")
        form.addRow(QLabel(_t("Remaining Due")), self.applySaleRemainingLabel)

        # Amount (>0)
        self.applyAmountEdit = QDoubleSpinBox()
        self.applyAmountEdit.setDecimals(2)
        self.applyAmountEdit.setRange(0.00, 1_000_000_000.00)
        self.applyAmountEdit.setSingleStep(1.00)
        form.addRow(QLabel(_t("Amount *")), self.applyAmountEdit)

        # Date
        self.applyDateEdit = QDateEdit()
        self.applyDateEdit.setCalendarPopup(True)
        self.applyDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.applyDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Date")), self.applyDateEdit)

        # Notes / Created by
        self.applyNotesEdit = QPlainTextEdit()
        self.applyNotesEdit.setPlaceholderText(_t("Optional notes"))
        self.applyNotesEdit.setFixedHeight(80)
        form.addRow(QLabel(_t("Notes")), self.applyNotesEdit)

        self.applyCreatedByEdit = QLineEdit()
        self.applyCreatedByEdit.setValidator(QIntValidator())
        form.addRow(QLabel(_t("Created By")), self.applyCreatedByEdit)

        # info labels (if adapters provided)
        self.applyAvailLabel = QLabel("")
        form.addRow(QLabel(_t("Available Credit")), self.applyAvailLabel)

        # wire
        self.applySalePicker.currentIndexChanged.connect(self._update_apply_remaining)
        self.applyAmountEdit.valueChanged.connect(self._validate_live_apply)

    # ---------- Tab events ----------
    def _on_tab_changed(self, idx: int) -> None:
        self.pageStack.setCurrentIndex(idx)
        self._sync_window_title()
        self._update_hint()
        self._validate_live()
        self._validate_live_advance()
        self._validate_live_apply()

    def _sync_window_title(self) -> None:
        titles = {
            self.PAGE_RECEIPT: _t("Record Customer Receipt"),
            self.PAGE_ADVANCE: _t("Record Customer Advance"),
            self.PAGE_APPLY: _t("Apply Customer Advance to Sale"),
        }
        self.setWindowTitle(titles.get(self.pageStack.currentIndex(), _t("Customer Money")))

    # ---------- Data loaders ----------
    def _load_sales(self) -> None:
        # used by both receipt and apply pages
        sales: list[dict] = []
        try:
            if self._list_sales_for_customer:
                sales = list(self._list_sales_for_customer(self._customer_id))
            elif isinstance(self._sales_seed, list):
                sales = list(self._sales_seed)
        except Exception:
            sales = []

        # Receipt sale picker
        if hasattr(self, "salePicker"):
            self.salePicker.clear()
            for row in sales:
                sid = str(row.get("sale_id", ""))
                doc = str(row.get("doc_no", sid))
                date = str(row.get("date", ""))
                total = float(row.get("total", 0.0))
                paid = float(row.get("paid", 0.0))
                rem = total - paid
                display = f"{doc} — {date} — Total {total:.2f} Paid {paid:.2f} Rem {rem:.2f}"
                self.salePicker.addItem(display, row)
            self._update_remaining()

        # Apply sale picker
        if hasattr(self, "applySalePicker"):
            self.applySalePicker.clear()
            for row in sales:
                sid = str(row.get("sale_id", ""))
                doc = str(row.get("doc_no", sid))
                date = str(row.get("date", ""))
                total = float(row.get("total", 0.0))
                paid = float(row.get("paid", 0.0))
                rem = total - paid
                display = f"{doc} — {date} — Total {total:.2f} Paid {paid:.2f} Rem {rem:.2f}"
                self.applySalePicker.addItem(display, row)
            self._update_apply_remaining()

        # Available credit labels (if adapter)
        if self._get_available_advance:
            try:
                bal = float(self._get_available_advance(self._customer_id))
                if hasattr(self, "availableLabel"):
                    self.availableLabel.setText(f"{bal:.2f}")
                if hasattr(self, "applyAvailLabel"):
                    self.applyAvailLabel.setText(f"{bal:.2f}")
            except Exception:
                pass

    def _load_bank_accounts(self) -> None:
        if not hasattr(self, "bankAccountCombo"):
            return
        self.bankAccountCombo.clear()
        self.bankAccountCombo.addItem("", None)  # blank row
        accounts: list[dict] = []
        try:
            if self._list_company_bank_accounts:
                accounts = list(self._list_company_bank_accounts())
        except Exception:
            accounts = []
        for acc in accounts:
            self.bankAccountCombo.addItem(str(acc.get("name", "")), int(acc.get("id")))

        # Preselect bank by id if provided
        if self._prefill_bank_id is not None:
            for i in range(self.bankAccountCombo.count()):
                if self.bankAccountCombo.itemData(i) == self._prefill_bank_id:
                    self.bankAccountCombo.setCurrentIndex(i)
                    break

    def _lock_sale_if_needed(self) -> None:
        if self._locked_sale_id is None:
            return
        # Receipt page
        for i in range(self.salePicker.count()):
            data = self.salePicker.itemData(i)
            if isinstance(data, dict) and str(data.get("sale_id", "")) == self._locked_sale_id:
                self.salePicker.setCurrentIndex(i)
                break
        else:
            placeholder = {"sale_id": self._locked_sale_id, "doc_no": self._locked_sale_id, "date": "", "total": 0.0, "paid": 0.0}
            self.salePicker.addItem(self._locked_sale_id, placeholder)
            self.salePicker.setCurrentIndex(self.salePicker.count() - 1)
        self.salePicker.setEnabled(False)

        # Apply page
        for i in range(self.applySalePicker.count()):
            data = self.applySalePicker.itemData(i)
            if isinstance(data, dict) and str(data.get("sale_id", "")) == self._locked_sale_id:
                self.applySalePicker.setCurrentIndex(i)
                self.applySalePicker.setEnabled(False)
                break

    # ---------- Prefills (receipt page only) ----------
    def _apply_prefills_receipt(self) -> None:
        if not hasattr(self, "methodCombo"):
            return
        if self._prefill_method in METHODS:
            self.methodCombo.setCurrentIndex(METHODS.index(self._prefill_method))

        if isinstance(self._prefill_amount, (int, float)):
            self.amountEdit.setValue(float(self._prefill_amount))

        if self._prefill_date:
            self._set_date_from_str(self.dateEdit, self._prefill_date)
        elif self._today:
            self._set_date_from_str(self.dateEdit, self._today())

        if self._prefill_instrument_type in INSTRUMENT_TYPES:
            self.instrumentTypeCombo.setCurrentIndex(INSTRUMENT_TYPES.index(self._prefill_instrument_type))

        if self._prefill_instrument_no:
            self.instrumentNoEdit.setText(str(self._prefill_instrument_no))

        if self._prefill_instrument_date:
            self._set_date_from_str(self.instrumentDateEdit, self._prefill_instrument_date)
        if self._prefill_deposited_date:
            self._set_date_from_str(self.depositedDateEdit, self._prefill_deposited_date)

        if self._prefill_clearing_state in CLEARING_STATES:
            self.clearingStateCombo.setCurrentIndex(CLEARING_STATES.index(self._prefill_clearing_state))

        if self._prefill_cleared_date:
            self._set_date_from_str(self.clearedDateEdit, self._prefill_cleared_date)

        if self._prefill_ref_no:
            self.refNoEdit.setText(str(self._prefill_ref_no))

        if self._prefill_notes:
            self.notesEdit.setPlainText(str(self._prefill_notes))

        if self._prefill_created_by is not None:
            self.createdByEdit.setText(str(self._prefill_created_by))

    # ---------- Signals / UX (receipt) ----------
    def _on_method_changed(self) -> None:
        method = self.methodCombo.currentText()

        # Force/default instrument type
        forced = METHOD_TO_FORCED_INSTRUMENT.get(method)
        if forced in INSTRUMENT_TYPES:
            self.instrumentTypeCombo.setCurrentIndex(INSTRUMENT_TYPES.index(forced))

        # Default clearing state
        default_clear = METHOD_TO_DEFAULT_CLEARING.get(method, "posted")
        if default_clear in CLEARING_STATES:
            self.clearingStateCombo.setCurrentIndex(CLEARING_STATES.index(default_clear))

        # Bank requirement
        needs_bank = method in METHODS_REQUIRE_BANK
        self.bankAccountCombo.setEnabled(needs_bank)
        self._set_required_label(self.bankAccountCombo, needs_bank)
        if method == "Cash":
            self.bankAccountCombo.setCurrentIndex(0)  # blank

        # Instrument number required?
        req_inst = method in METHODS_REQUIRE_INSTR_NO
        self._set_required_label(self.instrumentNoEdit, req_inst)

        # UX focus
        if needs_bank:
            self.bankAccountCombo.setFocus()
        elif req_inst:
            self.instrumentNoEdit.setFocus()
        else:
            self.amountEdit.setFocus()

        self._update_hint()
        self._validate_live()

    def _on_clearing_changed(self) -> None:
        state = self.clearingStateCombo.currentText()
        enable_cd = state == "cleared"
        self.clearedDateEdit.setEnabled(enable_cd)
        if not enable_cd:
            self._clear_date(self.clearedDateEdit)
        self._validate_live()

    def _update_hint(self) -> None:
        idx = self.pageStack.currentIndex()
        hint = ""
        if idx == self.PAGE_RECEIPT:
            method = self.methodCombo.currentText()
            if method == "Cash":
                hint = _t("Negative amounts allowed. Bank must be blank. Instrument no optional.")
            elif method == "Bank Transfer":
                hint = _t("Incoming only (>0). Company bank required. Instrument type 'online'. Instrument no required.")
            elif method == "Cheque":
                hint = _t("Incoming only (>0). Company bank required. Type 'cross_cheque'. Cheque no required.")
            elif method == "Cash Deposit":
                hint = _t("Incoming only (>0). Company bank required. Type 'cash_deposit'. Deposit slip no required.")
            elif method in ("Card", "Other"):
                hint = _t("Incoming only (>0). Bank optional. Instrument no optional.")
        elif idx == self.PAGE_ADVANCE:
            hint = _t("Record a positive customer advance (store credit). No method or bank needed.")
        elif idx == self.PAGE_APPLY:
            hint = _t("Apply available advance to an open sale. Amount must not exceed available credit or remaining due.")
        self.hintLabel.setText(hint)

    def _update_remaining(self) -> None:
        data = self.salePicker.currentData()
        if isinstance(data, dict):
            total = float(data.get("total", 0.0))
            paid = float(data.get("paid", 0.0))
            rem = total - paid
            self.saleRemainingLabel.setText(_t(f"Remaining: ${rem:.2f}"))
        else:
            self.saleRemainingLabel.setText("")

    # ---------- Apply page helpers ----------
    def _update_apply_remaining(self) -> None:
        data = self.applySalePicker.currentData()
        if isinstance(data, dict):
            total = float(data.get("total", 0.0))
            paid = float(data.get("paid", 0.0))
            rem = total - paid
            # If adapter exists, prefer it for more accurate due
            if self._get_sale_due and str(data.get("sale_id", "")):
                try:
                    rem = float(self._get_sale_due(str(data.get("sale_id"))))
                except Exception:
                    pass
            self.applySaleRemainingLabel.setText(f"{rem:.2f}")
        else:
            self.applySaleRemainingLabel.setText("")

    # ---------- Validation (receipt) ----------
    def _validate_live(self) -> None:
        if self.pageStack.currentIndex() != self.PAGE_RECEIPT:
            return
        ok, msg = self._validate_receipt()
        self.errorLabel.setText(msg or "")
        self.saveBtn.setEnabled(ok)

    def _validate_receipt(self) -> tuple[bool, Optional[str]]:
        # 1) Sale present
        sale_dict = self.salePicker.currentData()
        if not isinstance(sale_dict, dict) or not str(sale_dict.get("sale_id", "")):
            return False, _t("Please select a sale for this receipt.")

        # 2) Method supported
        method = self.methodCombo.currentText()
        if method not in METHODS:
            return False, _t("Payment method is not supported.")

        # 3) Amount sign/zero
        amount = float(self.amountEdit.value())
        if abs(amount) < 1e-9:
            return False, _t("Amount cannot be zero.")
        if amount < 0 and method != "Cash":
            return False, _t("Refunds (negative amounts) are only allowed with the Cash method.")

        # 4) Bank rules
        bank_id = self._current_bank_id()
        if method == "Cash":
            if bank_id is not None:
                return False, _t("Bank must be empty when method is Cash.")
        elif method in METHODS_REQUIRE_BANK and bank_id is None:
            return False, _t("Company bank account is required for this method.")

        # 5) Instrument type enforcement
        instype = self.instrumentTypeCombo.currentText()
        if instype not in INSTRUMENT_TYPES:
            return False, _t("Payment method is not supported.")
        forced = METHOD_TO_FORCED_INSTRUMENT.get(method)
        if method in ("Bank Transfer", "Cheque", "Cash Deposit") and instype != forced:
            if method == "Bank Transfer":
                return False, _t("Instrument type must be 'online' for Bank Transfer.")
            if method == "Cheque":
                return False, _t("Instrument type must be 'cross_cheque' for Cheque.")
            if method == "Cash Deposit":
                return False, _t("Instrument type must be 'cash_deposit' for Cash Deposit.")

        # 6) Instrument number requirement
        inst_no = self.instrumentNoEdit.text().strip()
        if method in METHODS_REQUIRE_INSTR_NO and not inst_no:
            return False, _t("Please enter instrument/reference number.")

        # 7) Clearing state & dates
        state = self.clearingStateCombo.currentText()
        if state == "cleared":
            if not self._has_date(self.clearedDateEdit):
                return False, _t("Please select a cleared date.")

        # 8) Dates string format safety
        for de in (self.dateEdit, self.instrumentDateEdit, self.depositedDateEdit, self.clearedDateEdit):
            if self._has_date(de):
                s = de.date().toString("yyyy-MM-dd")
                if len(s) != 10:
                    return False, _t("Please enter dates in YYYY-MM-DD.")

        return True, None

    # ---------- Validation (advance) ----------
    def _validate_live_advance(self) -> None:
        if self.pageStack.currentIndex() != self.PAGE_ADVANCE:
            return
        ok, msg = self._validate_advance()
        self.errorLabel.setText(msg or "")
        self.saveBtn.setEnabled(ok)

    def _validate_advance(self) -> tuple[bool, Optional[str]]:
        amt = float(self.advAmountEdit.value())
        if amt <= 0.0:
            return False, _t("Amount must be greater than zero.")
        # no upper bound for grant_credit (business rules allow any positive)
        return True, None

    # ---------- Validation (apply advance) ----------
    def _validate_live_apply(self) -> None:
        if self.pageStack.currentIndex() != self.PAGE_APPLY:
            return
        ok, msg = self._validate_apply()
        self.errorLabel.setText(msg or "")
        self.saveBtn.setEnabled(ok)

    def _validate_apply(self) -> tuple[bool, Optional[str]]:
        # Sale present
        data = self.applySalePicker.currentData()
        if not isinstance(data, dict) or not str(data.get("sale_id", "")):
            return False, _t("Please select a sale to apply the advance.")

        amt = float(self.applyAmountEdit.value())
        if amt <= 0.0:
            return False, _t("Amount must be greater than zero.")

        # Bounds (best-effort via adapters; repo will enforce again)
        # available credit
        if self._get_available_advance:
            try:
                bal = float(self._get_available_advance(self._customer_id))
                if amt - bal > 1e-9:
                    return False, _t("Amount exceeds available customer advance.")
            except Exception:
                pass
        # sale due
        try:
            rem = None
            if self._get_sale_due and str(data.get("sale_id", "")):
                rem = float(self._get_sale_due(str(data.get("sale_id"))))
            else:
                total = float(data.get("total", 0.0))
                paid = float(data.get("paid", 0.0))
                rem = total - paid
            if amt - rem > 1e-9:
                return False, _t("Amount exceeds remaining due for the selected sale.")
        except Exception:
            pass

        return True, None

    # ---------- Save ----------
    def _on_save(self) -> None:
        idx = self.pageStack.currentIndex()
        if idx == self.PAGE_RECEIPT:
            ok, msg = self._validate_receipt()
            if not ok:
                self._warn(msg); return
            self._payload = self._build_payload_receipt()
        elif idx == self.PAGE_ADVANCE:
            ok, msg = self._validate_advance()
            if not ok:
                self._warn(msg); return
            self._payload = self._build_payload_advance()
        elif idx == self.PAGE_APPLY:
            ok, msg = self._validate_apply()
            if not ok:
                self._warn(msg); return
            self._payload = self._build_payload_apply()

        self.accept()

    def payload(self) -> Optional[dict]:
        return self._payload

    # ---------- Helpers ----------
    def _warn(self, msg: Optional[str]) -> None:
        self.errorLabel.setText(msg or "")
        QMessageBox.warning(self, _t("Cannot Save"), msg or _t("Please correct the highlighted fields."))

    def _current_bank_id(self) -> Optional[int]:
        data = self.bankAccountCombo.currentData()
        return int(data) if isinstance(data, int) else None

    def _set_required_label(self, widget: QWidget, required: bool) -> None:
        label = getattr(self, "_label_map", {}).get(widget)
        if not label:
            return
        base = label.text().rstrip(" *")
        label.setText(base + (" *" if required else ""))

    def _set_date_from_str(self, edit: QDateEdit, s: str) -> None:
        try:
            y, m, d = map(int, s.split("-"))
            edit.setDate(QDate(y, m, d))
        except Exception:
            pass

    def _has_date(self, edit: QDateEdit) -> bool:
        return True  # QDateEdit always has a date unless using special values

    def _clear_date(self, edit: QDateEdit) -> None:
        edit.setDate(QDate.currentDate())

    # ---------- Build payloads ----------
    def _build_payload_receipt(self) -> dict:
        sale_dict = self.salePicker.currentData() or {}

        def date_or_none(edit: QDateEdit) -> Optional[str]:
            if edit.isEnabled():
                return edit.date().toString("yyyy-MM-dd")
            return None

        payload = {
            "sale_id": str(sale_dict.get("sale_id")),
            "amount": float(self.amountEdit.value()),
            "method": self.methodCombo.currentText(),
            "date": self.dateEdit.date().toString("yyyy-MM-dd"),
            "bank_account_id": self._current_bank_id(),
            "instrument_type": self.instrumentTypeCombo.currentText() or None,
            "instrument_no": (self.instrumentNoEdit.text().strip() or None),
            "instrument_date": date_or_none(self.instrumentDateEdit),
            "deposited_date": date_or_none(self.depositedDateEdit),
            "clearing_state": self.clearingStateCombo.currentText() or None,
            "cleared_date": (self.clearedDateEdit.date().toString("yyyy-MM-dd") if self.clearedDateEdit.isEnabled() else None),
            "ref_no": (self.refNoEdit.text().strip() or None),
            "notes": (self.notesEdit.toPlainText().strip() or None),
            "created_by": (int(self.createdByEdit.text()) if self.createdByEdit.text().strip() else None),
        }
        return payload

    def _build_payload_advance(self) -> dict:
        payload = {
            "customer_id": self._customer_id,
            "amount": float(self.advAmountEdit.value()),
            "date": self.advDateEdit.date().toString("yyyy-MM-dd"),
            "notes": (self.advNotesEdit.toPlainText().strip() or None),
            "created_by": (int(self.advCreatedByEdit.text()) if self.advCreatedByEdit.text().strip() else None),
        }
        return payload

    def _build_payload_apply(self) -> dict:
        sale_dict = self.applySalePicker.currentData() or {}
        payload = {
            "customer_id": self._customer_id,
            "sale_id": str(sale_dict.get("sale_id")),
            "amount": float(self.applyAmountEdit.value()),
            "date": self.applyDateEdit.date().toString("yyyy-MM-dd"),
            "notes": (self.applyNotesEdit.toPlainText().strip() or None),
            "created_by": (int(self.applyCreatedByEdit.text()) if self.applyCreatedByEdit.text().strip() else None),
        }
        return payload

```

inventory_management/modules/sales/form.py
```
from PySide6.QtWidgets import (
    QDialog, QFormLayout, QDialogButtonBox, QVBoxLayout, QHBoxLayout, QComboBox,
    QDateEdit, QLineEdit, QLabel, QGroupBox, QTableWidget, QTableWidgetItem,
    QPushButton, QAbstractItemView, QCompleter, QWidget
)
from PySide6.QtCore import Qt, QDate
from ...database.repositories.customers_repo import CustomersRepo
    # (bank account repo is passed in, not imported here)
from ...database.repositories.products_repo import ProductsRepo
from ...utils.helpers import today_str, fmt_money
from ...utils.ui_helpers import info  # <-- added for visible validation messages


class SaleForm(QDialog):
    # Columns now include Base/Alt UoM and expanded totals logic
    COLS = ["#", "Product", "Base UoM", "Alt UoM", "Avail", "Qty", "Unit Price", "Discount", "Margin", "Line Total", ""]

    def __init__(
        self,
        parent=None,
        customers: CustomersRepo | None = None,
        products: ProductsRepo | None = None,
        bank_accounts=None,  # repo instance providing list_company_bank_accounts(); kept optional, no import here
        initial=None,
        mode: str = "sale",   # <-- NEW: 'sale' | 'quotation'
    ):
        super().__init__(parent)
        self.mode = "quotation" if str(mode).lower() == "quotation" else "sale"
        self.setWindowTitle("Quotation" if self.mode == "quotation" else "Sale")
        self.setModal(True)
        self.customers = customers; self.products = products; self.bank_accounts = bank_accounts
        self._payload = None

        # --- header widgets ---
        self.cmb_customer = QComboBox(); self.cmb_customer.setEditable(True)
        # better UX: placeholder & completer
        self.cmb_customer.lineEdit().setPlaceholderText("Type customer name…")
        self.edt_contact = QLineEdit(); self.edt_contact.setPlaceholderText("Contact (phone)")
        self.btn_add_customer = QPushButton("Add Customer"); self.btn_add_customer.setEnabled(False)

        # populate existing customers + completer + quick lookup by lower(name)
        self._customers_by_name = {}
        names = []
        for c in self.customers.list_customers():
            self.cmb_customer.addItem(f"{c.name} (#{c.customer_id})", c.customer_id)
            self._customers_by_name[c.name.lower()] = c
            names.append(c.name)

        # do NOT preselect a customer by default
        self.cmb_customer.setCurrentIndex(-1)
        self.cmb_customer.setEditText("")

        self._completer = QCompleter(names, self)
        self._completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.cmb_customer.setCompleter(self._completer)

        # auto-fill contact for existing selection
        def _fill_contact_from_sel():
            idx = self.cmb_customer.currentIndex()
            if idx >= 0:
                cid = self.cmb_customer.currentData()
                c = self.customers.get(cid)
                if c:
                    self.edt_contact.setText(c.contact_info or "")
        self.cmb_customer.currentIndexChanged.connect(lambda _=None: _fill_contact_from_sel())

        # enable/disable "Add Customer" when new name + contact are provided
        def _update_add_customer_state():
            name = (self.cmb_customer.currentText() or "").strip()
            enable = bool(name) and name.lower() not in self._customers_by_name and bool((self.edt_contact.text() or "").strip())
            self.btn_add_customer.setEnabled(enable)

        self.cmb_customer.currentTextChanged.connect(lambda _=None: _update_add_customer_state())
        self.edt_contact.textChanged.connect(lambda _=None: _update_add_customer_state())

        def _add_customer_now():
            name = (self.cmb_customer.currentText() or "").strip()
            contact = (self.edt_contact.text() or "").strip()
            if not name or not contact:
                return
            new_id = self.customers.create(name=name, contact_info=contact, address=None)
            # refresh list & completer
            self.cmb_customer.blockSignals(True)
            self.cmb_customer.clear(); self._customers_by_name.clear()
            names = []
            for c in self.customers.list_customers():
                self.cmb_customer.addItem(f"{c.name} (#{c.customer_id})", c.customer_id)
                self._customers_by_name[c.name.lower()] = c
                names.append(c.name)
            self._completer = QCompleter(names, self); self._completer.setCaseSensitivity(Qt.CaseInsensitive)
            self.cmb_customer.setCompleter(self._completer)
            # select new customer
            idx = self.cmb_customer.findData(new_id)
            if idx >= 0: self.cmb_customer.setCurrentIndex(idx)
            self.cmb_customer.blockSignals(False)
            self.btn_add_customer.setEnabled(False)

        self.btn_add_customer.clicked.connect(_add_customer_now)

        # date / discount / notes
        self.date = QDateEdit(); self.date.setCalendarPopup(True)
        self.date.setDate(QDate.fromString(initial["date"], "yyyy-MM-dd") if initial and initial.get("date") else QDate.fromString(today_str(), "yyyy-MM-dd"))

        self.txt_discount = QLineEdit(); self.txt_discount.setPlaceholderText("0")
        self.txt_notes = QLineEdit()

        # make header fields narrower
        maxw = 360
        for w in (self.cmb_customer, self.edt_contact, self.btn_add_customer, self.date, self.txt_discount, self.txt_notes):
            w.setMaximumWidth(maxw)

        # --- items box & table ---
        box = QGroupBox("Items"); ib = QVBoxLayout(box)
        self.tbl = QTableWidget(0, len(self.COLS))
        self.tbl.setHorizontalHeaderLabels(self.COLS)
        self.tbl.verticalHeader().setVisible(False)
        self.tbl.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tbl.setEditTriggers(QAbstractItemView.AllEditTriggers)
        ib.addWidget(self.tbl, 1)
        add = QHBoxLayout(); self.btn_add_row = QPushButton("Add Row"); add.addWidget(self.btn_add_row); add.addStretch(1); ib.addLayout(add)

        # bottom totals (richer summary)
        tot = QHBoxLayout()
        self.lab_sub_raw   = QLabel("0.00")   # sum(qty * unit_price)
        self.lab_line_disc = QLabel("0.00")   # sum(qty * per-unit discount)
        self.lab_order_disc= QLabel("0.00")   # order discount field value
        self.lab_overall   = QLabel("0.00")   # total discount = line + order
        self.lab_total     = QLabel("0.00")   # sub_raw - overall
        tot.addStretch(1)
        for cap, w in (("Subtotal:", self.lab_sub_raw),
                       ("Line Discount:", self.lab_line_disc),
                       ("Order Discount:", self.lab_order_disc),
                       ("Total Discount:", self.lab_overall),
                       ("Total:", self.lab_total)):
            tot.addWidget(QLabel(cap)); tot.addWidget(w)

        # payment strip (wrapped in a widget so we can hide for quotations)
        self.pay_box = QWidget()
        pay = QHBoxLayout(self.pay_box)
        self.pay_amount = QLineEdit(); self.pay_amount.setPlaceholderText("0")
        self.pay_method = QComboBox(); self.pay_method.addItems(["Cash","Bank Transfer","Card","Cheque","Other"])
        pay.addStretch(1); pay.addWidget(QLabel("Initial Payment:")); pay.addWidget(self.pay_amount)
        pay.addWidget(QLabel("Method:")); pay.addWidget(self.pay_method)

        # --- Bank details strip (visible only when Method == "Bank Transfer") ---
        self.bank_box = QWidget()
        bank_layout = QHBoxLayout(self.bank_box)
        bank_layout.setContentsMargins(0, 0, 0, 0)
        self.cmb_bank_account = QComboBox()
        self.cmb_bank_account.setMinimumWidth(280)
        self.edt_instr_no = QLineEdit(); self.edt_instr_no.setPlaceholderText("Transaction/Reference No.")
        bank_layout.addStretch(1)
        bank_layout.addWidget(QLabel("Bank Account:"))
        bank_layout.addWidget(self.cmb_bank_account)
        bank_layout.addWidget(QLabel("Reference No.:"))
        bank_layout.addWidget(self.edt_instr_no)

        # Populate bank accounts if repo provided
        try:
            if self.bank_accounts and hasattr(self.bank_accounts, "list_company_bank_accounts"):
                for a in self.bank_accounts.list_company_bank_accounts():
                    # Expecting fields: bank_account_id, bank_name, account_title, account_no
                    label = f"{a['bank_name']} — {a['account_title']} ({a['account_no']})"
                    self.cmb_bank_account.addItem(label, int(a["bank_account_id"]))
        except Exception:
            # Silent: if repo call fails, leave empty; validation will handle later.
            pass

        self.bank_box.setVisible(False)  # hidden by default; toggled by method selection

        # layout assembly
        lay = QVBoxLayout(self)
        form = QFormLayout()
        form.addRow("Customer*", self.cmb_customer)
        form.addRow("Contact", self.edt_contact)
        form.addRow("", self.btn_add_customer)
        form.addRow("Date*", self.date)
        form.addRow("Order Discount", self.txt_discount)
        form.addRow("Notes", self.txt_notes)
        lay.addLayout(form); lay.addWidget(box, 1); lay.addLayout(tot)

        # Add payment/ bank strips only for 'sale' mode (hidden for quotations)
        lay.addWidget(self.pay_box)
        lay.addWidget(self.bank_box)
        if self.mode == "quotation":
            self.pay_box.setVisible(False)
            self.bank_box.setVisible(False)

        self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept); self.buttons.rejected.connect(self.reject); lay.addWidget(self.buttons)
        self.resize(1200, 600); self.setSizeGripEnabled(True)

        # wiring
        self.tbl.cellChanged.connect(self._cell_changed)
        self.btn_add_row.clicked.connect(self._add_row)
        self.txt_discount.textChanged.connect(self._refresh_totals)
        self.pay_method.currentTextChanged.connect(self._toggle_bank_fields)

        # seed table
        self._rows = [dict(x) for x in (initial.get("items") or [])] if initial else []
        self._rebuild_table()
        if initial:
            i = self.cmb_customer.findData(initial.get("customer_id"))
            if i >= 0: self.cmb_customer.setCurrentIndex(i)
            self.txt_discount.setText(str(initial.get("order_discount", 0) or 0))
            self.txt_notes.setText(initial.get("notes") or "")

    # --- helpers ---
    def _toggle_bank_fields(self, text: str):
        # Only relevant in sale mode
        if self.mode != "sale":
            self.bank_box.setVisible(False)
            return
        self.bank_box.setVisible(text == "Bank Transfer")

    def _warn(self, title: str, message: str, focus_widget=None, row_to_select: int | None = None):
        """Show a friendly message, focus a widget, optionally select a row."""
        info(self, title, message)
        if focus_widget:
            focus_widget.setFocus()
        if row_to_select is not None and 0 <= row_to_select < self.tbl.rowCount():
            try:
                self.tbl.clearSelection()
                self.tbl.selectRow(row_to_select)
            except Exception:
                pass

    def _all_products(self):
        return self.products.list_products()

    def _base_uom_id(self, product_id: int) -> int:
        base = self.products.get_base_uom(product_id)
        if base: return int(base["uom_id"])
        u = self.products.list_uoms()
        return int(u[0]["uom_id"]) if u else 1

    def _add_row(self, pre: dict | None = None):
        self.tbl.blockSignals(True)
        r = self.tbl.rowCount(); self.tbl.insertRow(r)

        # row number
        num = QTableWidgetItem(str(r+1))
        num.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        self.tbl.setItem(r, 0, num)

        # product combo (lazy import)
        from PySide6.QtWidgets import QComboBox
        cmb = QComboBox()
        for p in self._all_products():
            cmb.addItem(f"{p.name} (#{p.product_id})", p.product_id)
        self.tbl.setCellWidget(r, 1, cmb)

        # Base UoM (read-only label cell)
        base_cell = QTableWidgetItem("-")
        base_cell.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        self.tbl.setItem(r, 2, base_cell)

        # Alt UoM (combo; disabled when no alternates)
        alt = QComboBox(); alt.setEnabled(False)
        self.tbl.setCellWidget(r, 3, alt)

        # Avail (read-only)
        avail = QTableWidgetItem("0")
        avail.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        avail.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.tbl.setItem(r, 4, avail)

        # Qty (editable)
        qty = QTableWidgetItem("0"); qty.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.tbl.setItem(r, 5, qty)

        # Unit Price (read-only; per selected UoM)
        unit = QTableWidgetItem("0.00")
        unit.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        unit.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.tbl.setItem(r, 6, unit)

        # Discount (per-unit; editable)
        disc = QTableWidgetItem("0"); disc.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.tbl.setItem(r, 7, disc)

        # Margin (total for the line; read-only)
        marg = QTableWidgetItem("0.00")
        marg.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        marg.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.tbl.setItem(r, 8, marg)

        # Line Total (read-only)
        ltot = QTableWidgetItem("0.00")
        ltot.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        ltot.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.tbl.setItem(r, 9, ltot)

        # delete button
        btn = QPushButton("✕")
        def kill():
            self.tbl.removeRow(r); self._reindex(); self._refresh_totals()
        btn.clicked.connect(kill); self.tbl.setCellWidget(r, 10, btn)

        # when product changes → base uom name, alt list, prices, avail
        def on_prod():
            pid = cmb.currentData()
            if not pid:
                base_cell.setText("-"); alt.clear(); alt.setEnabled(False)
                return
            # base + alternates (requires ProductsRepo.list_product_uoms)
            uoms = self.products.list_product_uoms(int(pid))
            base = next((u for u in uoms if u["is_base"]), None)
            alts = [u for u in uoms if not u["is_base"]]
            base_cell.setText(base["unit_name"] if base else "-")
            # store base uom id in row-number col UserRole; base factor in Base UoM col UserRole
            self.tbl.item(r, 0).setData(Qt.UserRole, int(base["uom_id"]) if base else None)
            self.tbl.item(r, 2).setData(Qt.UserRole, float(base["factor_to_base"]) if base else 1.0)

            # build alt combo: first item = “— base —”
            alt.blockSignals(True); alt.clear()
            alt.addItem("— base —", None)
            for u in alts:
                alt.addItem(u["unit_name"], (int(u["uom_id"]), float(u["factor_to_base"])))
            alt.setEnabled(bool(alts))
            alt.blockSignals(False)

            # prices (BASE per-unit) and stock (BASE)
            pr = self.products.latest_prices_base(int(pid))
            cost_base = float(pr["cost"]); sale_base = float(pr["sale"])
            unit.setData(Qt.UserRole, cost_base)  # store base cost for margin math
            unit.setText(fmt_money(sale_base))    # display base price by default

            # availability in BASE initially; alt handler will convert
            avail_base = self.products.on_hand_base(int(pid))
            avail.setText(f"{avail_base:g}")

            self._recalc_row(r); self._refresh_totals()

        def on_alt_changed():
            # when alt UoM changes → convert price & avail for display
            data = alt.currentData()
            pid = cmb.currentData()
            if not pid:
                return
            pr = self.products.latest_prices_base(int(pid))
            sale_base = float(pr["sale"])
            cost_base = float(unit.data(Qt.UserRole) or 0.0)
            avail_base = self.products.on_hand_base(int(pid))

            if data is None:
                # base uom
                unit.setText(fmt_money(sale_base))
                avail.setText(f"{avail_base:g}")
            else:
                _, f = data
                unit.setText(fmt_money(sale_base * f))
                # availability in selected UoM = base / f
                avail.setText(f"{(avail_base / f):g}")
            self._recalc_row(r); self._refresh_totals()

        cmb.currentIndexChanged.connect(on_prod)
        alt.currentIndexChanged.connect(on_alt_changed)
        on_prod()

        # prefill for edit
        if pre:
            i = cmb.findData(pre.get("product_id"))
            if i >= 0: cmb.setCurrentIndex(i)
            # Alt UoM selection if provided (after on_prod() built alt list)
            alt_cb = self.tbl.cellWidget(r, 3)
            if pre.get("uom_id") and self.tbl.item(r,0).data(Qt.UserRole) != pre["uom_id"] and isinstance(alt_cb, QComboBox):
                for k in range(alt_cb.count()):
                    data = alt_cb.itemData(k)
                    if isinstance(data, tuple) and data[0] == pre["uom_id"]:
                        alt_cb.setCurrentIndex(k); break
            # qty / price / discount
            self.tbl.item(r,5).setText(str(pre.get("quantity", 0)))
            self.tbl.item(r,6).setText(fmt_money(pre.get("unit_price", 0)))
            self.tbl.item(r,7).setText(str(pre.get("item_discount", 0)))

        self.tbl.blockSignals(False)
        self._recalc_row(r)

    def _reindex(self):
        for r in range(self.tbl.rowCount()):
            it = self.tbl.item(r,0)
            if it: it.setText(str(r+1))

    def _rebuild_table(self):
        self.tbl.blockSignals(True)
        self.tbl.setRowCount(0)
        if not self._rows:
            self._add_row({})
        else:
            for row in self._rows:
                self._add_row(row)
        self.tbl.blockSignals(False)
        self._refresh_totals()

    def _cell_changed(self, row:int, col:int):
        # Only Qty (5) and Discount (7) are editable; respond to those changes
        if col not in (5, 7):
            return
        for c in (4,5,6,7,9):
            if self.tbl.item(row,c) is None: return
        self._recalc_row(row); self._refresh_totals()

    # qty-aware margin; per-unit margin shown in tooltip; oversell in selected UoM
    def _recalc_row(self, r:int):
        def num(c):
            it = self.tbl.item(r,c)
            try: return float(it.text().replace(",","")) if it and it.text() else 0.0
            except Exception: return 0.0

        # selected UoM factor: None = base (factor 1)
        alt = self.tbl.cellWidget(r, 3)
        data = alt.currentData() if alt else None
        factor = float(data[1]) if data else 1.0

        avail = num(4)             # already shown in selected UoM
        qty   = num(5)
        unit  = num(6)             # per selected UoM
        disc  = num(7)             # per selected UoM
        # base cost (per base unit) was stored in UserRole of Unit Price; convert to selected UoM
        cost_base = float(self.tbl.item(r,6).data(Qt.UserRole) or 0.0)
        cost_uom  = cost_base * factor

        over = qty > avail and avail >= 0
        it_qty = self.tbl.item(r,5)
        if it_qty: it_qty.setBackground(Qt.red if over else Qt.white)

        # total margin (qty-aware). Per-unit margin in tooltip.
        m_unit = (unit - disc) - cost_uom
        m_tot  = qty * m_unit
        it_m = self.tbl.item(r,8)
        if it_m:
            it_m.setText(fmt_money(m_tot))
            it_m.setToolTip(f"Per-unit margin: {fmt_money(m_unit)}")
            it_m.setBackground(Qt.red if m_tot < 0 else Qt.white)

        # line total (before order discount)
        lt = max(0.0, qty * (unit - disc))
        it_lt = self.tbl.item(r,9)
        if it_lt: it_lt.setText(fmt_money(lt))

    # ---- totals helpers (raw subtotal & line discount) ----
    def _calc_raw_subtotal(self) -> float:
        s = 0.0
        for r in range(self.tbl.rowCount()):
            try:
                qty  = float(self.tbl.item(r,5).text() or 0)
                unit = float(self.tbl.item(r,6).text().replace(",","") or 0)
                s += qty * unit
            except Exception:
                pass
        return s

    def _calc_line_discount(self) -> float:
        s = 0.0
        for r in range(self.tbl.rowCount()):
            try:
                qty  = float(self.tbl.item(r,5).text() or 0)
                disc = float(self.tbl.item(r,7).text() or 0)
                s += qty * disc
            except Exception:
                pass
        return s

    def _refresh_totals(self):
        sub_raw = self._calc_raw_subtotal()
        line_disc = self._calc_line_discount()
        try: od = float(self.txt_discount.text() or 0)
        except Exception: od = 0.0
        overall = line_disc + od
        total = max(0.0, sub_raw - overall)
        self.lab_sub_raw.setText(fmt_money(sub_raw))
        self.lab_line_disc.setText(fmt_money(line_disc))
        self.lab_order_disc.setText(fmt_money(od))
        self.lab_overall.setText(fmt_money(overall))
        self.lab_total.setText(fmt_money(total))

    # payload with visible validation and row highlighting
    def get_payload(self) -> dict | None:
        # customer must be chosen or added
        cid = self.cmb_customer.currentData()
        if not cid:
            self._warn("Missing Customer", "Please select an existing customer or add a new one.", self.cmb_customer)
            return None

        errors = []
        items = []

        # row-by-row validation with specific messages
        for r in range(self.tbl.rowCount()):
            try:
                # widgets
                from PySide6.QtWidgets import QComboBox  # lazy import retained
                cmb: QComboBox = self.tbl.cellWidget(r, 1)
                alt: QComboBox = self.tbl.cellWidget(r, 3)

                # product
                if not cmb or cmb.currentData() is None:
                    errors.append(f"Row {r+1}: Select a product.")
                    continue
                pid = int(cmb.currentData())

                # numbers in selected UoM (as displayed)
                def num(c):
                    it = self.tbl.item(r, c)
                    return float(it.text().replace(",", "")) if it and it.text() else 0.0

                avail = num(4)
                qty   = num(5)
                unit  = num(6)
                disc  = num(7)

                if qty <= 0:
                    errors.append(f"Row {r+1}: Quantity must be greater than 0.")
                    continue
                if unit <= 0:
                    errors.append(f"Row {r+1}: Unit Price must be greater than 0.")
                    continue
                if disc < 0:
                    errors.append(f"Row {r+1}: Discount cannot be negative.")
                    continue
                # oversell guard in the selected UoM
                if qty > avail:
                    errors.append(f"Row {r+1}: Quantity ({qty:g}) exceeds available ({avail:g}).")
                    continue

                # uom_id: base vs alt
                base_uom_id = int(self.tbl.item(r, 0).data(Qt.UserRole) or 0)
                uom_id = base_uom_id
                if alt and isinstance(alt.currentData(), tuple):
                    uom_id = int(alt.currentData()[0])

                items.append({
                    "product_id": pid,
                    "uom_id": int(uom_id),
                    "quantity": qty,
                    "unit_price": unit,
                    "item_discount": disc,
                })
            except Exception:
                errors.append(f"Row {r+1}: Invalid or incomplete data.")
                continue

        if errors and not items:
            # If nothing valid, show the first few issues and select the first bad row
            self._warn("Please fix these issues",
                       "\n".join(errors[:6] + (["…"] if len(errors) > 6 else [])),
                       focus_widget=self.tbl, row_to_select=0)
            return None

        if not items:
            self._warn("No Items", "Add at least one valid item to proceed.", focus_widget=self.btn_add_row)
            return None

        # order discount parsing + totals
        try:
            od = float(self.txt_discount.text() or 0)
        except Exception:
            od = 0.0

        # reuse your totals helpers
        sub_raw = self._calc_raw_subtotal()
        line_disc = self._calc_line_discount()
        total = max(0.0, sub_raw - (line_disc + od))

        payload = {
            "customer_id": int(cid),
            "date": self.date.date().toString("yyyy-MM-dd"),
            "order_discount": od,
            "notes": (self.txt_notes.text().strip() or None),
            "items": items,
            "total_amount": total,
            "line_discount_total": line_disc,
            "subtotal_raw": sub_raw,
        }

        # --- Initial payment only in SALE mode ---
        if self.mode == "sale":
            init = float(self.pay_amount.text() or 0)
            method = self.pay_method.currentText()
            payload["initial_payment"] = init
            payload["initial_method"] = method

            # Bank Transfer specifics (only when initial_payment > 0 and method == Bank Transfer)
            if init > 0 and method == "Bank Transfer":
                bank_id = self.cmb_bank_account.currentData()
                instr_no = (self.edt_instr_no.text() or "").strip()

                if bank_id is None:
                    self._warn("Bank Required", "Select a company bank account for Bank Transfer.", self.cmb_bank_account)
                    return None
                if not instr_no:
                    self._warn("Reference Required", "Enter the transaction/reference number for Bank Transfer.", self.edt_instr_no)
                    return None

                payload["initial_bank_account_id"] = int(bank_id)
                payload["initial_instrument_no"] = instr_no
                payload["initial_instrument_type"] = "online"  # fixed per rule

        return payload

    def accept(self):
        p = self.get_payload()
        if p is None:
            return
        self._payload = p; super().accept()

    def payload(self):
        return self._payload

```

inventory_management/modules/sales/item_form.py
```
# Got it. Here’s the end-to-end picture of how **Sales** and **Sale Returns** work in your app, organized by concept and by file. No code—just the logic and responsibilities.

# ---

# # 1) Data model & system behavior (from `schema.py`)

# ### Core entities

# * **customers, vendors, users, products, uoms (units of measure)** — standard masters.
# * **product\_uoms** — per-product UoMs with:

#   * exactly **one base UoM** (`is_base=1`, `factor_to_base=1`)
#   * any number of alternates (each has `factor_to_base>0`)
#   * unique constraint & trigger enforce those rules.

# ### Sales documents

# * **sales (header)**: `sale_id`, `customer_id`, `date`, `total_amount` (already net of order-level discount), `order_discount`, `payment_status` (`paid/partial/unpaid`), `paid_amount`, `notes`, `created_by`, plus `source_type/id`.
# * **sale\_items (lines)**: product, qty, uom, `unit_price`, `item_discount` (per unit).

# ### Inventory ledger & costing

# * **inventory\_transactions**: the single source of truth for stock movement.

#   * Types: `purchase`, `sale`, `sale_return`, `purchase_return`, `adjustment`.
#   * Every sale line inserts a `sale` ledger row; every return inserts a `sale_return` row.
#   * A validation trigger enforces: positive qty for non-adjustments, correct references, and product/UoM consistency with the referenced line.

# * **stock\_valuation\_history**: moving-average costing snapshot after each inventory transaction.

#   * A big **AFTER INSERT** trigger on `inventory_transactions`:

#     * Converts qty into **base UoM** using `product_uoms.factor_to_base`.
#     * Recomputes on-hand qty and **running average unit cost**.
#     * On `purchase`, it blends old value with new purchase cost (UoM-aware); other types adjust qty at the existing average cost.
#   * View **`v_stock_on_hand`** returns the latest quantity/value per product.

# ### Financial views

# * **`sale_detailed_totals`** (important for returns): gives

#   * `subtotal_before_order_discount` = Σ(qty × unit\_price − item\_discount) across lines
#   * `calculated_total_amount` = that subtotal − `order_discount`
# * **`sale_item_cogs`**: COGS for each sale item using running-average at sale date (UoM-aware).
# * **`profit_loss_view`**: month buckets = sales revenue − COGS − expenses.

# ---

# # 2) Repository layer (from `sales_repo.py`)

# ### Data carriers

# * `SaleHeader`, `SaleItem` dataclasses mirror the header/line payloads used by the controller.

# ### Reads

# * `list_sales()` → recent sales with joined customer name and money fields as REALs.
# * `search_sales(query, date)` → filter by SO or customer name and/or date (for the returns UI).
# * `get_header(sid)` → raw sales header.
# * `list_items(sid)` → line items with product & uom names, typed numbers.

# ### Writes (sales lifecycle)

# * **Create sale**:

#   1. Insert header.
#   2. Insert each line.
#   3. For each line, insert an `inventory_transactions` row of type **`sale`** referencing that line.

#      * The after-insert trigger updates stock on hand & moving-average cost.

# * **Update sale**:

#   1. Update header fields.
#   2. Delete prior sale content: all `inventory_transactions` for this sale, then all lines.
#   3. Re-insert fresh lines and corresponding `sale` inventory rows.

# * **Delete sale**:

#   * Delete sale’s inventory rows → delete lines → delete header.

# ### Returns (inventory + money helpers)

# * **record\_return(sid, date, created\_by, lines, notes)**:

#   * Inserts **`sale_return`** inventory rows for the specified `sale_items.item_id` with the returned qty (UoM-consistent with the original line).
#   * The valuation trigger adjusts on-hand at existing moving-average cost.

# * **sale\_return\_totals(sale\_id)**:

#   * Aggregates returned qty and returned value (= Σ qty\_returned × (unit\_price − item\_discount)) across the `sale_return` rows for that sale.

# ### Payments

# * **apply\_payment(sid, amount)**: increases `paid_amount`, sets `payment_status` accordingly.
# * **apply\_refund(sid, amount)**: reduces `paid_amount` (floors at 0), re-derives `payment_status`.

# ### Small helper we added

# * **get\_sale\_totals(sid)** (new): reads `sale_detailed_totals` view to get the canonical:

#   * `net_subtotal` (before order discount)
#   * `total_after_od` (after order discount)
#   * Used by the Return dialog to prorate order discount correctly.

# ---

# # 3) UI & interaction flow (by file)

# ## `sales/view.py` (container view)

# * Toolbar: **New**, **Edit**, **Return**, search box.
# * Split view:

#   * Left: main sales table + a secondary table for the selected sale’s lines.
#   * Right: **SaleDetails** panel.

# ## `sales/model.py`

# * **SalesTableModel**: columns = ID, Date, Customer, Total, Paid, Status. Formats money.
# * **SaleItemsModel**: columns = #, Product, Qty, Unit Price, Discount, Line Total (computed as qty × (price − item\_discount)).

# ## `sales/items.py`

# * **SaleItemsView**: a thin wrapper that hosts the table and model, and exposes `set_rows()`.

# ## `sales/details.py`

# * **SaleDetails** panel shows:

#   * core fields (ID, date, customer)
#   * `Total`, `Order Discount`, `Total Discount` (order + summed line-discount)
#   * placeholders for **Returned Qty**, **Returned Value**, and **Net (after returns)** (UI labels exist; filling those numbers depends on controller providing them)
#   * `Paid`, `Remaining`, and `Status`.

# ## `sales/form.py` (Create/Edit sale dialog)

# * **Header**: select or add customer (with phone), date (defaults to today), order-level discount, notes, optional initial payment (amount + method).
# * **Items grid** (each row):

#   * Product selector
#   * **Base UoM** label and **Alt UoM** combo (enabled only when alternates exist for that product)
#   * **Avail** (current on-hand in the selected UoM)
#   * **Qty** (editable)
#   * **Unit Price** (displayed per selected UoM; sourced from latest base sale price × UoM factor)
#   * **Discount** (per-unit)
#   * **Margin** (total margin for that line = qty × \[(unit − disc) − cost\_in\_selected\_uom]); highlighted red if negative
#   * **Line Total** (qty × (unit − disc))
#   * Delete button for the row
# * **Totals strip** at the bottom:

#   * Subtotal (raw) = Σ qty × unit\_price (after UoM selection, before discount)
#   * Line Discount total = Σ qty × per-unit discount
#   * Order Discount (the header field)
#   * Total Discount (line + order)
#   * **Total** = Subtotal − (Line + Order)
# * **Validation** on OK:

#   * Customer required.
#   * Each row must have product, qty > 0, unit > 0, discount ≥ 0.
#   * **Oversell guard**: qty ≤ available (in current UoM). Violations are highlighted and listed.
#   * On success, returns a payload with normalized line data (`uom_id` = base or selected alt), header totals, and optional initial payment.

# ## `sales/return_form.py` (Sale Return dialog)

# * **Search** pane: query by SO or customer, optional exact date; shows a grid of matching sales (SO/date/customer/Total/Paid).

# * Selecting a sale loads its lines into the lower grid:

#   * `Qty Sold`, `Unit Price` **net of line discount** (i.e., unit − item\_discount), and an editable `Qty Return`.

# * **Order-level discount proration**:

#   * The dialog gets **canonical totals** via `SalesRepo.get_sale_totals()`:

#     * `net_subtotal` = Σ qty × (unit − item\_discount), *before* order discount
#     * `total_after_od` = net\_subtotal − order\_discount
#   * It computes **order\_factor = total\_after\_od / net\_subtotal** (fallback 1.0 if denominator is 0).
#   * Each line’s **Line Refund** = `qty_return × (unit − item_discount) × order_factor`.
#   * **Overshoot protection**: you cannot return more than the `Qty Sold`; that cell turns red and the line ignores amounts.

# * **Whole-order toggle**: fills `Qty Return` = `Qty Sold` for all lines.

# * **Money in the footer** (post-update we agreed on):

#   * **Returned Value** = Σ line refunds (this is the actual value of goods being reversed, already after the order-level discount is prorated).
#   * **Cash Refund (max)** = `min(Returned Value, Paid)` — the most you can give back in cash immediately, based on how much the customer has already paid.
#   * If **Paid = 0**, **Refund now?** is disabled (no cash out); the returned value just reduces the outstanding balance.
#   * Context note tells the operator when the cash refund is capped by Paid.

# * **Payload on OK**:

#   * `sale_id`
#   * `lines` = \[{`item_id`, `qty_return`}…] for valid rows only
#   * `refund_now` (checkbox state)
#   * `refund_amount` = the **Returned Value** (already after proration).
#     The controller decides the actual **cash** to pay now and how much to apply to the balance.

# ---

# # 4) Controller orchestration (from `sales/controller.py`)

# ### Common

# * Generates `sale_id` as `SOYYYYMMDD-####`.
# * Wires view actions (New/Edit/Return), search filtering via `QSortFilterProxyModel`, table selection syncing.

# ### Create sale (`_add`)

# * Opens **SaleForm**.
# * Derives `payment_status` from initial payment vs total.
# * Annotates notes with an initial payment tag if provided.
# * Calls `SalesRepo.create_sale()` (header, lines, and per-line sale inventory rows).
# * UI refresh + “Saved” info.

# ### Edit sale (`_edit`)

# * Preloads existing line items and header fields into **SaleForm**.
# * On save, calls `SalesRepo.update_sale()` (rebuilds lines + inventory rows).
# * UI refresh + “Saved” info.

# ### Delete sale (`_delete`)

# * Not wired by default (commented), but implementation deletes inventory rows, lines, and header.

# ### **Return** (`_return`) — inventory + money

# 1. Open **SaleReturnForm** and read payload.
# 2. Map the payload’s `item_id`s to full line records; build **`lines`** for inventory.
# 3. Call `SalesRepo.record_return()`:

#    * Inserts `sale_return` inventory rows (valuation trigger adjusts on-hand and keeps the average cost unchanged).
# 4. Money logic (the key business rules we finalized):

#    * Let **`refund_amount`** = **Returned Value** (already after order discount proration from the dialog).

#    * Look up current header to get `total_amount` (**this is the post-order-discount amount**) and `paid_amount`.

#    * **If “Refund now?”**:

#      * **Cash refund** = `min(refund_amount, paid_before)`.
#      * Apply it via `SalesRepo.apply_refund()` (reduces `paid_amount`, re-derives `payment_status`).
#      * The remaining non-cash part (**credit\_part** = `refund_amount − cash_refund`) proceeds to balance reduction.

#    * **Reduce balance (never below zero)**:

#      * Refresh `paid_after`.
#      * `balance_before = max(0, total_before − paid_after)`.
#      * `apply_to_balance = min(credit_part, balance_before)`.
#      * `new_total = max(0, total_before − apply_to_balance)`.
#      * Update `sales.total_amount = new_total` and recompute `payment_status` from `paid_after` vs `new_total`.
#      * If any **leftover\_credit** still remains (i.e., you returned more value than the sale’s remaining balance), it is recorded as a **note** (`[Credit memo X]`) until a proper customer-ledger module exists.

#    * If **all sold quantities were returned**, append a `[Full return]` note.

#    * Show a friendly summary (what was refunded in cash, how much balance was reduced, and any credit memo).

# **Resulting behavior**

# * **Paid = 0 & whole return** → no cash out; `total_amount` is reduced to 0; `payment_status` becomes `unpaid` → `paid` (if `paid_after >= new_total`) or stays appropriate.
# * **Partial return & partial payment** → cash refund is capped by Paid; the remainder reduces outstanding balance; statuses adjust correctly; never creates negative balances or accidental over-payments.
# * **Full paid & full return** → cash up to the full `paid_amount`; any residual (if numbers drift due to rounding) only reduces `total_amount`; no negative totals.

# ---

# # 5) Business rules captured

# * **Per-unit vs order-discount**:

#   * Line totals and margins use **line discount** at the per-unit level.
#   * The **order-level discount** is handled once at the header and **prorated** across returns via `order_factor = total_after_od / net_subtotal`.
#   * This ensures returned amounts always match what the customer actually owed/paid after discounts.

# * **UoM awareness everywhere**:

#   * The sale form presents prices/availability in the selected UoM; cost/margin convert from base using `factor_to_base`.
#   * Inventory ledger always carries qty in the specified UoM and converts to base for valuation.

# * **Integrity guards**:

#   * You can’t oversell in the UI (validation).
#   * The DB refuses inventory rows that don’t match the originating line’s product/UoM or that have non-positive qty (except adjustments).
#   * Only one base UoM per product; invalid factors are blocked by triggers.

# * **Financial accuracy**:

#   * Payment status is **derived**, never free-typed.
#   * Cash refunds are **capped by Paid**; the remainder reduces balance, not paid.
#   * No negative totals or balances are created; extra value becomes a placeholder **credit memo** note.

# ---

# # 6) What changed in our updates (so you know the deltas)

# * **Return dialog math & display**

#   * Uses `SalesRepo.get_sale_totals()` (via the `sale_detailed_totals` view) to compute the proration factor reliably.
#   * Shows **two numbers** in the footer:

#     * **Returned Value** (after OD proration; equals the sum of the “Line Refund” column).
#     * **Cash Refund (max)** = `min(Returned Value, Paid)` to avoid confusion.
#   * Disables **Refund now?** when `Paid = 0`.
#   * Context note clarifies when the cash refund is capped.

# * **Controller money logic**

#   * Cash path: **min(returned\_value, paid\_before)** then `apply_refund()`.
#   * Non-cash path: reduce **outstanding balance only**, never below zero; recalc status from `paid_after` vs `new_total`.
#   * Any extra beyond the balance is stored as a simple **credit memo** in notes (until you add a proper customer ledger).
#   * Adds `[Full return]` note when appropriate.

# ---

# That’s the complete functional picture: how data flows from UI to repo to DB, how stock and valuation move, how discounts and returns are computed, and how payments/refunds/balance are enforced. If you’d like, I can also map this to a few concrete scenarios (e.g., partial return with partial payment, fully unpaid full return) and show the exact field transitions step-by-step.

```

inventory_management/modules/sales/__init__.py
```
# /home/pc/Desktop/inventory_management/modules/sales/__init__.py

"""
Sales module package exports.

Always available:
- SalesController

Optional UI/model components (imported defensively so environments
without Qt can still import this package):
- SalesView
- PaymentsView
- PaymentsTableModel
- SalesTableModel
- SaleItemsModel
- SaleForm
- SaleReturnForm
- SaleDetails
- SaleItemsView
"""

from .controller import SalesController

# UI/model pieces are optional to avoid a hard Qt dependency during headless tests
try:
    from .view import SalesView, PaymentsView, PaymentsTableModel  # type: ignore
    from .model import SalesTableModel, SaleItemsModel  # type: ignore
    from .form import SaleForm  # type: ignore
    from .return_form import SaleReturnForm  # type: ignore
    from .details import SaleDetails  # type: ignore
    from .items import SaleItemsView  # type: ignore
except Exception:  # pragma: no cover
    SalesView = None  # type: ignore
    PaymentsView = None  # type: ignore
    PaymentsTableModel = None  # type: ignore
    SalesTableModel = None  # type: ignore
    SaleItemsModel = None  # type: ignore
    SaleForm = None  # type: ignore
    SaleReturnForm = None  # type: ignore
    SaleDetails = None  # type: ignore
    SaleItemsView = None  # type: ignore

__all__ = [
    "SalesController",
    "SalesView",
    "PaymentsView",
    "PaymentsTableModel",
    "SalesTableModel",
    "SaleItemsModel",
    "SaleForm",
    "SaleReturnForm",
    "SaleDetails",
    "SaleItemsView",
]

```

inventory_management/modules/sales/return_form.py
```
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton,
    QTableWidget, QTableWidgetItem, QAbstractItemView, QLabel,
    QCheckBox, QDialogButtonBox, QDateEdit, QDoubleSpinBox
)
from PySide6.QtCore import Qt, QDate
from ...utils.helpers import today_str, fmt_money
from ...database.repositories.sales_repo import SalesRepo


class SaleReturnForm(QDialog):
    """
    Returned value (after order discount proration):
        returned_value = sum(qty_return * (unit_price - item_discount)) * (total_after_od / net_subtotal)

    Footer shows:
      - Returned Value  (after OD proration)
      - Cash Refund (now) -> operator-entered value, capped at min(Returned Value, Paid)

    Quick mode:
      If constructed with sale_id, the dialog hides the search UI and preloads that sale.
    """
    def __init__(self, parent=None, repo: SalesRepo | None = None, sale_id: str | None = None):
        super().__init__(parent)
        self.setWindowTitle("Sale Return")
        self.setModal(True)
        self.repo = repo
        self._initial_sale_id = sale_id

        lay = QVBoxLayout(self)

        # --- search bar (can be hidden in quick mode) ---
        self._search_row = QHBoxLayout()
        self.edt_q = QLineEdit()
        self.edt_q.setPlaceholderText("SO number or customer name…")
        self.edt_date = QDateEdit()
        self.edt_date.setCalendarPopup(True)
        self.edt_date.setDate(QDate.fromString(today_str(), "yyyy-MM-dd"))
        self.btn_find = QPushButton("Find")
        self._search_row.addWidget(QLabel("Search:"))
        self._search_row.addWidget(self.edt_q, 2)
        self._search_row.addWidget(QLabel("Date:"))
        self._search_row.addWidget(self.edt_date)
        self._search_row.addWidget(self.btn_find)
        lay.addLayout(self._search_row)

        # --- sales results ---
        self.tbl_sales = QTableWidget(0, 5)
        self.tbl_sales.setHorizontalHeaderLabels(["SO", "Date", "Customer", "Total", "Paid"])
        self.tbl_sales.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tbl_sales.setSelectionMode(QAbstractItemView.SingleSelection)
        lay.addWidget(self.tbl_sales, 1)

        # --- items of selected sale ---
        self.tbl_items = QTableWidget(0, 6)
        self.tbl_items.setHorizontalHeaderLabels(["ItemID", "Product", "Qty Sold", "Unit Price", "Qty Return", "Line Refund"])
        self.tbl_items.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tbl_items.setSelectionMode(QAbstractItemView.SingleSelection)
        lay.addWidget(self.tbl_items, 2)

        # --- options (return-all + refund) ---
        opt = QHBoxLayout()
        self.chk_return_all = QCheckBox("Return whole order")
        self.chk_refund = QCheckBox("Refund now?")
        opt.addWidget(self.chk_return_all)
        opt.addWidget(self.chk_refund)
        opt.addStretch(1)

        # footer values
        self.lbl_returned_value = QLabel("0.00")

        # Cash refund (operator editable)
        self.spin_cash = QDoubleSpinBox()
        self.spin_cash.setDecimals(2)
        self.spin_cash.setMinimum(0.0)
        self.spin_cash.setMaximum(0.0)  # set dynamically
        self.spin_cash.setEnabled(False)
        self._cash_user_set = False  # becomes True the first time user edits while enabled

        self.lbl_cash_cap = QLabel("(max: 0.00)")
        self.lbl_cash_cap.setStyleSheet("color:#666;")

        opt.addWidget(QLabel("Returned Value:"))
        opt.addWidget(self.lbl_returned_value)
        opt.addSpacing(16)
        opt.addWidget(QLabel("Cash Refund (now):"))
        opt.addWidget(self.spin_cash)
        opt.addWidget(self.lbl_cash_cap)
        lay.addLayout(opt)

        # helpful note when cap/credit applies
        self.lbl_note = QLabel("")
        self.lbl_note.setStyleSheet("color:#a22;")
        lay.addWidget(self.lbl_note)

        # --- dialog buttons ---
        bb = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        bb.accepted.connect(self.accept)
        bb.rejected.connect(self.reject)
        lay.addWidget(bb)

        # wiring
        self.btn_find.clicked.connect(self._search)
        self.tbl_sales.itemSelectionChanged.connect(self._load_items)
        self.tbl_items.cellChanged.connect(self._recalc)
        self.chk_return_all.toggled.connect(self._toggle_return_all)
        self.chk_refund.toggled.connect(self._on_refund_toggle)
        self.spin_cash.valueChanged.connect(self._on_cash_changed)

        # window size
        self.resize(960, 620)

        # state
        self._selected_sid: str | None = None
        self._refund_amount: float = 0.0           # returned value AFTER order-discount proration
        self._sale_total_after_od: float = 0.0     # sales.total_amount (after ORDER discount)
        self._sale_paid: float = 0.0               # sales.paid_amount
        self._sale_od: float = 0.0                 # sales.order_discount
        self._sale_net_subtotal: float = 0.0       # Σ qty * (unit_price - item_discount), BEFORE order discount

        # Quick mode: pre-select a sale and skip search UI
        if self._initial_sale_id:
            self._prime_with_sale_id(self._initial_sale_id)

    # ---- helpers ----------------------------------------------------------

    @staticmethod
    def _is_sale_row(row) -> bool:
        """Best-effort check that the row represents a real sale (not a quotation)."""
        try:
            if isinstance(row, dict):
                dt = row.get("doc_type")
            else:
                # sqlite3.Row supports mapping; .keys() may exist or not, so guard
                dt = row["doc_type"] if "doc_type" in row.keys() else None
            return (dt or "sale") == "sale"
        except Exception:
            # If doc_type is absent, assume it's a sale (legacy behavior),
            # but our search path tries to request doc_type='sale' anyway.
            return True

    # ---- quick-mode priming ----
    def _prime_with_sale_id(self, sid: str):
        if not self.repo:
            return

        # Try repo.search_sales with doc_type filter if supported
        rows = []
        try:
            rows = self.repo.search_sales(query=sid, date=None, doc_type="sale") or []
        except TypeError:
            # Fallback to legacy signature then filter locally
            rows = self.repo.search_sales(query=sid, date=None) or []
            rows = [r for r in rows if self._is_sale_row(r)]

        row = next((r for r in rows if str(r["sale_id"]) == str(sid)), None)

        if not row:
            h = self.repo.get_header(sid)
            if not h or str(h.get("doc_type", "sale")) != "sale":
                return
            row = {
                "sale_id": h["sale_id"],
                "date": h["date"],
                "customer_name": "(customer)",
                "total_amount": float(h["total_amount"] or 0.0),
                "paid_amount": float(h["paid_amount"] or 0.0),
            }

        for i in reversed(range(self._search_row.count())):
            w = self._search_row.itemAt(i).widget()
            if w is not None:
                w.setVisible(False)

        self.setWindowTitle(f"Sale Return — {sid}")

        self.tbl_sales.setRowCount(1)
        self.tbl_sales.setItem(0, 0, QTableWidgetItem(str(row["sale_id"])))
        self.tbl_sales.setItem(0, 1, QTableWidgetItem(row["date"]))
        self.tbl_sales.setItem(0, 2, QTableWidgetItem(row.get("customer_name", "")))
        self.tbl_sales.setItem(0, 3, QTableWidgetItem(fmt_money(row["total_amount"])))
        self.tbl_sales.setItem(0, 4, QTableWidgetItem(fmt_money(row["paid_amount"])))
        self.tbl_sales.selectRow(0)  # triggers _load_items

    # ---- search and load ----
    def _search(self):
        if not self.repo:
            return
        q = (self.edt_q.text() or "").strip()
        d = self.edt_date.date().toString("yyyy-MM-dd") if self.edt_date.date() else None

        # Prefer repo-side doc_type filtering; fallback to local filter
        try:
            rows = self.repo.search_sales(q, d, doc_type="sale")
        except TypeError:
            rows = self.repo.search_sales(q, d)
            rows = [r for r in (rows or []) if self._is_sale_row(r)]

        rows = rows or []
        self.tbl_sales.setRowCount(len(rows))
        for r, x in enumerate(rows):
            self.tbl_sales.setItem(r, 0, QTableWidgetItem(x["sale_id"]))
            self.tbl_sales.setItem(r, 1, QTableWidgetItem(x["date"]))
            self.tbl_sales.setItem(r, 2, QTableWidgetItem(x.get("customer_name", "")))
            self.tbl_sales.setItem(r, 3, QTableWidgetItem(fmt_money(x["total_amount"])))
            self.tbl_sales.setItem(r, 4, QTableWidgetItem(fmt_money(x["paid_amount"])))

    def _load_items(self):
        if not self.repo:
            return
        idxs = self.tbl_sales.selectionModel().selectedRows()
        if not idxs:
            return
        sid = self.tbl_sales.item(idxs[0].row(), 0).text()
        self._selected_sid = sid

        # Header (paid + order discount)
        h = self.repo.get_header(sid) or {}
        # Guard: if somehow a quotation slipped through, do nothing
        if str(h.get("doc_type", "sale")) != "sale":
            return

        self._sale_paid = float(h.get("paid_amount") or 0.0)
        self._sale_od   = float(h.get("order_discount") or 0.0)

        # Canonical totals from DB view (preferred), safe fallback if not present
        totals_ok = False
        try:
            if hasattr(self.repo, "get_sale_totals"):
                t = self.repo.get_sale_totals(sid) or {}
                self._sale_net_subtotal   = float(t.get("net_subtotal") or 0.0)
                self._sale_total_after_od = float(t.get("total_after_od") or 0.0)
                totals_ok = True
        except Exception:
            totals_ok = False

        items = self.repo.list_items(sid)
        if not totals_ok:
            self._sale_total_after_od = float(h.get("total_amount") or 0.0)
            self._sale_net_subtotal = 0.0

        self.tbl_items.blockSignals(True)
        self.tbl_items.setRowCount(len(items))
        for r, it in enumerate(items):
            unit_net = float(it["unit_price"]) - float(it["item_discount"])
            qty_sold = float(it["quantity"])
            if not totals_ok:
                self._sale_net_subtotal += qty_sold * unit_net
            self.tbl_items.setItem(r, 0, QTableWidgetItem(str(it["item_id"])))
            self.tbl_items.setItem(r, 1, QTableWidgetItem(it["product_name"]))
            self.tbl_items.setItem(r, 2, QTableWidgetItem(f'{qty_sold:g}'))
            self.tbl_items.setItem(r, 3, QTableWidgetItem(fmt_money(unit_net)))
            qret = QTableWidgetItem("0"); qret.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
            self.tbl_items.setItem(r, 4, qret)
            self.tbl_items.setItem(r, 5, QTableWidgetItem("0.00"))
        self.tbl_items.blockSignals(False)

        # Enable refund-now checkbox when something was paid
        self.chk_refund.setEnabled(self._sale_paid > 0.0)
        # Spinner enabled whenever there is paid>0 (no need to tick first)
        self.spin_cash.setEnabled(self._sale_paid > 0.0)
        if self._sale_paid <= 0.0:
            self.chk_refund.setChecked(False)
            self._cash_user_set = False
            self.spin_cash.blockSignals(True)
            self.spin_cash.setValue(0.0)
            self.spin_cash.blockSignals(False)

        if self.chk_return_all.isChecked():
            self._toggle_return_all(True)

        self._recalc()

    def _toggle_return_all(self, checked: bool):
        if self.tbl_items.rowCount() == 0:
            return
        self.tbl_items.blockSignals(True)
        for r in range(self.tbl_items.rowCount()):
            sold = self.tbl_items.item(r, 2)
            target = self.tbl_items.item(r, 4)
            if sold and target:
                target.setText(sold.text() if checked else "0")
        self.tbl_items.blockSignals(False)
        self._recalc()

    def _on_refund_toggle(self, checked: bool):
        # Spinner stays enabled based on paid>0; just refresh defaults/notes.
        if not checked:
            pass
        self._recalc()

    def _on_cash_changed(self, _=None):
        # If user types a positive value, auto-check "Refund now?"
        if self.spin_cash.isEnabled() and self.spin_cash.value() > 0 and not self.chk_refund.isChecked():
            self.chk_refund.setChecked(True)
        self._cash_user_set = True
        self._update_note()

    # ---- math helpers ----
    def _order_factor(self) -> float:
        if self._sale_net_subtotal <= 0:
            return 1.0
        return float(self._sale_total_after_od) / float(self._sale_net_subtotal)

    # ---- recompute totals ----
    def _recalc(self, *args):
        total = 0.0
        of = self._order_factor()
        for r in range(self.tbl_items.rowCount()):
            try:
                sold = float(self.tbl_items.item(r, 2).text() or 0)
                unit_net = float((self.tbl_items.item(r, 3).text() or "0").replace(",", ""))
                qty = float(self.tbl_items.item(r, 4).text() or 0)
            except Exception:
                continue

            over = qty > sold
            it = self.tbl_items.item(r, 4)
            if it:
                it.setBackground(Qt.red if over else Qt.white)
            if over:
                lt = self.tbl_items.item(r, 5)
                if lt:
                    lt.setText(fmt_money(0.0))
                continue

            line_refund = qty * unit_net * of
            total += line_refund
            lt = self.tbl_items.item(r, 5)
            if lt:
                lt.setText(fmt_money(line_refund))

        # Returned value AFTER order-discount proration
        self._refund_amount = total
        self.lbl_returned_value.setText(fmt_money(self._refund_amount))

        # Cap for cash refund now
        cap = min(self._refund_amount, self._sale_paid)
        self.lbl_cash_cap.setText(f"(max: {fmt_money(cap)})")
        self.spin_cash.setMaximum(max(0.0, cap))

        # Default the spinner if user hasn't edited yet
        self.spin_cash.blockSignals(True)
        if self.spin_cash.isEnabled():
            if not self._cash_user_set:
                self.spin_cash.setValue(cap)
            else:
                if self.spin_cash.value() > cap:
                    self.spin_cash.setValue(cap)
        else:
            self.spin_cash.setValue(0.0)
        self.spin_cash.blockSignals(False)

        self._update_note()

    def _update_note(self):
        cap = min(self._refund_amount, self._sale_paid)
        cash_now = self.spin_cash.value() if self.spin_cash.isEnabled() else 0.0
        if cap <= 0:
            self.lbl_note.setText("")
            return

        if cash_now < cap:
            credited = self._refund_amount - cash_now
            self.lbl_note.setText(
                f"Paying {fmt_money(cash_now)} now. "
                f"{fmt_money(credited)} will reduce balance / be credited."
            )
        elif self._refund_amount > self._sale_paid:
            self.lbl_note.setText(
                f"Note: Paid is {fmt_money(self._sale_paid)}. "
                f"Cash refund is capped at that amount; the remainder will be credited/reduce balance."
            )
        else:
            self.lbl_note.setText("")

    # ---- payload ----
    def get_payload(self):
        if not self._selected_sid:
            return None
        lines = []
        for r in range(self.tbl_items.rowCount()):
            qty = float(self.tbl_items.item(r, 4).text() or 0)
            sold = float(self.tbl_items.item(r, 2).text() or 0)
            if qty <= 0 or qty > sold:
                continue
            lines.append({
                "item_id": int(self.tbl_items.item(r, 0).text()),
                "qty_return": qty
            })
        if not lines:
            return None
        return {
            "sale_id": self._selected_sid,
            "lines": lines,
            # Consider it a "refund now" if either box is checked or a positive cash value is set
            "refund_now": self.chk_refund.isChecked() or (self.spin_cash.isEnabled() and self.spin_cash.value() > 0),
            "refund_amount": self._refund_amount,                 # returned value (after OD proration)
            "cash_refund_now": float(self.spin_cash.value()) if self.spin_cash.isEnabled() else 0.0,
        }

    def accept(self):
        p = self.get_payload()
        if not p:
            return
        self._payload = p
        super().accept()

    def payload(self):
        return getattr(self, "_payload", None)

```

inventory_management/modules/sales/controller.py
```
from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Qt, QSortFilterProxyModel
import sqlite3

from ..base_module import BaseModule
from .view import SalesView
from .model import SalesTableModel
from .form import SaleForm
from .return_form import SaleReturnForm
from ...database.repositories.sales_repo import SalesRepo, SaleHeader, SaleItem
from ...database.repositories.customers_repo import CustomersRepo
from ...database.repositories.products_repo import ProductsRepo
from ...utils.ui_helpers import info
from ...utils.helpers import today_str, fmt_money


def new_sale_id(conn: sqlite3.Connection, date_str: str) -> str:
    d = date_str.replace("-", "")
    prefix = f"SO{d}-"
    row = conn.execute(
        "SELECT MAX(sale_id) AS m FROM sales WHERE sale_id LIKE ?",
        (prefix + "%",),
    ).fetchone()
    last = int(row["m"].split("-")[-1]) if row and row["m"] else 0
    return f"{prefix}{last+1:04d}"


def new_quotation_id(conn: sqlite3.Connection, date_str: str) -> str:
    """
    Quotation IDs use prefix QO + yyyymmdd + -NNNN
    """
    d = date_str.replace("-", "")
    prefix = f"QO{d}-"
    row = conn.execute(
        "SELECT MAX(sale_id) AS m FROM sales WHERE sale_id LIKE ?",
        (prefix + "%",),
    ).fetchone()
    last = int(row["m"].split("-")[-1]) if row and row["m"] else 0
    return f"{prefix}{last+1:04d}"


class SalesController(BaseModule):
    def __init__(self, conn: sqlite3.Connection, current_user: dict | None):
        self.conn = conn
        self.user = current_user
        self.view = SalesView()

        # Controller-level state
        self._doc_type: str = "sale"   # 'sale' | 'quotation' (mirrors view toggle)
        self._search_text: str = ""    # current server-side search string

        # Repos using the shared connection
        self.repo = SalesRepo(conn)
        self.customers = CustomersRepo(conn)
        self.products = ProductsRepo(conn)

        # Optional repo for bank accounts (lazy import; safe if missing)
        self.bank_accounts = None
        try:
            from ...database.repositories.bank_accounts_repo import BankAccountsRepo  # type: ignore
            self.bank_accounts = BankAccountsRepo(conn)
        except Exception:
            self.bank_accounts = None

        # Path for path-based repos (payments/advances)
        self._db_path = self._get_db_path_from_conn(conn)

        self._wire()
        self._reload()

    # ---- internals --------------------------------------------------------

    @staticmethod
    def _get_db_path_from_conn(conn: sqlite3.Connection) -> str:
        """
        Returns the file path for the 'main' database of this connection.
        Falls back to ':memory:' if not available.
        """
        try:
            cur = conn.execute("PRAGMA database_list;")
            row = cur.fetchone()
            if row is not None:
                # row columns: seq, name, file
                file_path = row[2] if isinstance(row, tuple) else row["file"]
                return file_path or ":memory:"
        except Exception:
            pass
        return ":memory:"

    def get_widget(self) -> QWidget:
        return self.view

    # ---- wiring / model ---------------------------------------------------

    def _wire(self):
        self.view.btn_add.clicked.connect(self._add)
        self.view.btn_edit.clicked.connect(self._edit)
        self.view.btn_return.clicked.connect(self._return)

        # Server-side search: on change, refetch from repo
        self.view.search.textChanged.connect(self._on_search_changed)

        if hasattr(self.view, "btn_record_payment"):
            self.view.btn_record_payment.clicked.connect(self._record_payment)
        if hasattr(self.view, "btn_print"):
            self.view.btn_print.clicked.connect(self._print)
        if hasattr(self.view, "btn_convert"):
            self.view.btn_convert.clicked.connect(self._convert_to_sale)
        # Apply Credit button (sales mode only)
        if hasattr(self.view, "btn_apply_credit"):
            self.view.btn_apply_credit.clicked.connect(self._on_apply_credit)

        # React to Sales|Quotations toggle → update controller state + reload
        if hasattr(self.view, "modeChanged"):
            self.view.modeChanged.connect(self._on_mode_changed)

        # initial action-state guard
        self._update_action_states()

    def _on_mode_changed(self, mode: str):
        mode = (mode or "sale").lower()
        self._doc_type = "quotation" if mode == "quotation" else "sale"
        # Let the details widget know (if it supports this)
        try:
            if hasattr(self.view, "details") and hasattr(self.view.details, "set_mode"):
                self.view.details.set_mode(self._doc_type)
        except Exception:
            pass
        self._update_action_states()
        self._reload()

    def _on_search_changed(self, text: str):
        self._search_text = text or ""
        self._reload()

    def _on_selection_changed(self, *_):
        # Enable/disable buttons then refresh details
        self._update_action_states()
        self._sync_details()

    def _update_action_states(self):
        """Guard toolbar buttons by selection and mode."""
        selected = self._selected_row() is not None

        # Always available
        if hasattr(self.view, "btn_edit"):
            self.view.btn_edit.setEnabled(selected)
        if hasattr(self.view, "btn_print"):
            self.view.btn_print.setEnabled(selected)

        # Sales-only actions
        allow_sales = (self._doc_type == "sale") and selected
        if hasattr(self.view, "btn_return"):
            self.view.btn_return.setEnabled(allow_sales)
        if hasattr(self.view, "btn_record_payment"):
            self.view.btn_record_payment.setEnabled(allow_sales)
        if hasattr(self.view, "btn_apply_credit"):
            self.view.btn_apply_credit.setEnabled(allow_sales)

        # Quotation-only action
        allow_convert = (self._doc_type == "quotation") and selected
        if hasattr(self.view, "btn_convert"):
            self.view.btn_convert.setEnabled(allow_convert)

    def _build_model(self):
        """
        Build the table model using server-side search (preferred).
        Falls back to list_* if search API is unavailable.
        """
        # Try repo.search_sales(query, doc_type=...)
        rows_to_use = None
        try:
            if hasattr(self.repo, "search_sales"):
                rows_to_use = list(self.repo.search_sales(self._search_text, doc_type=self._doc_type))
        except TypeError:
            # some implementations might have different signature; try (query, doc_type) kw-agnostic
            try:
                rows_to_use = list(self.repo.search_sales(self._search_text, self._doc_type))
            except Exception:
                rows_to_use = None
        except Exception:
            rows_to_use = None

        # Fallback behavior if search_sales is not available
        if rows_to_use is None:
            if self._doc_type == "quotation":
                try:
                    rows_to_use = list(self.repo.list_quotations())
                except Exception:
                    rows_to_use = []
            else:
                rows_to_use = list(self.repo.list_sales())

        # Normalize quotations to keep table happy (no payments; show quotation_status or em dash)
        if self._doc_type == "quotation":
            norm = []
            for r in rows_to_use:
                d = dict(r)
                d.setdefault("paid_amount", 0.0)
                qstat = d.get("quotation_status") or d.get("payment_status") or "—"
                d["payment_status"] = qstat
                norm.append(d)
            rows_to_use = norm

        # Build model & wire to view
        self.base = SalesTableModel(rows_to_use)
        self.proxy = QSortFilterProxyModel(self.view)
        self.proxy.setSourceModel(self.base)
        self.proxy.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.proxy.setFilterKeyColumn(-1)  # no client-side filtering; server-side fetch above
        self.view.tbl.setModel(self.proxy)
        self.view.tbl.resizeColumnsToContents()

        # Selection model is recreated with each setModel; connect handlers every time
        sel = self.view.tbl.selectionModel()
        sel.selectionChanged.connect(self._on_selection_changed)

    def _reload(self):
        self._build_model()
        if self.proxy.rowCount() > 0:
            self.view.tbl.selectRow(0)
        # Ensure buttons are correctly enabled/disabled and details are fresh
        self._update_action_states()
        self._sync_details()

    def _selected_row(self) -> dict | None:
        try:
            idxs = self.view.tbl.selectionModel().selectedRows()
        except Exception:
            return None
        if not idxs:
            return None
        src = self.proxy.mapToSource(idxs[0])
        return self.base.at(src.row())

    # --- small helper: fetch financials using calc view + header -----------
    def _fetch_sale_financials(self, sale_id: str) -> dict:
        """
        Returns a dict with:
          total_amount, paid_amount, advance_payment_applied,
          calculated_total_amount, remaining_due
        remaining_due = calculated_total_amount - paid_amount - advance_payment_applied (clamped ≥ 0)
        """
        row = self.conn.execute(
            """
            SELECT
              s.total_amount,
              COALESCE(s.paid_amount, 0.0)              AS paid_amount,
              COALESCE(s.advance_payment_applied, 0.0)  AS advance_payment_applied,
              COALESCE(sdt.calculated_total_amount, s.total_amount) AS calculated_total_amount
            FROM sales s
            LEFT JOIN sale_detailed_totals sdt ON sdt.sale_id = s.sale_id
            WHERE s.sale_id = ?;
            """,
            (sale_id,),
        ).fetchone()
        if not row:
            return {
                "total_amount": 0.0,
                "paid_amount": 0.0,
                "advance_payment_applied": 0.0,
                "calculated_total_amount": 0.0,
                "remaining_due": 0.0,
            }
        calc_total = float(row["calculated_total_amount"] or 0.0)
        paid = float(row["paid_amount"] or 0.0)
        adv = float(row["advance_payment_applied"] or 0.0)
        remaining = max(0.0, calc_total - paid - adv)
        return {
            "total_amount": float(row["total_amount"] or 0.0),
            "paid_amount": paid,
            "advance_payment_applied": adv,
            "calculated_total_amount": calc_total,
            "remaining_due": remaining,
        }

    def _sync_details(self, *args):
        r = self._selected_row()

        # default: nothing selected → clear subviews
        if not r:
            self.view.items.set_rows([])
            try:
                if hasattr(self.view, "payments"):
                    self.view.payments.set_rows([])
            except Exception:
                pass
            self.view.details.set_data(None)
            return

        # Always load item rows for the selected sale/quotation
        items = self.repo.list_items(r["sale_id"])
        line_disc = sum(float(it["quantity"]) * float(it["item_discount"]) for it in items)
        r = dict(r)
        r["overall_discount"] = float(r.get("order_discount") or 0.0) + line_disc

        # Returns summary for details panel (quotations naturally zero)
        try:
            rt = self.repo.sale_return_totals(r["sale_id"])
            r["returned_qty"] = float(rt.get("qty", 0.0))
            r["returned_value"] = float(rt.get("value", 0.0))
            r["net_after_returns"] = max(0.0, float(r.get("total_amount", 0.0)) - r["returned_value"])
        except Exception:
            r["returned_qty"] = 0.0
            r["returned_value"] = 0.0
            r["net_after_returns"] = float(r.get("total_amount", 0.0))

        self.view.items.set_rows(items)

        # ---- payments + customer credit (sales only) ----
        payments_rows: list[dict] = []
        if self._doc_type == "sale":
            # Payments list
            try:
                from ...database.repositories.sale_payments_repo import SalePaymentsRepo  # type: ignore
                pay_repo = SalePaymentsRepo(self._db_path)
                payments_rows = list(pay_repo.list_by_sale(r["sale_id"])) or []
            except Exception:
                payments_rows = []

            # Customer credit balance
            try:
                from ...database.repositories.customer_advances_repo import CustomerAdvancesRepo  # type: ignore
                adv_repo = CustomerAdvancesRepo(self._db_path)
                bal = adv_repo.get_balance(int(r.get("customer_id") or 0))
                r["customer_credit_balance"] = float(bal or 0.0)
            except Exception:
                r["customer_credit_balance"] = None

            # Financials including credit applied (NEW: include advance_payment_applied)
            fin = self._fetch_sale_financials(r["sale_id"])
            r["advance_payment_applied"] = fin["advance_payment_applied"]
            r["calculated_total_amount"] = fin["calculated_total_amount"]
            r["paid_plus_credit"] = fin["paid_amount"] + fin["advance_payment_applied"]
            r["remaining_due"] = fin["remaining_due"]
        else:
            # Quotation: explicitly pass empty payments and no credit balance
            payments_rows = []
            r.pop("customer_credit_balance", None)
            # Keep remaining_due aligned to quotations (0 by design)
            r["advance_payment_applied"] = 0.0
            r["paid_plus_credit"] = float(r.get("paid_amount") or 0.0)
            r["remaining_due"] = 0.0

        # Attach payments to the details payload
        r["payments"] = payments_rows

        # Feed the compact payments table on the left, if present
        try:
            if hasattr(self.view, "payments"):
                self.view.payments.set_rows(payments_rows)
        except Exception:
            pass

        # Finally update the details panel and its mode (if supported)
        try:
            if hasattr(self.view.details, "set_mode"):
                self.view.details.set_mode(self._doc_type)
        except Exception:
            pass
        self.view.details.set_data(r)

    # ---- helpers to open SaleForm with/without 'mode' ---------------------

    def _open_sale_form(self, *, initial: dict | None = None, as_quotation: bool = False) -> SaleForm | None:
        """
        Try to instantiate SaleForm with a few safe constructor variants.
        - If as_quotation=True, we first try passing mode='quotation', else fall back.
        - Keeps bank_accounts lazy path.
        Returns a dialog instance or None if all ctor attempts fail.
        """
        kwargs = {
            "customers": self.customers,
            "products": self.products,
            "bank_accounts": self.bank_accounts,
        }
        if initial is not None:
            kwargs["initial"] = initial

        if as_quotation:
            # Prefer explicit mode kw first
            try:
                return SaleForm(self.view, **kwargs, mode="quotation")  # type: ignore[arg-type]
            except TypeError:
                pass

        # Fallback without mode kwarg
        try:
            return SaleForm(self.view, **kwargs)
        except TypeError:
            # Try progressively simpler ctor shapes
            try:
                kwargs2 = {"customers": self.customers, "products": self.products}
                if initial is not None:
                    kwargs2["initial"] = initial
                return SaleForm(self.view, **kwargs2)
            except TypeError:
                try:
                    return SaleForm(self.view)
                except Exception:
                    return None

    # ---- local adapters for customer dialog/actions -----------------------

    def _list_company_bank_accounts(self) -> list[dict]:
        """
        Adapter used by customer.money dialog. Tries common repo shapes; returns list of {id, name}.
        """
        # Try repo methods if present
        try:
            if self.bank_accounts:
                for attr in ("list_accounts", "list", "list_all", "all"):
                    if hasattr(self.bank_accounts, attr):
                        rows = list(getattr(self.bank_accounts, attr)())
                        # Try to normalize to {id, name}
                        norm = []
                        for r in rows:
                            d = dict(r)
                            _id = d.get("id") or d.get("account_id") or d.get("bank_account_id")
                            _name = d.get("name") or d.get("account_name") or d.get("title")
                            if _id is not None and _name is not None:
                                norm.append({"id": int(_id), "name": str(_name)})
                        if norm:
                            return norm
        except Exception:
            pass
        # Fallback empty list
        return []

    def _list_sales_for_customer(self, customer_id: int) -> list[dict]:
        """
        Adapter used by customer.money dialog. Shape: {sale_id, doc_no, date, total, paid}
        """
        # Prefer repo helper if exists
        try:
            if hasattr(self.repo, "list_sales_for_customer"):
                rows = list(self.repo.list_sales_for_customer(customer_id))
                out = []
                for r in rows:
                    d = dict(r)
                    out.append({
                        "sale_id": str(d.get("sale_id")),
                        "doc_no": str(d.get("sale_id")),
                        "date": str(d.get("date")),
                        "total": float(d.get("total_amount") or d.get("total") or 0.0),
                        "paid": float(d.get("paid_amount") or d.get("paid") or 0.0),
                    })
                return out
        except Exception:
            pass

        # Safe fallback SQL (keeps compatibility with existing schema used elsewhere in this module)
        try:
            cur = self.conn.execute(
                """
                SELECT sale_id, date, total_amount AS total, COALESCE(paid_amount,0.0) AS paid
                FROM sales
                WHERE customer_id = ?
                ORDER BY date DESC, sale_id DESC
                LIMIT 200;
                """,
                (customer_id,),
            )
            out = []
            for row in cur.fetchall():
                out.append({
                    "sale_id": str(row["sale_id"]),
                    "doc_no": str(row["sale_id"]),
                    "date": str(row["date"]),
                    "total": float(row["total"]),
                    "paid": float(row["paid"]),
                })
            return out
        except Exception:
            return []

    def _eligible_sales_for_application(self, customer_id: int) -> list[dict]:
        """
        Build a list of sales with remaining_due > 0 for apply-advance UI.
        Shape per input spec: at least {sale_id, date, remaining_due, total, paid}
        """
        rows = self._list_sales_for_customer(customer_id)
        out: list[dict] = []
        for r in rows:
            sid = str(r.get("sale_id") or "")
            if not sid:
                continue
            fin = self._fetch_sale_financials(sid)
            if fin["remaining_due"] > 1e-9:
                out.append({
                    "sale_id": sid,
                    "date": r.get("date"),
                    "remaining_due": fin["remaining_due"],
                    "total": fin["calculated_total_amount"],
                    "paid": fin["paid_amount"],
                })
        return out

    # ---- CRUD -------------------------------------------------------------

    def _add(self):
        doc_type = self._doc_type

        dlg = self._open_sale_form(as_quotation=(doc_type == "quotation"))
        if dlg is None:
            info(self.view, "Error", "Sale form could not be opened.")
            return

        if not dlg.exec():
            return
        p = dlg.payload()
        if not p:
            return

        if doc_type == "quotation":
            # Quotation creation: ID prefix QO, no inventory posting, no payments
            qid = new_quotation_id(self.conn, p["date"])

            h = SaleHeader(
                sale_id=qid,
                customer_id=p["customer_id"],
                date=p["date"],
                total_amount=p["total_amount"],
                order_discount=p["order_discount"],
                payment_status="—",          # display-only; payments disallowed
                paid_amount=0.0,
                advance_payment_applied=0.0,
                notes=p["notes"],
                created_by=(self.user["user_id"] if self.user else None),
                source_type="direct",
                source_id=None,
            )

            items = [
                SaleItem(
                    None,
                    qid,
                    it["product_id"],
                    it["quantity"],
                    it["uom_id"],
                    it["unit_price"],
                    it["item_discount"],
                )
                for it in p["items"]
            ]

            try:
                self.repo.create_quotation(h, items)
                info(self.view, "Saved", f"Quotation {qid} created.")
            except Exception as e:
                info(self.view, "Error", f"Could not create quotation: {e}")
            self._reload()
            self._sync_details()
            return

        # --- sale path ---
        sid = new_sale_id(self.conn, p["date"])

        # Header: payment fields start at 0/unpaid. Roll-up comes from sale_payments.
        h = SaleHeader(
            sale_id=sid,
            customer_id=p["customer_id"],
            date=p["date"],
            total_amount=p["total_amount"],
            order_discount=p["order_discount"],
            payment_status="unpaid",
            paid_amount=0.0,
            advance_payment_applied=0.0,
            notes=p["notes"],
            created_by=(self.user["user_id"] if self.user else None),
        )
        items = [
            SaleItem(
                None,
                sid,
                it["product_id"],
                it["quantity"],
                it["uom_id"],
                it["unit_price"],
                it["item_discount"],
            )
            for it in p["items"]
        ]

        # Persist header + items (inventory is posted by repo for sales)
        self.repo.create_sale(h, items)

        # Initial payment via SalePaymentsRepo (no header math)
        init_amt = float(p.get("initial_payment") or 0.0)
        if init_amt > 0:
            try:
                from ...database.repositories.sale_payments_repo import SalePaymentsRepo  # lazy import
                pay_repo = SalePaymentsRepo(self._db_path)

                method = p.get("initial_method") or "Cash"
                kwargs = {
                    "sale_id": sid,
                    "amount": init_amt,
                    "method": method,
                    "date": p["date"],
                    "created_by": (self.user["user_id"] if self.user else None),
                    "notes": "[Init payment]",
                }

                # Method-specific fields
                if method == "Bank Transfer":
                    kwargs["bank_account_id"] = int(p["initial_bank_account_id"])
                    kwargs["instrument_no"] = p["initial_instrument_no"]
                    kwargs["instrument_type"] = p.get("initial_instrument_type", "online")
                else:
                    kwargs["instrument_type"] = "other"

                pay_repo.record_payment(**kwargs)
                info(self.view, "Saved", f"Sale {sid} created and initial payment recorded.")
            except Exception as e:
                # Sale is created; payment failed → notify clearly
                info(self.view, "Saved (with note)",
                     f"Sale {sid} created. Initial payment was not recorded: {e}")
        else:
            info(self.view, "Saved", f"Sale {sid} created.")

        self._reload()
        self._sync_details()

    def _edit(self):
        r = self._selected_row()
        if not r:
            info(self.view, "Select", "Select a row to edit.")
            return

        doc_type = self._doc_type

        items = self.repo.list_items(r["sale_id"])
        init = {
            "customer_id": r["customer_id"],
            "date": r["date"],
            "order_discount": r.get("order_discount"),
            "notes": r.get("notes"),
            "items": [
                {
                    "product_id": it["product_id"],
                    "uom_id": it["uom_id"],
                    "quantity": it["quantity"],
                    "unit_price": it["unit_price"],
                    "item_discount": it["item_discount"],
                }
                for it in items
            ],
        }

        dlg = self._open_sale_form(initial=init, as_quotation=(doc_type == "quotation"))
        if dlg is None:
            info(self.view, "Error", "Sale form could not be opened.")
            return

        if not dlg.exec():
            return
        p = dlg.payload()
        if not p:
            return

        sid = r["sale_id"]

        if doc_type == "quotation":
            # Update quotation (no inventory posting). Use repo.update_quotation if available.
            if hasattr(self.repo, "update_quotation"):
                h = SaleHeader(
                    sale_id=sid,
                    customer_id=p["customer_id"],
                    date=p["date"],
                    total_amount=p["total_amount"],
                    order_discount=p["order_discount"],
                    payment_status=r.get("payment_status", "—"),
                    paid_amount=0.0,
                    advance_payment_applied=0.0,
                    notes=p["notes"],
                    created_by=(self.user["user_id"] if self.user else None),
                    source_type=r.get("source_type", "direct"),
                    source_id=r.get("source_id"),
                )
                items = [
                    SaleItem(
                        None,
                        sid,
                        it["product_id"],
                        it["quantity"],
                        it["uom_id"],
                        it["unit_price"],
                        it["item_discount"],
                    )
                    for it in p["items"]
                ]
                try:
                    self.repo.update_quotation(h, items)  # should not post inventory
                    info(self.view, "Saved", f"Quotation {sid} updated.")
                except Exception as e:
                    info(self.view, "Error", f"Could not update quotation: {e}")
            else:
                info(self.view, "Not available",
                     "Updating quotations requires SalesRepo.update_quotation(...).")
            self._reload()
            self._sync_details()
            return

        # --- sale path ---
        h = SaleHeader(
            sale_id=sid,
            customer_id=p["customer_id"],
            date=p["date"],
            total_amount=p["total_amount"],
            order_discount=p["order_discount"],
            payment_status=r["payment_status"],
            paid_amount=r["paid_amount"],
            advance_payment_applied=0.0,
            notes=p["notes"],
            created_by=(self.user["user_id"] if self.user else None),
        )
        items = [
            SaleItem(
                None,
                sid,
                it["product_id"],
                it["quantity"],
                it["uom_id"],
                it["unit_price"],
                it["item_discount"],
            )
            for it in p["items"]
        ]
        self.repo.update_sale(h, items)
        info(self.view, "Saved", f"Sale {sid} updated.")
        self._reload()
        self._sync_details()

    def _delete(self):
        r = self._selected_row()
        if not r:
            info(self.view, "Select", "Select a row to delete.")
            return
        self.repo.delete_sale(r["sale_id"])
        info(self.view, "Deleted", f"{r['sale_id']} removed.")
        self._reload()
        self._sync_details()

    # ---- Convert to Sale (from quotation mode) ----------------------------

    def _convert_to_sale(self):
        doc_type = self._doc_type
        if doc_type != "quotation":
            info(self.view, "Not a quotation", "Switch to Quotations to use Convert to Sale.")
            return

        r = self._selected_row()
        if not r:
            info(self.view, "Select", "Select a quotation to convert.")
            return

        qo_id = r["sale_id"]
        date_for_so = today_str()  # you can change to reuse quotation date if you prefer
        so_id = new_sale_id(self.conn, date_for_so)

        try:
            self.repo.convert_quotation_to_sale(
                qo_id=qo_id,
                new_so_id=so_id,
                date=date_for_so,
                created_by=(self.user["user_id"] if self.user else None),
            )
            info(self.view, "Converted", f"{qo_id} → {so_id} created.")
        except Exception as e:
            info(self.view, "Error", f"Conversion failed: {e}")

        self._reload()
        self._sync_details()

    # ---- Payments / Printing ---------------------------------------------

    def _record_payment(self):
        """
        Open the customer payment UI for the selected sale (sales mode only).
        Prefer the unified customer money dialog + actions; fall back to legacy UI if not available.
        """
        doc_type = self._doc_type
        if doc_type != "sale":
            info(self.view, "Not available", "Payments are not available for quotations.")
            return

        row = self._selected_row()
        if not row:
            info(self.view, "Select", "Select a sale first.")
            return

        sale_id = str(row["sale_id"])
        customer_id = int(row.get("customer_id") or 0)
        customer_display = str(row.get("customer_name") or customer_id)

        # --- Preferred path: local customer dialog + actions (lazy imports) ---
        try:
            from ...customer.receipt_dialog import open_payment_or_advance_form  # type: ignore
            from ...customer import actions as customer_actions  # type: ignore

            payload = open_payment_or_advance_form(
                mode="receipt",
                customer_id=customer_id,
                sale_id=sale_id,
                defaults={
                    "list_company_bank_accounts": self._list_company_bank_accounts,
                    "list_sales_for_customer": self._list_sales_for_customer,
                    "customer_display": customer_display,
                },
            )
            if payload:
                _ = customer_actions.receive_payment(
                    db_path=self._db_path,
                    sale_id=sale_id,
                    customer_id=customer_id,
                    with_ui=False,
                    form_defaults=payload,  # already shaped for repo by the dialog
                )
                self._reload()
                self._sync_details()
                return
        except Exception:
            # fall through to legacy path
            pass

        # --- Legacy fallback: legacy payments UI (kept for compatibility) ---
        try:
            from ...payments.ui.customer_receipt_form import CustomerReceiptForm  # type: ignore

            dlg = None
            for args in (
                (self.view, sale_id, self._db_path),
                (self.view, sale_id, self.conn),
                (self.view, sale_id),
                (self.view,),
            ):
                try:
                    dlg = CustomerReceiptForm(*args)
                    break
                except TypeError:
                    dlg = None

            if dlg is None:
                raise RuntimeError("CustomerReceiptForm constructor not recognized.")

            if hasattr(dlg, "set_sale_id"):
                try:
                    dlg.set_sale_id(sale_id)
                except Exception:
                    pass

            dlg.exec()
            self._reload()
            self._sync_details()
            return
        except Exception:
            info(
                self.view,
                "Payments UI not available",
                "The payments dialog isn't wired in this build. "
                "Open the Payments module to record a receipt.",
            )
            # Even if dialog isn't available, keep UI in a sane state
            self._update_action_states()
            self._sync_details()

    def _print(self):
        """
        Route to the appropriate template based on mode.
        """
        row = self._selected_row()
        if not row:
            info(self.view, "Select", "Select a row to print.")
            return

        doc_type = self._doc_type
        sale_id = row["sale_id"]

        # Choose template
        if doc_type == "quotation":
            template = "resources/templates/invoices/quotation_invoice.html"
            window_title = f"Quotation — {sale_id}"
        else:
            template = "resources/templates/invoices/sale_invoice.html"
            window_title = f"Sale Invoice — {sale_id}"

        # Try a printing controller first
        try:
            from ...printing.controller import PrintingController  # type: ignore

            pc = PrintingController(self.conn)
            if hasattr(pc, "preview_invoice"):
                pc.preview_invoice(template, {"sale_id": sale_id})
                return
            # Optional aliases if your controller has specialized methods
            if doc_type == "quotation" and hasattr(pc, "print_quotation"):
                pc.print_quotation(sale_id)
                return
            if doc_type == "sale" and hasattr(pc, "print_sale"):
                pc.print_sale(sale_id)
                return
            raise RuntimeError("No suitable printing method found on PrintingController.")
        except Exception:
            pass

        # Fallback to invoice preview widget if available
        try:
            from ...widgets.invoice_preview import InvoicePreview  # type: ignore
            w = InvoicePreview(template, {"sale_id": sale_id})
            w.setWindowTitle(window_title)
            w.show()  # non-modal
            return
        except Exception:
            info(
                self.view,
                "Printing not configured",
                "Printing/preview is not wired in this build. "
                "Use the Printing module to preview/print.",
            )

        # After printing attempt, keep states fresh
        self._update_action_states()
        self._sync_details()

    # ---- Apply Credit to Sale (UPDATED) -----------------------------------

    def _on_apply_credit(self):
        """
        Apply existing customer credit to the currently selected SALE.

        Preferred: use local dialog + actions.
        Fallback: legacy UI path preserved for compatibility.
        """
        if self._doc_type != "sale":
            info(self.view, "Not available", "Apply Credit is available for sales only.")
            return

        row = self._selected_row()
        if not row:
            info(self.view, "Select", "Select a sale first.")
            return

        sale_id = str(row["sale_id"])
        customer_id = int(row.get("customer_id") or 0)
        if not customer_id:
            info(self.view, "Missing data", "Selected sale is missing customer information.")
            return

        # --- Preferred path: local dialog + actions (lazy imports) ---
        try:
            from ...customer.receipt_dialog import open_payment_or_advance_form  # type: ignore
            from ...customer import actions as customer_actions  # type: ignore

            payload = open_payment_or_advance_form(
                mode="apply_advance",
                customer_id=customer_id,
                sale_id=None,
                defaults={
                    "list_sales_for_customer": self._list_sales_for_customer,
                    "sales": self._eligible_sales_for_application(customer_id),
                },
            )
            if payload:
                _ = customer_actions.apply_customer_advance(
                    db_path=self._db_path,
                    customer_id=customer_id,
                    sale_id=str(payload["sale_id"]),
                    with_ui=False,
                    form_defaults={
                        "customer_id": customer_id,
                        "sale_id": payload["sale_id"],
                        "amount_to_apply": payload["amount"],
                        "date": payload.get("date"),
                        "notes": payload.get("notes"),
                        "created_by": payload.get("created_by"),
                    },
                )
                info(self.view, "Saved", "Credit application recorded.")
                self._reload()
                self._sync_details()
                return
        except Exception:
            # fall through to legacy path below
            pass

        # --- Legacy fallback path (kept) ---
        # Fetch financials for this sale (includes advance_payment_applied)
        fin = self._fetch_sale_financials(sale_id)
        remaining_due = float(fin["remaining_due"])

        # Fetch customer's available credit balance via repo (lazy import path-based)
        try:
            from ...database.repositories.customer_advances_repo import CustomerAdvancesRepo  # type: ignore
            adv_repo = CustomerAdvancesRepo(self._db_path)
            credit_balance = float(adv_repo.get_balance(customer_id) or 0.0)
        except Exception as e:
            info(self.view, "Unavailable", f"Could not fetch customer credit balance: {e}")
            return

        if remaining_due <= 0.0:
            info(self.view, "Nothing due", "This sale has no remaining due.")
            return

        if credit_balance <= 0.0:
            info(self.view, "No credit", "Customer has no available credit to apply.")
            return

        # Prefer a dedicated legacy UI if present
        try:
            from ...payments.ui.apply_advance_form import open_apply_advance_form  # type: ignore

            sales_payload = [{
                "sale_id": sale_id,
                "date": row.get("date"),
                "remaining_due": remaining_due,
                "total": float(fin["calculated_total_amount"]),
                "paid": float(fin["paid_amount"]),
            }]
            defaults = {
                "sale_id": sale_id,
                "amount_to_apply": min(remaining_due, credit_balance),
                "date": today_str(),
                "notes": "[Apply credit]",
            }
            form_payload = open_apply_advance_form(
                customer_id=customer_id,
                sales=sales_payload,
                defaults=defaults,
            )
            if not form_payload:
                return  # cancelled

            amt = form_payload.get("amount_to_apply")
            if amt is None or float(amt) <= 0:
                info(self.view, "Required", "Please enter a positive amount to apply.")
                return

            try:
                tx_id = adv_repo.apply_credit_to_sale(
                    customer_id=customer_id,
                    sale_id=sale_id,
                    amount=-abs(float(amt)),
                    date=form_payload.get("date"),
                    notes=form_payload.get("notes"),
                    created_by=(self.user["user_id"] if self.user else None),
                )
            except (ValueError, sqlite3.IntegrityError) as e:
                info(self.view, "Not applied", str(e))
                return

            info(self.view, "Saved", f"Credit application #{tx_id} recorded.")
            self._reload()
            self._sync_details()
            return

        except Exception:
            info(
                self.view,
                "Apply Credit UI not available",
                "The Apply Credit dialog isn't wired in this build. "
                "Open the Customers module to apply credit from there.",
            )
            self._update_action_states()
            self._sync_details()

    # ---- Returns ----------------------------------------------------------

    def _return(self):
        """
        Inventory: insert sale_return transactions.
        Money:
          - For 'refund now': insert a negative Cash payment via SalePaymentsRepo.
          - For the remainder: add a customer return credit via CustomerAdvancesRepo.
        Do NOT rewrite header totals/paid/status; DB and credit ledger are source of truth.
        """
        doc_type = self._doc_type
        if doc_type != "sale":
            info(self.view, "Not available", "Returns apply to sales only, not quotations.")
            return

        selected = self._selected_row()
        if selected:
            dlg = SaleReturnForm(self.view, repo=self.repo, sale_id=selected["sale_id"])
        else:
            dlg = SaleReturnForm(self.view, repo=self.repo)

        if not dlg.exec():
            return
        p = dlg.payload()
        if not p:
            return

        sid = p["sale_id"]
        items = self.repo.list_items(sid)
        by_id = {it["item_id"]: it for it in items}

        # Build inventory return lines
        lines = []
        for ln in p["lines"]:
            it = by_id.get(ln["item_id"])
            if not it:
                continue
            lines.append(
                {
                    "item_id": it["item_id"],
                    "product_id": it["product_id"],
                    "uom_id": it["uom_id"],
                    "qty_return": float(ln["qty_return"]),
                }
            )

        # 1) Inventory transactions
        self.repo.record_return(
            sid=sid,
            date=today_str(),
            created_by=(self.user["user_id"] if self.user else None),
            lines=lines,
            notes="[Return]",
        )

        # 2) Money side
        refund_amount = float(p.get("refund_amount") or 0.0)  # already order-discount prorated
        hdr = self.repo.get_header(sid) or {}
        paid_before = float(hdr.get("paid_amount") or 0.0)
        customer_id = int(hdr.get("customer_id") or 0)

        cash_refund = 0.0
        credit_part = refund_amount

        if p.get("refund_now"):
            cash_refund = min(refund_amount, paid_before)
            credit_part = max(0.0, refund_amount - cash_refund)

            if cash_refund > 0:
                try:
                    from ...database.repositories.sale_payments_repo import SalePaymentsRepo  # lazy import
                    pay_repo = SalePaymentsRepo(self._db_path)
                    pay_repo.record_payment(
                        sale_id=sid,
                        date=today_str(),
                        amount=-abs(cash_refund),
                        method="Cash",
                        instrument_type="other",
                        notes="[Return refund]",
                        created_by=(self.user["user_id"] if self.user else None),
                    )
                except Exception as e:
                    info(
                        self.view,
                        "Refund warning",
                        f"Inventory return saved, but cash refund could not be recorded: {e}",
                    )

        if credit_part > 0 and customer_id:
            try:
                from ...database.repositories.customer_advances_repo import CustomerAdvancesRepo  # lazy import
                adv_repo = CustomerAdvancesRepo(self._db_path)
                adv_repo.add_return_credit(
                    customer_id=customer_id,
                    amount=credit_part,
                    sale_id=sid,
                    date=today_str(),
                    notes="[Return credit]",
                    created_by=(self.user["user_id"] if self.user else None),
                )
            except Exception as e:
                info(
                    self.view,
                    "Credit warning",
                    f"Inventory return saved, but customer credit could not be recorded: {e}",
                )

        # Optional note if fully returned
        all_back = all(
            (
                float(
                    next((l["qty_return"] for l in p["lines"] if l["item_id"] == it["item_id"]), 0.0)
                )
                >= float(it["quantity"])
            )
            for it in items
        )
        if all_back:
            try:
                with self.conn:
                    self.conn.execute(
                        "UPDATE sales SET notes = COALESCE(notes,'') || ' [Full return]' WHERE sale_id=?",
                        (sid,),
                    )
            except Exception:
                pass

        # Summary
        if p.get("refund_now"):
            if credit_part > 0:
                info(
                    self.view,
                    "Saved",
                    f"Return recorded. Refunded {fmt_money(cash_refund)} in cash; "
                    f"{fmt_money(credit_part)} added to customer credit.",
                )
            else:
                info(self.view, "Saved", f"Return recorded. Refunded {fmt_money(cash_refund)} in cash.")
        else:
            info(self.view, "Saved", f"Return recorded. {fmt_money(refund_amount)} added to customer credit.")

        self._reload()
        self._sync_details()

```

inventory_management/modules/sales/view.py
```
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit, QLabel,
    QSplitter, QWidget as W, QVBoxLayout as V, QGroupBox, QButtonGroup
)
from PySide6.QtCore import Qt, QAbstractTableModel, QModelIndex, Signal
from ...widgets.table_view import TableView
from .details import SaleDetails
from .items import SaleItemsView
from ...utils.helpers import fmt_money


class PaymentsTableModel(QAbstractTableModel):
    """
    Read-only, compact payments table:
    Columns: Date, Method, Amount ±, State, Ref #, Bank
    Accepts rows as sqlite3.Row or dict with keys similar to sale_payments schema.
    """
    HEADERS = ["Date", "Method", "Amount", "State", "Ref #", "Bank"]

    def __init__(self, rows: list[dict] | None = None):
        super().__init__()
        self._rows = rows or []

    def rowCount(self, parent=QModelIndex()):
        return len(self._rows)

    def columnCount(self, parent=QModelIndex()):
        return len(self.HEADERS)

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.HEADERS[section]
        return super().headerData(section, orientation, role)

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        if role not in (Qt.DisplayRole, Qt.EditRole):
            return None

        r = self._rows[index.row()]

        # tolerant getters for sqlite3.Row or dict
        def g(key, default=None):
            try:
                if isinstance(r, dict):
                    return r.get(key, default)
                return r[key] if key in r.keys() else default
            except Exception:
                return default

        date = g("date", "")
        method = g("method", "")
        amount = g("amount", 0.0)
        state = g("clearing_state", g("state", ""))
        ref_no = g("ref_no", None) or g("instrument_no", "")

        bank_display = ""
        bank_name = g("bank_name", None)
        account_no = g("account_no", None)
        if bank_name or account_no:
            if bank_name and account_no:
                bank_display = f"{bank_name} ({account_no})"
            else:
                bank_display = bank_name or account_no or ""
        else:
            bank_id = g("bank_account_id", None)
            if bank_id is not None:
                bank_display = f"#{bank_id}"

        cols = [
            str(date or ""),
            str(method or ""),
            fmt_money(float(amount or 0.0)),
            str(state or ""),
            str(ref_no or ""),
            bank_display,
        ]
        return cols[index.column()]

    def replace(self, rows: list[dict]):
        self.beginResetModel()
        self._rows = rows or []
        self.endResetModel()


class PaymentsView(QWidget):
    """
    Small wrapper: a titled group box with a TableView and read-only model.
    Use .set_rows(rows) to populate.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        box = QGroupBox("Payments")
        v = QVBoxLayout(box)
        self.table = TableView()
        self.model = PaymentsTableModel([])
        self.table.setModel(self.model)
        v.addWidget(self.table, 1)

        root = QVBoxLayout(self)
        root.addWidget(box, 1)

    def set_rows(self, rows: list[dict]):
        self.model.replace(rows)
        self.table.resizeColumnsToContents()


class SalesView(QWidget):
    # Emit 'sale' or 'quotation' when user toggles the mode.
    modeChanged = Signal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        root = QVBoxLayout(self)

        # --- Mode toggle (Sales | Quotations) ---
        modebar = QHBoxLayout()
        modebar.addWidget(QLabel("Mode:"))
        self.btn_mode_sales = QPushButton("Sales")
        self.btn_mode_quotes = QPushButton("Quotations")
        for b in (self.btn_mode_sales, self.btn_mode_quotes):
            b.setCheckable(True)
        self._mode_group = QButtonGroup(self)
        self._mode_group.setExclusive(True)
        self._mode_group.addButton(self.btn_mode_sales)
        self._mode_group.addButton(self.btn_mode_quotes)
        self.btn_mode_sales.setChecked(True)  # default
        modebar.addWidget(self.btn_mode_sales)
        modebar.addWidget(self.btn_mode_quotes)
        modebar.addStretch(1)
        root.addLayout(modebar)

        # --- Top toolbar ---
        bar = QHBoxLayout()
        self.btn_add = QPushButton("New")
        self.btn_edit = QPushButton("Edit")
        # self.btn_del = QPushButton("Delete")
        self.btn_return = QPushButton("Return")

        # Record Payment, Apply Credit & Print (Apply Credit is new)
        self.btn_record_payment = QPushButton("Record Payment…")
        self.btn_apply_credit = QPushButton("Apply Credit…")
        self.btn_print = QPushButton("Print")

        # Shown only in Quotation mode
        self.btn_convert = QPushButton("Convert to Sale")

        bar.addWidget(self.btn_add)
        bar.addWidget(self.btn_edit)
        bar.addWidget(self.btn_return)
        bar.addWidget(self.btn_record_payment)
        bar.addWidget(self.btn_apply_credit)  # NEW button in toolbar
        bar.addWidget(self.btn_print)
        bar.addWidget(self.btn_convert)

        bar.addStretch(1)
        self.search = QLineEdit()
        self.search.setPlaceholderText("Search sales (id, customer, status)…")
        bar.addWidget(QLabel("Search:"))
        bar.addWidget(self.search, 2)
        root.addLayout(bar)

        # --- Main split: left (list + items + payments), right (details) ---
        split = QSplitter(Qt.Horizontal)

        left = W()
        lv = V(left)
        self.tbl = TableView()
        lv.addWidget(self.tbl, 3)

        self.items = SaleItemsView()
        lv.addWidget(self.items, 2)

        # compact payments table under items (hidden in quotation mode)
        self.payments = PaymentsView()
        lv.addWidget(self.payments, 1)

        split.addWidget(left)

        self.details = SaleDetails()
        split.addWidget(self.details)

        split.setStretchFactor(0, 3)
        split.setStretchFactor(1, 2)
        root.addWidget(split, 1)

        # initial state for mode-dependent controls
        self._doc_type = "sale"
        self._apply_mode_visibility()

        # wiring for mode change
        self.btn_mode_sales.toggled.connect(self._on_mode_toggle)
        self.btn_mode_quotes.toggled.connect(self._on_mode_toggle)

    # --- Public helpers ----------------------------------------------------

    def current_doc_type(self) -> str:
        """Return the current mode as 'sale' or 'quotation'."""
        return self._doc_type

    def set_mode(self, doc_type: str):
        """Programmatically set the mode and update UI."""
        doc_type = (doc_type or "sale").lower()
        if doc_type not in ("sale", "quotation"):
            doc_type = "sale"
        self._doc_type = doc_type
        # Update toggle buttons to reflect state
        if doc_type == "sale":
            self.btn_mode_sales.setChecked(True)
        else:
            self.btn_mode_quotes.setChecked(True)
        self._apply_mode_visibility()

    # --- Internals ---------------------------------------------------------

    def _on_mode_toggle(self, _checked: bool):
        new_mode = "quotation" if self.btn_mode_quotes.isChecked() else "sale"
        if new_mode != self._doc_type:
            self._doc_type = new_mode
            self._apply_mode_visibility()
            self.modeChanged.emit(self._doc_type)

    def _apply_mode_visibility(self):
        """Show/hide or enable/disable widgets based on current mode."""
        is_quote = (self._doc_type == "quotation")

        # Buttons:
        # - Quotations: show Convert, hide/disable Return, Record Payment & Apply Credit
        # - Sales: hide Convert, enable Return, Record Payment & Apply Credit
        self.btn_convert.setVisible(is_quote)
        self.btn_convert.setEnabled(is_quote)

        self.btn_return.setVisible(not is_quote)
        self.btn_return.setEnabled(not is_quote)

        self.btn_record_payment.setVisible(not is_quote)
        self.btn_record_payment.setEnabled(not is_quote)

        self.btn_apply_credit.setVisible(not is_quote)   # NEW: only in Sales mode
        self.btn_apply_credit.setEnabled(not is_quote)

        # Payments panel only for sales
        self.payments.setVisible(not is_quote)

        # Search placeholder
        self.search.setPlaceholderText(
            "Search quotations (id, customer, status)…" if is_quote
            else "Search sales (id, customer, status)…"
        )

```

inventory_management/modules/sales/model.py
```
from PySide6.QtCore import QAbstractTableModel, Qt, QModelIndex
from ...utils.helpers import fmt_money

class SalesTableModel(QAbstractTableModel):
    HEADERS = ["ID", "Date", "Customer", "Total", "Paid", "Status"]

    def __init__(self, rows: list[dict]):
        super().__init__(); self._rows = rows

    def rowCount(self, p=QModelIndex()): return len(self._rows)
    def columnCount(self, p=QModelIndex()): return len(self.HEADERS)

    def data(self, idx, role=Qt.DisplayRole):
        if not idx.isValid(): return None
        r = self._rows[idx.row()]
        if role in (Qt.DisplayRole, Qt.EditRole):
            # Fields (with safe defaults)
            sale_id = r.get("sale_id")
            date = r.get("date")
            customer_name = r.get("customer_name")
            total_amount = float(r.get("total_amount", 0.0))

            # NEW: consider credit applied when computing paid & status
            paid_amount = float(r.get("paid_amount", 0.0))
            adv_applied = float(r.get("advance_payment_applied", 0.0))  # repo/query should now provide this
            paid_total = paid_amount + adv_applied

            # Status: prefer existing value when it's clearly a quotation marker (e.g., '—' or quotation statuses)
            existing_status = (r.get("payment_status") or "").strip().lower()
            quotation_marker = existing_status in {"—", "draft", "sent", "accepted", "expired", "cancelled"}
            if quotation_marker:
                status = r.get("payment_status") or "—"
            else:
                EPS = 1e-9
                if paid_total + EPS >= total_amount and total_amount > 0:
                    status = "paid"
                elif paid_total > EPS:
                    status = "partial"
                else:
                    status = "unpaid"

            m = [
                sale_id,
                date,
                customer_name,
                fmt_money(total_amount),
                fmt_money(paid_total),   # NEW: paid = paid_amount + advance_payment_applied
                status,                  # NEW: status based on the new paid_total
            ]
            return m[idx.column()]
        return None

    def headerData(self, s, o, role=Qt.DisplayRole):
        return self.HEADERS[s] if o==Qt.Horizontal and role==Qt.DisplayRole else super().headerData(s,o,role)

    def at(self, row: int) -> dict: return self._rows[row]
    def replace(self, rows: list[dict]):
        self.beginResetModel(); self._rows = rows; self.endResetModel()


class SaleItemsModel(QAbstractTableModel):
    HEADERS = ["#", "Product", "Qty", "Unit Price", "Discount", "Line Total"]
    def __init__(self, rows: list[dict]): super().__init__(); self._rows = rows
    def rowCount(self, p=QModelIndex()): return len(self._rows)
    def columnCount(self, p=QModelIndex()): return len(self.HEADERS)
    def data(self, idx, role=Qt.DisplayRole):
        if not idx.isValid(): return None
        r = self._rows[idx.row()]
        if role in (Qt.DisplayRole, Qt.EditRole):
            lt = float(r["quantity"]) * (float(r["unit_price"]) - float(r["item_discount"]))
            m = [r["item_id"], r["product_name"], f'{float(r["quantity"]):g}',
                 fmt_money(r["unit_price"]), fmt_money(r["item_discount"]), fmt_money(lt)]
            return m[idx.column()]
        return None
    def headerData(self, s, o, role=Qt.DisplayRole):
        return self.HEADERS[s] if o==Qt.Horizontal and role==Qt.DisplayRole else super().headerData(s,o,role)
    def replace(self, rows: list[dict]): self.beginResetModel(); self._rows=rows; self.endResetModel()

```

inventory_management/modules/sales/items.py
```
from PySide6.QtWidgets import QWidget, QVBoxLayout
from ...widgets.table_view import TableView
from .model import SaleItemsModel

class SaleItemsView(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.table = TableView()
        self.model = SaleItemsModel([])
        self.table.setModel(self.model)
        lay = QVBoxLayout(self); lay.addWidget(self.table, 1)

    def set_rows(self, rows: list[dict]):
        self.model.replace(rows)
        self.table.resizeColumnsToContents()

```

inventory_management/modules/sales/details.py
```
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QGroupBox, QFormLayout, QLabel,
    QTableWidget, QTableWidgetItem, QAbstractItemView
)
from PySide6.QtCore import Qt
from ...utils.helpers import fmt_money


class SaleDetails(QWidget):
    """
    Read-only panel showing the selected sale’s/quotation’s header facts, returns summary
    (hidden for quotations), a compact payments list (hidden for quotations), and the
    customer’s credit balance (if provided).

    Expected keys in set_data(dict):
      sale_id, date, customer_name, total_amount, order_discount, overall_discount,
      returned_qty, returned_value, net_after_returns, paid_amount, payment_status,
      doc_type ('sale' | 'quotation'),
      (optional) payments: list[dict] with columns such as date, method, amount,
                           clearing_state, ref_no/instrument_no, bank_name/account_title/account_no/bank_account_id
      (optional) customer_credit_balance: float
    """
    def __init__(self, parent=None):
        super().__init__(parent)

        # --- Sale facts box -------------------------------------------------
        self.box = QGroupBox("Sale Details")
        f = QFormLayout(self.box)

        self.lab_id = QLabel("-")
        self.lab_date = QLabel("-")
        self.lab_customer = QLabel("-")

        self.lab_total = QLabel("-")
        self.lab_discount = QLabel("-")
        self.lab_total_discount = QLabel("-")

        # Returns summary + net after returns
        self.lab_returned_qty = QLabel("-")
        self.lab_returned_val = QLabel("-")
        self.lab_net_after = QLabel("-")

        self.lab_paid = QLabel("-")
        self.lab_remain = QLabel("-")
        self.lab_status = QLabel("-")

        # Optional: customer credit balance
        self.lab_credit = QLabel("-")

        f.addRow("ID:", self.lab_id)
        f.addRow("Date:", self.lab_date)
        f.addRow("Customer:", self.lab_customer)
        f.addRow("Total:", self.lab_total)
        f.addRow("Order Discount:", self.lab_discount)
        f.addRow("Total Discount:", self.lab_total_discount)
        f.addRow("Returned Qty:", self.lab_returned_qty)
        f.addRow("Returned Value:", self.lab_returned_val)
        f.addRow("Net (after returns):", self.lab_net_after)
        f.addRow("Paid:", self.lab_paid)
        f.addRow("Remaining:", self.lab_remain)
        f.addRow("Status:", self.lab_status)
        f.addRow("Customer Credit:", self.lab_credit)

        self._form = f  # keep a handle for row visibility control

        # --- Payments list (compact, read-only) -----------------------------
        self.pay_box = QGroupBox("Payments (read-only)")
        pay_layout = QVBoxLayout(self.pay_box)

        self.tbl_payments = QTableWidget(0, 6)
        self.tbl_payments.setHorizontalHeaderLabels(["Date", "Method", "Amount", "State", "Ref #", "Bank"])
        self.tbl_payments.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.tbl_payments.setSelectionMode(QAbstractItemView.NoSelection)
        self.tbl_payments.setFocusPolicy(Qt.NoFocus)
        self.tbl_payments.verticalHeader().setVisible(False)
        self.tbl_payments.setAlternatingRowColors(True)
        pay_layout.addWidget(self.tbl_payments)

        # Root layout
        root = QVBoxLayout(self)
        root.addWidget(self.box)
        root.addWidget(self.pay_box)

    # ----------------------------------------------------------------------

    def _reset(self):
        for w in (
            self.lab_id, self.lab_date, self.lab_customer,
            self.lab_total, self.lab_discount, self.lab_total_discount,
            self.lab_returned_qty, self.lab_returned_val, self.lab_net_after,
            self.lab_paid, self.lab_remain, self.lab_status, self.lab_credit
        ):
            w.setText("-")
        self._load_payments([])
        # Default to 'sale' visibility when nothing is selected
        self._apply_doc_type_visibility("sale")

    def _load_payments(self, rows: list[dict]):
        """Populate the compact payments table from a list of dict-like rows."""
        self.tbl_payments.setRowCount(0)
        if not rows:
            return

        def _text(x) -> str:
            return "" if x is None else str(x)

        for r, row in enumerate(rows):
            self.tbl_payments.insertRow(r)

            # Date
            date = row.get("date") or row.get("tx_date") or ""
            self.tbl_payments.setItem(r, 0, self._cell(_text(date)))

            # Method
            method = row.get("method", "")
            self.tbl_payments.setItem(r, 1, self._cell(_text(method)))

            # Amount (±)
            try:
                amt_val = float(row.get("amount", 0.0) or 0.0)
            except Exception:
                amt_val = 0.0
            amt_cell = self._cell(fmt_money(amt_val))
            if amt_val < 0:
                amt_cell.setForeground(Qt.red)  # subtle hint for refunds
            self.tbl_payments.setItem(r, 2, amt_cell)

            # State
            state = row.get("clearing_state", "")
            self.tbl_payments.setItem(r, 3, self._cell(_text(state)))

            # Ref #
            ref = row.get("ref_no") or row.get("instrument_no") or ""
            self.tbl_payments.setItem(r, 4, self._cell(_text(ref)))

            # Bank (best-effort label)
            bank_label = ""
            if row.get("bank_name"):
                acct_bits = []
                if row.get("account_title"):
                    acct_bits.append(row["account_title"])
                if row.get("account_no"):
                    acct_bits.append(f"({row['account_no']})")
                bank_label = f"{row['bank_name']} " + " ".join(acct_bits) if acct_bits else row["bank_name"]
            elif row.get("bank_account_id"):
                bank_label = f"#{row['bank_account_id']}"
            self.tbl_payments.setItem(r, 5, self._cell(bank_label))

        self.tbl_payments.resizeColumnsToContents()

    @staticmethod
    def _cell(text: str) -> QTableWidgetItem:
        it = QTableWidgetItem(text)
        it.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)
        return it

    # --- visibility helpers ------------------------------------------------

    def _set_row_visible(self, field_widget: QWidget, visible: bool):
        """Hide/show a row in the QFormLayout by hiding both the value and its label."""
        try:
            label = self._form.labelForField(field_widget)
            if label is not None:
                label.setVisible(visible)
        except Exception:
            pass
        field_widget.setVisible(visible)

    def _apply_doc_type_visibility(self, doc_type: str):
        """
        For quotations: hide returns summary rows and the payments box.
        For sales: show them.
        """
        is_quote = (str(doc_type).lower() == "quotation")
        # Returns rows
        self._set_row_visible(self.lab_returned_qty, not is_quote)
        self._set_row_visible(self.lab_returned_val, not is_quote)
        self._set_row_visible(self.lab_net_after, not is_quote)
        # Payments panel
        self.pay_box.setVisible(not is_quote)

    # ----------------------------------------------------------------------

    def set_data(self, r: dict | None):
        if not r:
            self._reset()
            return

        # Toggle sections based on doc_type
        self._apply_doc_type_visibility(r.get("doc_type", "sale"))

        # Header
        self.lab_id.setText(r.get("sale_id", "-"))
        self.lab_date.setText(r.get("date", "-"))
        self.lab_customer.setText(r.get("customer_name", "-"))

        # Money (header-level)
        total_amount = float(r.get("total_amount", 0.0) or 0.0)
        order_discount = float(r.get("order_discount", 0.0) or 0.0)
        paid_amount = float(r.get("paid_amount", 0.0) or 0.0)

        self.lab_total.setText(fmt_money(total_amount))
        self.lab_discount.setText(fmt_money(order_discount))
        self.lab_total_discount.setText(fmt_money(r.get("overall_discount", 0.0)))

        # Returns summary
        self.lab_returned_qty.setText(f"{float(r.get('returned_qty', 0.0) or 0.0):g}")
        self.lab_returned_val.setText(fmt_money(r.get("returned_value", 0.0)))
        self.lab_net_after.setText(fmt_money(r.get("net_after_returns", 0.0)))

        # Paid / remaining / status
        self.lab_paid.setText(fmt_money(paid_amount))
        self.lab_remain.setText(fmt_money(max(0.0, total_amount - paid_amount)))
        self.lab_status.setText(r.get("payment_status", "-"))

        # Optional: customer credit balance
        if "customer_credit_balance" in r and r["customer_credit_balance"] is not None:
            try:
                self.lab_credit.setText(fmt_money(float(r["customer_credit_balance"])))
            except Exception:
                self.lab_credit.setText(fmt_money(0.0))
        else:
            self.lab_credit.setText("-")

        # Optional: payments list
        payments = r.get("payments") or []
        norm_rows = []
        for row in payments:
            try:
                if isinstance(row, dict):
                    norm_rows.append(row)
                else:
                    norm_rows.append(dict(row))  # sqlite3.Row → dict
            except Exception:
                continue
        self._load_payments(norm_rows)

```

inventory_management/modules/sales/return.py
```

```

inventory_management/modules/purchase/form.py
```
from PySide6.QtWidgets import (
    QDialog, QFormLayout, QDialogButtonBox, QVBoxLayout, QHBoxLayout, QComboBox,
    QDateEdit, QLineEdit, QPushButton, QLabel, QGroupBox, QTableWidget, QTableWidgetItem,
    QAbstractItemView, QScrollArea, QWidget, QHeaderView, QGridLayout
)
from PySide6.QtCore import Qt, QDate
from ...database.repositories.vendors_repo import VendorsRepo
from ...database.repositories.products_repo import ProductsRepo
from ...utils.helpers import today_str, fmt_money

TRASH_ICON = None  # optional; you can drop a png into resources/icons and set the path


class PurchaseForm(QDialog):
    # Discount column removed
    COLS = ["#", "Product", "Qty", "Buy Price", "Sale Price", "Line Total", ""]

    def __init__(self, parent=None, vendors: VendorsRepo | None = None,
                 products: ProductsRepo | None = None, initial=None):
        super().__init__(parent)
        self.setWindowTitle("Purchase")
        self.setModal(True)
        self.vendors = vendors
        self.products = products
        self._payload = None

        # ===== Content (inside scroll) =====
        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        main_layout.setContentsMargins(12, 12, 12, 12)
        main_layout.setSpacing(10)

        # --- Header (two columns) ---
        self.cmb_vendor = QComboBox(); self.cmb_vendor.setEditable(True)
        for v in self.vendors.list_vendors():
            self.cmb_vendor.addItem(f"{v.name} (#{v.vendor_id})", v.vendor_id)

        self.date = QDateEdit(); self.date.setCalendarPopup(True)
        self.date.setDate(
            QDate.fromString(initial["date"], "yyyy-MM-dd")
            if initial and initial.get("date") else
            QDate.fromString(today_str(), "yyyy-MM-dd")
        )
        # Order discount removed
        self.txt_notes = QLineEdit()

        header_box = QGroupBox()
        hg = QGridLayout(header_box)
        hg.setHorizontalSpacing(12); hg.setVerticalSpacing(8)

        def add_pair(row, col, text, widget):
            c = col * 2
            hg.addWidget(QLabel(text), row, c)
            hg.addWidget(widget, row, c + 1)

        add_pair(0, 0, "Vendor*", self.cmb_vendor)
        add_pair(0, 1, "Date*", self.date)
        add_pair(1, 0, "Notes", self.txt_notes)
        hg.setColumnStretch(1, 1)
        hg.setColumnStretch(3, 1)
        main_layout.addWidget(header_box)

        # --- Items table (expand to fill space) ---
        items_box = QGroupBox("Items")
        ib = QVBoxLayout(items_box)
        ib.setSpacing(8)

        self.tbl = QTableWidget(0, len(self.COLS))
        self.tbl.setHorizontalHeaderLabels(self.COLS)
        self.tbl.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tbl.setEditTriggers(QAbstractItemView.AllEditTriggers)
        self.tbl.verticalHeader().setVisible(False)

        header = self.tbl.horizontalHeader()
        header.setSectionResizeMode(1, QHeaderView.Stretch)  # Product column grows
        # compact widths for numeric cols (indices updated)
        self.tbl.setColumnWidth(0, 40)   # #
        self.tbl.setColumnWidth(2, 80)   # Qty
        self.tbl.setColumnWidth(3, 110)  # Buy
        self.tbl.setColumnWidth(4, 110)  # Sale
        self.tbl.setColumnWidth(5, 120)  # Line Total
        self.tbl.setColumnWidth(6, 48)   # Delete btn

        ib.addWidget(self.tbl, 1)

        row_btns = QHBoxLayout()
        self.btn_add_row = QPushButton("Add Row")
        row_btns.addWidget(self.btn_add_row)
        row_btns.addStretch(1)
        ib.addLayout(row_btns)

        main_layout.addWidget(items_box, 2)

        # --- Totals (compact) ---
        tot = QHBoxLayout()
        self.lab_sub = QLabel("0.00")
        self.lab_total = QLabel("0.00")
        tot.addStretch(1)
        tot.addWidget(QLabel("Subtotal:")); tot.addWidget(self.lab_sub)
        tot.addSpacing(16)
        tot.addWidget(QLabel("Total:"));    tot.addWidget(self.lab_total)
        main_layout.addLayout(tot)

        # --- Initial Payment (two columns) ---
        ip_box = QGroupBox("Initial Payment (optional)")
        ipg = QGridLayout(ip_box)
        ipg.setHorizontalSpacing(12); ipg.setVerticalSpacing(8)

        self.ip_amount = QLineEdit();    self.ip_amount.setPlaceholderText("0")
        self.ip_date = QDateEdit();      self.ip_date.setCalendarPopup(True); self.ip_date.setDate(self.date.date())

        # Include Cash (top) and Other
        self.ip_method = QComboBox()
        self.ip_method.addItems(["Cash", "Bank Transfer", "Cheque", "Cash Deposit", "Other"])

        self.ip_company_acct = QComboBox(); self.ip_company_acct.setEditable(True)
        self.ip_vendor_acct  = QComboBox(); self.ip_vendor_acct.setEditable(True)
        self.ip_instr_no   = QLineEdit(); self.ip_instr_no.setPlaceholderText("Instrument / Cheque / Slip #")
        self.ip_instr_date = QDateEdit(); self.ip_instr_date.setCalendarPopup(True); self.ip_instr_date.setDate(self.ip_date.date())
        self.ip_ref_no     = QLineEdit(); self.ip_ref_no.setPlaceholderText("Reference (optional)")
        self.ip_notes      = QLineEdit(); self.ip_notes.setPlaceholderText("Notes (optional)")

        def add_ip(row, col, text, widget):
            c = col * 2
            ipg.addWidget(QLabel(text), row, c)
            ipg.addWidget(widget, row, c + 1)

        add_ip(0, 0, "Amount", self.ip_amount)
        add_ip(0, 1, "Payment Date", self.ip_date)
        add_ip(1, 0, "Method", self.ip_method)
        add_ip(1, 1, "Company Bank Account", self.ip_company_acct)
        add_ip(2, 0, "Vendor Bank Account", self.ip_vendor_acct)
        add_ip(2, 1, "Instrument No", self.ip_instr_no)
        add_ip(3, 0, "Instrument Date", self.ip_instr_date)
        add_ip(3, 1, "Ref No", self.ip_ref_no)
        ipg.addWidget(QLabel("Payment Notes"), 4, 0)
        ipg.addWidget(self.ip_notes, 4, 1, 1, 3)
        ipg.setColumnStretch(1, 1)
        ipg.setColumnStretch(3, 1)

        self._ip_instrument_type = None
        self._ip_clearing_state = None

        main_layout.addWidget(ip_box, 0)

        # ===== Buttons OUTSIDE scroll =====
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

        # Scroll wrapper
        scroll_area = QScrollArea()
        scroll_area.setWidget(main_widget)
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)

        final_layout = QVBoxLayout(self)
        final_layout.setContentsMargins(12, 12, 12, 12)
        final_layout.setSpacing(8)
        final_layout.addWidget(scroll_area, 1)
        final_layout.addWidget(button_box, 0)

        # ===== State / wiring =====
        self._rows = []
        if initial and initial.get("items"):
            self._rows = [dict(x) for x in initial["items"]]

        self.btn_add_row.clicked.connect(self._add_row)
        self.tbl.cellChanged.connect(self._cell_changed)

        self.cmb_vendor.currentIndexChanged.connect(self._reload_vendor_accounts)
        self.ip_method.currentIndexChanged.connect(self._refresh_ip_visibility)
        self.ip_date.dateChanged.connect(lambda _d: self.ip_instr_date.setDate(self.ip_date.date()))
        self.date.dateChanged.connect(
            lambda _d: (self.ip_date.setDate(self.date.date())
                        if (self.ip_amount.text().strip() in ("", "0", "0.0")) else None)
        )

        if initial:
            idx = self.cmb_vendor.findData(initial["vendor_id"])
            if idx >= 0: self.cmb_vendor.setCurrentIndex(idx)
            self.txt_notes.setText(initial.get("notes") or "")

        self._reload_company_accounts()
        self._reload_vendor_accounts()
        self._refresh_ip_visibility()
        self._rebuild_table()
        self._refresh_totals()

        # Sensible sizing for 1366×768 screens
        self.resize(1100, 700)
        self.setMinimumSize(860, 560)
        self.setSizeGripEnabled(True)

    # ---------------- helpers for initial payment panel ----------------
    def _reload_company_accounts(self):
        self.ip_company_acct.clear()
        try:
            conn = self.vendors.conn
            rows = conn.execute(
                "SELECT account_id, label FROM company_bank_accounts WHERE is_active=1 ORDER BY account_id"
            ).fetchall()
            for r in rows:
                self.ip_company_acct.addItem(r["label"], int(r["account_id"]))
        except Exception:
            pass

    def _reload_vendor_accounts(self):
        self.ip_vendor_acct.clear()
        vid = self.cmb_vendor.currentData()
        if not vid:
            return
        try:
            conn = self.vendors.conn
            rows = conn.execute(
                """
                SELECT vendor_bank_account_id AS vba_id, label, is_primary
                FROM vendor_bank_accounts
                WHERE vendor_id=? AND is_active=1
                ORDER BY is_primary DESC, vba_id
                """,
                (int(vid),),
            ).fetchall()
            for r in rows:
                label = r["label"] + (" (Primary)" if str(r.get("is_primary", 0)) in ("1","True","true") else "")
                self.ip_vendor_acct.addItem(label, int(r["vba_id"]))
        except Exception:
            pass

    def _refresh_ip_visibility(self):
        method = self.ip_method.currentText()
        need_company = method in ("Bank Transfer", "Cheque")
        need_vendor  = method in ("Bank Transfer", "Cheque", "Cash Deposit")
        need_instr   = method in ("Bank Transfer", "Cheque", "Cash Deposit")
        need_idate   = method in ("Bank Transfer", "Cheque", "Cash Deposit")

        self.ip_company_acct.setEnabled(need_company); self.ip_company_acct.setVisible(need_company)
        self.ip_vendor_acct.setEnabled(need_vendor);   self.ip_vendor_acct.setVisible(need_vendor)
        self.ip_instr_no.setEnabled(need_instr);       self.ip_instr_no.setVisible(need_instr)
        self.ip_instr_date.setEnabled(need_idate);     self.ip_instr_date.setVisible(need_idate)

        m = method
        if m == "Bank Transfer":
            self._ip_instrument_type = "online";        self._ip_clearing_state = "posted"
        elif m == "Cheque":
            self._ip_instrument_type = "cross_cheque";  self._ip_clearing_state = "pending"
        elif m == "Cash Deposit":
            self._ip_instrument_type = "cash_deposit";  self._ip_clearing_state = "pending"
        elif m == "Cash":
            self._ip_instrument_type = "cash";          self._ip_clearing_state = "posted"
        else:  # "Other"
            self._ip_instrument_type = "other";         self._ip_clearing_state = "pending"

    # ---------------- table helpers ----------------
    def _all_products(self):
        return self.products.list_products()

    def _base_uom_id(self, product_id: int) -> int:
        base = self.products.get_base_uom(product_id)
        if base: return int(base["uom_id"])
        u = self.products.list_uoms()
        return int(u[0]["uom_id"]) if u else 1

    def _delete_row_for_button(self, btn: QPushButton):
        for r in range(self.tbl.rowCount()):
            if self.tbl.cellWidget(r, 6) is btn:  # column index updated
                self.tbl.removeRow(r)
                self._reindex_rows()
                self._refresh_totals()
                return

    def _add_row(self, pre: dict | None = None):
        self.tbl.blockSignals(True)
        r = self.tbl.rowCount()
        self.tbl.insertRow(r)

        num = QTableWidgetItem(str(r + 1))
        num.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        self.tbl.setItem(r, 0, num)

        cmb_prod = QComboBox()
        for p in self._all_products():
            cmb_prod.addItem(f"{p.name} (#{p.product_id})", p.product_id)
        self.tbl.setCellWidget(r, 1, cmb_prod)

        # Fill editable numeric cells (no discount column now)
        for c in (2, 3, 4):
            it = QTableWidgetItem("0")
            it.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
            self.tbl.setItem(r, c, it)

        # Line total
        it_total = QTableWidgetItem("0.00")
        it_total.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
        it_total.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        self.tbl.setItem(r, 5, it_total)

        # Delete button
        btn_del = QPushButton("✕")
        btn_del.clicked.connect(lambda _=False, b=btn_del: self._delete_row_for_button(b))
        self.tbl.setCellWidget(r, 6, btn_del)

        def on_prod_changed():
            pid = cmb_prod.currentData()
            self.tbl.item(r, 0).setData(Qt.UserRole, self._base_uom_id(int(pid)) if pid else None)
            self._recalc_row(r); self._refresh_totals()
        cmb_prod.currentIndexChanged.connect(on_prod_changed)

        if pre:
            i = cmb_prod.findData(pre.get("product_id"))
            if i >= 0: cmb_prod.setCurrentIndex(i)
            self.tbl.item(r, 2).setText(str(pre.get("quantity", 0)))
            self.tbl.item(r, 3).setText(str(pre.get("purchase_price", 0)))
            self.tbl.item(r, 4).setText(str(pre.get("sale_price", 0)))
            if "uom_id" in pre:
                self.tbl.item(r, 0).setData(Qt.UserRole, int(pre["uom_id"]))
        else:
            on_prod_changed()

        self.tbl.blockSignals(False)
        self._recalc_row(r)

    def _reindex_rows(self):
        for r in range(self.tbl.rowCount()):
            if self.tbl.item(r, 0):
                self.tbl.item(r, 0).setText(str(r + 1))

    def _rebuild_table(self):
        self.tbl.blockSignals(True)
        self.tbl.setRowCount(0)
        if not self._rows:
            self._add_row({})
        else:
            for row in self._rows:
                self._add_row(row)
        self.tbl.blockSignals(False)
        self._refresh_totals()

    def _cell_changed(self, row: int, col: int):
        if row < 0 or row >= self.tbl.rowCount():
            return
        for c in (2, 3, 4, 5):  # ensure cells exist
            if self.tbl.item(row, c) is None and self.tbl.cellWidget(row, c) is None:
                return
        self._recalc_row(row)
        self._refresh_totals()

    def _recalc_row(self, r: int):
        def num(c):
            it = self.tbl.item(r, c)
            try:
                return float(it.text()) if it and it.text() else 0.0
            except Exception:
                return 0.0

        qty  = num(2)
        buy  = num(3)
        sale = num(4)

        def mark(col, bad):
            it = self.tbl.item(r, col)
            if it:
                it.setBackground(Qt.red if bad else Qt.white)

        bad_buy  = buy <= 0
        bad_sale = not (sale >= buy > 0)
        mark(3, bad_buy)
        mark(4, bad_sale or bad_buy)

        line_total = max(0.0, qty * buy)
        lt_item = self.tbl.item(r, 5)
        if lt_item:
            lt_item.setText(fmt_money(line_total))

    def _calc_subtotal(self) -> float:
        s = 0.0
        for r in range(self.tbl.rowCount()):
            try:
                qty  = float(self.tbl.item(r, 2).text() or 0)
                buy  = float(self.tbl.item(r, 3).text() or 0)
            except Exception:
                continue
            s += max(0.0, qty * buy)
        return s

    def _refresh_totals(self):
        sub = self._calc_subtotal()
        tot = sub  # no order discount
        self.lab_sub.setText(fmt_money(sub))
        self.lab_total.setText(fmt_money(tot))

    # ------------- payload -------------
    def _row_payload(self, r: int) -> dict | None:
        cmb_prod: QComboBox = self.tbl.cellWidget(r, 1)
        if not cmb_prod: return None
        pid = cmb_prod.currentData()
        if not pid: return None

        def num(c):
            it = self.tbl.item(r, c)
            try:
                return float(it.text()) if it and it.text() else 0.0
            except Exception:
                return 0.0

        qty  = num(2); buy = num(3); sale = num(4)
        if qty <= 0 or buy <= 0 or not (sale >= buy):
            return None
        uom_id = self.tbl.item(r, 0).data(Qt.UserRole)
        if not uom_id:
            uom_id = self._base_uom_id(int(pid))
        return {
            "product_id": int(pid),
            "uom_id": int(uom_id),
            "quantity": qty,
            "purchase_price": buy,
            "sale_price": sale,
            "item_discount": 0.0,  # kept for compatibility
        }

    def get_payload(self) -> dict | None:
        try:
            vendor_id = int(self.cmb_vendor.currentData())
        except Exception:
            return None

        rows = []
        for r in range(self.tbl.rowCount()):
            cmb_prod = self.tbl.cellWidget(r, 1)
            if not cmb_prod: continue
            product_id = cmb_prod.currentData()
            if product_id in (None, ""): continue
            qty_it  = self.tbl.item(r, 2)
            buy_it  = self.tbl.item(r, 3)
            sale_it = self.tbl.item(r, 4)
            try:
                qty  = float((qty_it.text()  or "0").strip())
                buy  = float((buy_it.text()  or "0").strip())
                sale = float((sale_it.text() or "0").strip())
            except Exception:
                return None
            if qty <= 0 or buy <= 0: return None
            uom_id = self.tbl.item(r, 0).data(Qt.UserRole)
            if uom_id is None:
                try:
                    uom_id = int(self.products.get_base_uom(product_id)["uom_id"])
                except Exception:
                    uom_id = self._base_uom_id(product_id)
            if uom_id is None: return None
            rows.append({
                "product_id": int(product_id),
                "uom_id": int(uom_id),
                "quantity": qty,
                "purchase_price": buy,
                "sale_price": sale,
                "item_discount": 0.0,  # compatibility
            })

        if not rows: return None

        date_str = self.date.date().toString("yyyy-MM-dd")
        total_amount = self._calc_subtotal()  # no order discount

        payload = {
            "vendor_id": vendor_id,
            "date": date_str,
            "order_discount": 0.0,  # kept for compatibility
            "notes": (self.txt_notes.text().strip() or None),
            "items": rows,
            "total_amount": total_amount,
        }

        # ----- Initial Payment payload (unchanged except for new methods) -----
        ip_amount_txt = self.ip_amount.text().strip() if hasattr(self, "ip_amount") else ""
        ip_amount = 0.0
        if ip_amount_txt:
            try: ip_amount = float(ip_amount_txt)
            except Exception: ip_amount = -1

        if ip_amount > 0:
            method = self.ip_method.currentText() if hasattr(self, "ip_method") else ""
            company_id = self.ip_company_acct.currentData() if hasattr(self, "ip_company_acct") else None
            vendor_bank_id = self.ip_vendor_acct.currentData() if hasattr(self, "ip_vendor_acct") else None
            instr_no = self.ip_instr_no.text().strip() if hasattr(self, "ip_instr_no") else ""
            instr_date = self.ip_instr_date.date().toString("yyyy-MM-dd") if hasattr(self, "ip_instr_date") else date_str
            ref_no = self.ip_ref_no.text().strip() if hasattr(self, "ip_ref_no") else None
            notes = self.ip_notes.text().strip() if hasattr(self, "ip_notes") else None

            m = (method or "").strip().lower()
            if m == "bank transfer":
                if not company_id or not vendor_bank_id or not instr_no: return None
                instr_type = "online";        clearing_state = "posted"
            elif m == "cheque":
                if not company_id or not vendor_bank_id or not instr_no: return None
                instr_type = "cross_cheque";  clearing_state = "pending"
            elif m == "cash deposit":
                if not vendor_bank_id or not instr_no: return None
                instr_type = "cash_deposit";  clearing_state = "pending"; company_id = None
            elif m == "cash":
                instr_type = "cash";          clearing_state = "posted"
                company_id = None;            vendor_bank_id = None
                instr_no = "";                instr_date = date_str
            else:  # "other"
                instr_type = "other";         clearing_state = "pending"
                company_id = None;            vendor_bank_id = None
                instr_no = "";                instr_date = date_str

            payload["initial_payment"] = {
                "amount": ip_amount,
                "method": method,
                "bank_account_id": int(company_id) if company_id else None,
                "vendor_bank_account_id": int(vendor_bank_id) if vendor_bank_id else None,
                "instrument_type": instr_type,
                "instrument_no": instr_no,
                "instrument_date": instr_date,
                "deposited_date": None,
                "cleared_date": None,
                "clearing_state": clearing_state,
                "ref_no": ref_no,
                "notes": notes,
                "date": date_str,
            }
            # legacy mirrors
            payload["initial_bank_account_id"] = payload["initial_payment"]["bank_account_id"]
            payload["initial_vendor_bank_account_id"] = payload["initial_payment"]["vendor_bank_account_id"]
            payload["initial_instrument_type"] = payload["initial_payment"]["instrument_type"]
            payload["initial_instrument_no"] = payload["initial_payment"]["instrument_no"]
            payload["initial_instrument_date"] = payload["initial_payment"]["instrument_date"]
            payload["initial_deposited_date"] = payload["initial_payment"]["deposited_date"]
            payload["initial_cleared_date"] = payload["initial_payment"]["cleared_date"]
            payload["initial_clearing_state"] = payload["initial_payment"]["clearing_state"]
            payload["initial_ref_no"] = payload["initial_payment"]["ref_no"]
            payload["initial_payment_notes"] = payload["initial_payment"]["notes"]
            payload["initial_method"] = payload["initial_payment"]["method"]

        return payload

    def accept(self):
        p = self.get_payload()
        if p is None: return
        self._payload = p
        super().accept()

    def payload(self):
        return self._payload

```

inventory_management/modules/purchase/item_form.py
```
from PySide6.QtWidgets import QDialog, QFormLayout, QDialogButtonBox, QVBoxLayout, QComboBox, QLineEdit
from PySide6.QtCore import Qt
from ...utils.validators import is_positive_number, non_empty
from ...database.repositories.products_repo import ProductsRepo

class PurchaseItemForm(QDialog):
    def __init__(self, parent=None, repo: ProductsRepo | None = None, initial=None):
        super().__init__(parent)
        self.setWindowTitle("Purchase Item")
        self.setModal(True)
        self.repo = repo
        self.cmb_product = QComboBox()
        self.cmb_product.setEditable(True)
        for p in self.repo.list_products():
            self.cmb_product.addItem(f"{p.name} (#{p.product_id})", p.product_id)
        
        # Initialize base UoM tracking
        self._base_uom_id = None
        
        # Configure UoM dropdown
        self.cmb_uom = QComboBox()
        self.cmb_uom.setEditable(False)
        self.cmb_uom.setEnabled(False)  # read-only; always shows base UoM for selected product
        
        # Other form fields
        self.txt_qty = QLineEdit();      self.txt_qty.setPlaceholderText("Quantity")
        self.txt_buy = QLineEdit();      self.txt_buy.setPlaceholderText("Purchase price")
        self.txt_sale = QLineEdit();     self.txt_sale.setPlaceholderText("Default sale price")
        self.txt_disc = QLineEdit();     self.txt_disc.setPlaceholderText("Item discount (per-unit)")
        
        # Layout setup
        lay = QVBoxLayout(self)
        form = QFormLayout()
        form.addRow("Product*", self.cmb_product)
        form.addRow("UoM*", self.cmb_uom)
        form.addRow("Quantity*", self.txt_qty)
        form.addRow("Purchase Price*", self.txt_buy)
        form.addRow("Sale Price*", self.txt_sale)
        form.addRow("Item Discount", self.txt_disc)
        lay.addLayout(form)
        
        # Buttons
        self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        lay.addWidget(self.buttons)
        
        self._payload = None
        
        # Connect product change handler
        self.cmb_product.currentIndexChanged.connect(self._on_product_changed)
        
        # Load base UoM for the first/selected product
        self._on_product_changed()
        
        if initial:
            # initial dict keys: product_id, uom_id, quantity, purchase_price, sale_price, item_discount
            idx = self.cmb_product.findData(initial["product_id"])
            if idx >= 0:
                self.cmb_product.setCurrentIndex(idx)
                # _on_product_changed() will refresh base UoM and set self._base_uom_id
            # ignore initial["uom_id"] if it isn't base; we always enforce base here
            self.txt_qty.setText(str(initial["quantity"]))
            self.txt_buy.setText(str(initial["purchase_price"]))
            self.txt_sale.setText(str(initial["sale_price"]))
            self.txt_disc.setText(str(initial["item_discount"]))
    
    def _fetch_product_record(self, product_id):
        """
        Fetch product record with base UoM information using multiple fallback approaches.
        Returns dict with product info or None if not found.
        """
        repo = getattr(self, "repo", None)
        
        # Direct getters
        for m in ("get_by_id", "get", "get_product", "find_by_id", "get_one"):
            if repo and hasattr(repo, m):
                try:
                    rec = getattr(repo, m)(int(product_id))
                    if rec:
                        return dict(rec)
                except Exception:
                    pass
        
        # List & filter fallbacks
        for m in ("list", "list_all", "list_products"):
            if repo and hasattr(repo, m):
                try:
                    rows = getattr(repo, m)()
                    for row in rows or []:
                        d = dict(row)
                        if int(d.get("product_id") or d.get("id") or -1) == int(product_id):
                            return d
                except Exception:
                    pass
        
        # Raw SQL fallback if repo exposes .conn (corrected to use uoms)
        try:
            conn = getattr(repo, "conn", None)
            if conn is not None:
                row = conn.execute(
                    """
                    SELECT p.product_id,
                           COALESCE(p.base_uom_id, p.uom_id) AS base_uom_id,
                           u.unit_name AS unit_name
                    FROM products p
                    LEFT JOIN uoms u ON u.uom_id = COALESCE(p.base_uom_id, p.uom_id)
                    WHERE p.product_id = ?
                    """,
                    (int(product_id),)
                ).fetchone()
                return dict(row) if row else None
        except Exception:
            pass
        
        return None
    
    def _resolve_base_uom(self, product_id: int):
        """
        Try repo.get_base_uom(product_id) first. If not available,
        scan repo.product_uoms(product_id) for is_base=1.
        Returns (uom_id, unit_name) or None if not found.
        """
        # Preferred API
        if hasattr(self.repo, "get_base_uom"):
            try:
                row = self.repo.get_base_uom(product_id)
                # row can be sqlite3.Row or dict-like
                if row and (row.get("uom_id") is not None):
                    return int(row["uom_id"]), row["unit_name"]
            except Exception:
                pass
        
        # Fallback: scan product_uoms
        try:
            puoms = self.repo.product_uoms(product_id) or []
            for m in puoms:
                # handle either bool/int flags or missing key
                if str(m.get("is_base", 0)) in ("1", "True", "true"):
                    return int(m["uom_id"]), m["unit_name"]
        except Exception:
            pass
        
        return None
    
    def _on_product_changed(self, *_):
        """Load ONLY the base UoM for the currently selected product (sync, no timers)."""
        try:
            pid = self.cmb_product.currentData()
        except Exception:
            pid = None
        if pid is None:
            return

        base = None

        # 1) Preferred: repo.get_base_uom(product_id)
        if getattr(self, "repo", None) and hasattr(self.repo, "get_base_uom"):
            try:
                row = self.repo.get_base_uom(int(pid))
                if row:
                    # sqlite3.Row or dict-like
                    base = (int(row["uom_id"]), row["unit_name"])
            except Exception:
                pass

        # 2) Fallback: scan product_uoms for is_base=1
        if base is None and hasattr(self.repo, "product_uoms"):
            try:
                for m in (self.repo.product_uoms(int(pid)) or []):
                    if int(m.get("is_base") or 0) == 1:
                        base = (int(m["uom_id"]), m["unit_name"])
                        break
            except Exception:
                pass

        # 3) Last resort: raw SQL (correct table names)
        if base is None:
            try:
                conn = getattr(self.repo, "conn", None)
                if conn:
                    row = conn.execute(
                        """
                        SELECT
                            COALESCE(pu.uom_id, p.uom_id) AS uom_id,
                            u.unit_name
                        FROM products p
                        LEFT JOIN product_uoms pu
                               ON pu.product_id = p.product_id AND pu.is_base = 1
                        LEFT JOIN uoms u
                               ON u.uom_id = COALESCE(pu.uom_id, p.uom_id)
                        WHERE p.product_id = ?
                        """,
                        (int(pid),)
                    ).fetchone()
                    if row:
                        # row may be tuple or Row
                        is_mapping = isinstance(row, dict) or hasattr(row, "keys")
                        uom_id = int(row["uom_id"] if is_mapping else row[0])
                        name = row["unit_name"] if is_mapping else row[1]
                        base = (uom_id, name)
            except Exception:
                pass

        # Apply to UI (ensure tests see count>=1 and _base_uom_id != None)
        self._base_uom_id = base[0] if base else None
        if hasattr(self, "cmb_uom"):
            self.cmb_uom.blockSignals(True)
            try:
                self.cmb_uom.clear()
                if base:
                    self.cmb_uom.addItem(str(base[1]), int(base[0]))
                else:
                    # Still add one item so the widget isn't empty, but use -1
                    self.cmb_uom.addItem("UoM", -1)
            finally:
                self.cmb_uom.blockSignals(False)
            self.cmb_uom.setEnabled(False)
    
    def get_payload(self) -> dict | None:
        pid = self.cmb_product.currentData()
        # Always use base UoM
        uom_id = self._base_uom_id if self._base_uom_id is not None else (
            self.cmb_uom.currentData() if hasattr(self, "cmb_uom") else None
        )
        if not pid or uom_id is None:
            return None

        # Strict numeric parsing
        try:
            qty_val = float((self.txt_qty.text() or "").strip())
            buy_val = float((self.txt_buy.text() or "").strip())
            sale_val = float((self.txt_sale.text() or "0").strip())
        except Exception:
            return None

        # Enforce: qty > 0, buy > 0, sale >= 0
        if not (qty_val > 0.0):
            return None
        if not (buy_val > 0.0):
            return None
        if sale_val < 0.0:
            return None

        # Discount: default 0; 0 ≤ disc < buy
        disc_str = (self.txt_disc.text() or "").strip()
        try:
            disc_val = float(disc_str) if disc_str else 0.0
        except Exception:
            return None
        if disc_val < 0.0 or disc_val >= buy_val:
            return None

        return {
            "product_id": int(pid),
            "uom_id": int(uom_id),         # ALWAYS base UoM
            "quantity": qty_val,
            "purchase_price": buy_val,
            "sale_price": sale_val,     # may be < buy_val
            "item_discount": disc_val
        }
    
    def accept(self):
        p = self.get_payload()
        if p is None:
            return
        self._payload = p
        super().accept()
    
    def payload(self):
        return self._payload

```

inventory_management/modules/purchase/__init__.py
```
# /home/pc/Desktop/inventory_management/modules/purchase/__init__.py

"""
Purchase module package exports.

Always available:
- PurchaseController

Optional UI/model components (imported defensively so environments
without Qt can still import this package):
- PurchaseView
- PurchasesTableModel
- PurchaseItemsModel
- PurchaseForm
- PurchaseReturnForm
- PurchasePaymentDialog
- PurchaseDetails
- PurchaseItemForm
- PurchaseItemsView
"""

from .controller import PurchaseController

# UI/model pieces are optional to avoid a hard Qt dependency during headless tests
try:
    from .view import PurchaseView  # type: ignore
    from .model import PurchasesTableModel, PurchaseItemsModel  # type: ignore
    from .form import PurchaseForm  # type: ignore
    from .return_form import PurchaseReturnForm  # type: ignore
    from .payments import PurchasePaymentDialog  # type: ignore
    from .details import PurchaseDetails  # type: ignore
    from .item_form import PurchaseItemForm  # type: ignore
    from .items import PurchaseItemsView  # type: ignore
except Exception:  # pragma: no cover
    PurchaseView = None  # type: ignore
    PurchasesTableModel = None  # type: ignore
    PurchaseItemsModel = None  # type: ignore
    PurchaseForm = None  # type: ignore
    PurchaseReturnForm = None  # type: ignore
    PurchasePaymentDialog = None  # type: ignore
    PurchaseDetails = None  # type: ignore
    PurchaseItemForm = None  # type: ignore
    PurchaseItemsView = None  # type: ignore

__all__ = [
    "PurchaseController",
    "PurchaseView",
    "PurchasesTableModel",
    "PurchaseItemsModel",
    "PurchaseForm",
    "PurchaseReturnForm",
    "PurchasePaymentDialog",
    "PurchaseDetails",
    "PurchaseItemForm",
    "PurchaseItemsView",
]

```

inventory_management/modules/purchase/return_form.py
```
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QGroupBox, QTableWidget, QTableWidgetItem,
    QAbstractItemView, QDialogButtonBox, QLineEdit, QFormLayout, QLabel, QComboBox, QDateEdit
)
from PySide6.QtCore import Qt, QDate, QTimer
from ...utils.helpers import today_str, fmt_money


def _first_key(d: dict, *keys, default=None):
    for k in keys:
        if k in d and d[k] is not None:
            return d[k]
    return default


class PurchaseReturnForm(QDialog):
    # Column indices
    COL_ITEM_ID = 0
    COL_PRODUCT = 1
    COL_UOM = 2
    COL_QTY_RETURN = 3
    COL_QTY_PURCHASED = 4
    COL_RETURNED_SO_FAR = 5
    COL_MAX_RETURNABLE = 6
    COL_LINE_VALUE = 7
    COL_NOTES = 8

    # Reordered headers: put Qty Return before any other 'qty/return' headers
    COLS = [
        "ItemID", "Product", "UoM",
        "Qty Return",
        "Qty Purchased",
        "Returned so far",
        "Max returnable",
        "Line Value",
        "Notes",
    ]

    def __init__(
        self,
        parent=None,
        items: list[dict] | None = None,
        *,
        vendor_id: int | None = None,
        vendor_bank_accounts_repo=None,
        company_bank_accounts_repo=None,
        purchases_repo=None,
    ):
        super().__init__(parent)
        self.setWindowTitle("Purchase Return")
        self.setModal(True)

        self.vendor_id = int(vendor_id) if vendor_id is not None else None
        self.vba_repo = vendor_bank_accounts_repo
        self.cba_repo = company_bank_accounts_repo

        # Header
        self.date = QDateEdit()
        self.date.setCalendarPopup(True)
        self.date.setDate(QDate.fromString(today_str(), "yyyy-MM-dd"))
        self.notes = QLineEdit()
        f = QFormLayout()
        f.addRow("Date", self.date)
        f.addRow("Notes", self.notes)

        # Table
        self.tbl = QTableWidget(0, len(self.COLS))
        self.tbl.setHorizontalHeaderLabels(self.COLS)
        self.tbl.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tbl.setEditTriggers(QAbstractItemView.AllEditTriggers)
        self.tbl.verticalHeader().setVisible(False)
        self.tbl.setColumnWidth(self.COL_ITEM_ID, 70)
        self.tbl.setColumnWidth(self.COL_PRODUCT, 220)
        self.tbl.setColumnWidth(self.COL_UOM, 80)
        self.tbl.setColumnWidth(self.COL_QTY_RETURN, 110)
        self.tbl.setColumnWidth(self.COL_QTY_PURCHASED, 110)
        self.tbl.setColumnWidth(self.COL_RETURNED_SO_FAR, 120)
        self.tbl.setColumnWidth(self.COL_MAX_RETURNABLE, 120)
        self.tbl.setColumnWidth(self.COL_LINE_VALUE, 120)
        self.tbl.setColumnWidth(self.COL_NOTES, 160)

        # Totals
        tot_bar = QHBoxLayout()
        tot_bar.addStretch(1)
        self.lab_qty_total = QLabel("0")
        self.lab_val_total = QLabel("Total Return Value: 0.00")
        tot_bar.addWidget(QLabel("Total Qty:")); tot_bar.addWidget(self.lab_qty_total)
        tot_bar.addSpacing(20)
        tot_bar.addWidget(self.lab_val_total)

        # Settlement
        settle_box = QGroupBox("Settlement")
        sb = QVBoxLayout(settle_box)

        mode_row = QHBoxLayout()
        self.cmb_mode = QComboBox()
        self.cmb_mode.addItems(["Credit Note", "Refund Now"])
        mode_row.addWidget(QLabel("Mode:"))
        mode_row.addWidget(self.cmb_mode)
        mode_row.addStretch(1)
        sb.addLayout(mode_row)

        self.ref_panel = QGroupBox("Refund (Incoming)")
        rp = QFormLayout(self.ref_panel)

        self.cmb_method = QComboBox()
        # Allow the three labels test searches for
        self.cmb_method.addItems(["Bank Transfer", "Cheque", "Cash Deposit"])

        self.cmb_company_acct = QComboBox()
        self._load_company_accounts()

        self.cmb_vendor_acct = QComboBox()
        self._load_vendor_accounts()

        self.txt_instr_no = QLineEdit()
        self.txt_instr_no.setPlaceholderText("Instrument / Cheque / Slip No")

        self.date_instr = QDateEdit()
        self.date_instr.setCalendarPopup(True)
        self.date_instr.setDate(self.date.date())

        self._clearing_state_fixed = "posted"

        rp.addRow("Method", self.cmb_method)
        rp.addRow("Company Account*", self.cmb_company_acct)
        rp.addRow("Vendor Account", self.cmb_vendor_acct)
        rp.addRow("Instrument No*", self.txt_instr_no)
        rp.addRow("Instrument Date", self.date_instr)
        sb.addWidget(self.ref_panel)
        self.ref_panel.setVisible(False)

        # Buttons
        self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)

        # Layout
        lay = QVBoxLayout(self)
        lay.addLayout(f)
        lay.addWidget(self.tbl, 1)
        lay.addLayout(tot_bar)
        lay.addWidget(settle_box)
        lay.addWidget(self.buttons)

        self._payload = None
        self._qty_snapshot = []  # for polling
        if items:
            self.set_items(items)

        # signals (user editing)
        self.tbl.cellChanged.connect(self._cell_changed)
        self.tbl.itemChanged.connect(self._item_changed)
        self.cmb_mode.currentTextChanged.connect(self._toggle_mode)
        self.cmb_method.currentIndexChanged.connect(self._validate)
        self.date.dateChanged.connect(self._default_instrument_date)
        self.txt_instr_no.textChanged.connect(self._validate)
        self.cmb_company_acct.currentIndexChanged.connect(self._validate)
        self.cmb_vendor_acct.currentIndexChanged.connect(self._validate)
        self.date_instr.dateChanged.connect(self._validate)

        # polling (programmatic setItem on Qty cell)
        self._poll = QTimer(self)
        self._poll.setInterval(15)
        self._poll.timeout.connect(self._poll_scan_qty)
        self._poll.start()

        self._validate()
        self.resize(1020, 680)
        self.setSizeGripEnabled(True)

    # ---------- account loaders ----------
    def _load_company_accounts(self):
        self.cmb_company_acct.clear()
        rows = []
        repo = self.cba_repo
        try_methods = ("list_active", "list_all", "list", "list_bank_accounts")
        if repo:
            for m in try_methods:
                if hasattr(repo, m):
                    rows = getattr(repo, m)()
                    break
        if not rows:
            rows = [
                {"label": "Meezan — Current", "account_id": 1},
                {"label": "HBL — Current", "account_id": 2},
            ]
        for r in rows or []:
            label = _first_key(r, "label", "bank_name", default="Account")
            aid = _first_key(r, "account_id", "bank_account_id")
            self.cmb_company_acct.addItem(str(label), aid)

    def _load_vendor_accounts(self):
        self.cmb_vendor_acct.clear()
        rows = []
        repo = self.vba_repo
        if repo and self.vendor_id:
            try_methods = ("list_active_for_vendor", "list_for_vendor", "list_by_vendor")
            for m in try_methods:
                if hasattr(repo, m):
                    rows = getattr(repo, m)(self.vendor_id)
                    break
        primary_index = 0
        for i, r in enumerate(rows or []):
            label = _first_key(r, "label", default="Vendor Account")
            vid = _first_key(r, "vendor_bank_account_id", "id")
            self.cmb_vendor_acct.addItem(str(label), vid)
            if _first_key(r, "is_primary", default=0) == 1 and primary_index == 0:
                primary_index = i
        if self.cmb_vendor_acct.count() > 0:
            self.cmb_vendor_acct.setCurrentIndex(primary_index)

    # ---------- items ----------
    def set_items(self, items: list[dict]):
        """
        Accepts flexible keys:
          item_id; product_name/name/product; unit_name/uom_name/uom;
          quantity/qty/qty_purchased; returned_so_far/returned/qty_returned; returnable;
          purchase_price/buy/buy_price/unit_price/unit_cost/cost_price; item_discount/discount/disc
        """
        self.tbl.blockSignals(True)
        self.tbl.setRowCount(len(items))
        for r, it in enumerate(items):
            item_id = int(_first_key(it, "item_id", default=-1))
            product = str(_first_key(it, "product_name", "name", "product", default=f"#{item_id}"))
            uom = str(_first_key(it, "unit_name", "uom_name", "uom", default=""))
            qty_purchased = float(_first_key(it, "quantity", "qty", "qty_purchased", default=0.0))

            if "returnable" in it and it["returnable"] is not None:
                try:
                    max_returnable = float(it["returnable"])
                    returned_so_far = max(0.0, qty_purchased - max_returnable)
                except Exception:
                    max_returnable = 0.0
                    returned_so_far = 0.0
            else:
                returned_so_far = float(_first_key(it, "returned_so_far", "returned", "qty_returned", default=0.0))
                max_returnable = max(0.0, qty_purchased - returned_so_far)

            buy = float(_first_key(
                it, "purchase_price", "buy_price", "buy",
                "unit_purchase_price", "unit_price", "price",
                "unit_cost", "cost_price", default=0.0
            ))
            disc = float(_first_key(it, "item_discount", "discount", "disc", "unit_discount", default=0.0))
            net_unit = max(0.0, buy - disc)

            def ro(text):
                x = QTableWidgetItem(text)
                x.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                return x

            id_item = ro(str(item_id))
            id_item.setData(Qt.UserRole, {
                "purchase_price": buy,
                "item_discount": disc,
                "net_unit": net_unit,
                "max_returnable": max_returnable,
            })
            self.tbl.setItem(r, self.COL_ITEM_ID, id_item)
            self.tbl.setItem(r, self.COL_PRODUCT, ro(product))
            self.tbl.setItem(r, self.COL_UOM, ro(uom))
            self.tbl.setItem(r, self.COL_QTY_PURCHASED, ro(f"{qty_purchased:g}"))
            self.tbl.setItem(r, self.COL_RETURNED_SO_FAR, ro(f"{returned_so_far:g}"))
            self.tbl.setItem(r, self.COL_MAX_RETURNABLE, ro(f"{max_returnable:g}"))

            q_item = QTableWidgetItem("0")
            q_item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
            self.tbl.setItem(r, self.COL_QTY_RETURN, q_item)

            v_item = ro("0.00")
            v_item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
            self.tbl.setItem(r, self.COL_LINE_VALUE, v_item)

            self.tbl.setItem(r, self.COL_NOTES, QTableWidgetItem(""))

        self.tbl.blockSignals(False)
        self._qty_snapshot = self._snapshot_qtys()
        self._recalc_all()

    # ---------- reactive / polling ----------
    def _snapshot_qtys(self):
        return [
            (self.tbl.item(r, self.COL_QTY_RETURN).text() if self.tbl.item(r, self.COL_QTY_RETURN) else "")
            for r in range(self.tbl.rowCount())
        ]

    def _poll_scan_qty(self):
        # Detect programmatic replacements/changes of Qty cells
        curr = self._snapshot_qtys()
        if curr != self._qty_snapshot:
            self._qty_snapshot = curr
            self._recalc_all()

    def _cell_changed(self, row: int, col: int):
        if row >= 0 and col == self.COL_QTY_RETURN:
            self._recalc_row(row)
            self._refresh_totals()
            self._validate()

    def _item_changed(self, item: QTableWidgetItem):
        if item and item.column() == self.COL_QTY_RETURN:
            self._recalc_row(item.row())
            self._refresh_totals()
            self._validate()

    def _meta_for_row(self, r: int):
        id_cell = self.tbl.item(r, self.COL_ITEM_ID)
        meta = (id_cell.data(Qt.UserRole) if id_cell else None) or {}
        if "max_returnable" not in meta or meta["max_returnable"] is None:
            try:
                meta["max_returnable"] = float(self.tbl.item(r, self.COL_MAX_RETURNABLE).text() or "0")
            except Exception:
                meta["max_returnable"] = 0.0
        return meta

    def _recalc_row(self, r: int):
        q_item = self.tbl.item(r, self.COL_QTY_RETURN)
        try:
            qty_ret = float(q_item.text() or "0")
        except Exception:
            qty_ret = 0.0
        meta = self._meta_for_row(r)
        max_ret = float(meta.get("max_returnable") or 0.0)
        net_unit = float(meta.get("net_unit") or 0.0)

        bad = qty_ret < 0 or qty_ret > max_ret + 1e-9
        try:
            from PySide6.QtGui import QBrush
            q_item.setBackground(QBrush(Qt.red if bad else Qt.white))
        except Exception:
            q_item.setBackground(Qt.red if bad else Qt.white)

        it_val = self.tbl.item(r, self.COL_LINE_VALUE)
        it_val.setText(fmt_money(max(0.0, qty_ret * net_unit)))

    def _recalc_all(self):
        for r in range(self.tbl.rowCount()):
            self._recalc_row(r)
        self._refresh_totals()
        self._validate()

    def _refresh_totals(self):
        qty_total = 0.0
        val_total = 0.0
        for r in range(self.tbl.rowCount()):
            it = self.tbl.item(r, self.COL_QTY_RETURN)
            try:
                q = float(it.text() or "0")
            except Exception:
                q = 0.0
            meta = self._meta_for_row(r)
            qty_total += q
            val_total += max(0.0, q * float(meta.get("net_unit") or 0.0))
        self.lab_qty_total.setText(f"{qty_total:g}")
        self.lab_val_total.setText(f"Total Return Value: {fmt_money(val_total)}")

    # ---------- settlement ----------
    def _toggle_mode(self):
        is_refund = (self.cmb_mode.currentText() == "Refund Now")
        self.ref_panel.setVisible(is_refund)
        if is_refund:
            self.date_instr.setDate(self.date.date())
        self._validate()

    def _default_instrument_date(self):
        if self.cmb_mode.currentText() == "Refund Now":
            self.date_instr.setDate(self.date.date())

    def _current_settlement_mode(self) -> str:
        t = (self.cmb_mode.currentText() or "").strip().lower()
        if "credit" in t:
            return "credit_note"
        if "refund" in t:
            return "refund_now"
        return "credit_note"

    # ---------- payload ----------
    def get_payload(self) -> dict | None:
        # Ensure any pending edits have been processed and totals are up to date
        try:
            from PySide6.QtWidgets import QApplication
            QApplication.processEvents()
        except Exception:
            pass
        # Recalculate to keep totals/validation in sync even if edits were programmatic
        self._recalc_all()

        if not hasattr(self, "tbl"):
            return None

        items = []
        for r in range(self.tbl.rowCount()):
            id_cell = self.tbl.item(r, self.COL_ITEM_ID)
            try:
                item_id = int(id_cell.text())
            except Exception:
                item_id = id_cell.data(Qt.UserRole) if id_cell else -1
            if item_id is None:
                item_id = -1

            qty_it = self.tbl.item(r, self.COL_QTY_RETURN)
            try:
                return_qty = float((qty_it.text() or "0").strip()) if qty_it else 0.0
            except Exception:
                return_qty = 0.0

            if return_qty < 0:
                return None
            if return_qty == 0:
                continue

            meta = self._meta_for_row(r)
            max_ret = float(meta.get("max_returnable") or 0.0)
            if return_qty > max_ret + 1e-9:
                return None

            purchase_price = float(meta.get("purchase_price") or 0.0)
            item_discount = float(meta.get("item_discount") or 0.0)
            if purchase_price < 0 or item_discount < 0:
                return None
            if (purchase_price - item_discount) < -1e-9:
                return None

            items.append({
                "item_id": int(item_id),
                "return_qty": return_qty,
                "purchase_price": purchase_price,
                "item_discount": item_discount,
            })

        if not items:
            return None

        date_str = self.date.date().toString("yyyy-MM-dd")
        mode = self._current_settlement_mode()

        if mode == "credit_note":
            settlement = {"mode": "credit_note"}
        else:
            method_txt = (self.cmb_method.currentText() or "Bank Transfer").strip()
            bank_id = self.cmb_company_acct.currentData() if self.cmb_company_acct.count() else None
            vendor_bank_id = self.cmb_vendor_acct.currentData() if self.cmb_vendor_acct.count() else None
            instr_no = (self.txt_instr_no.text() or "AUTO-REF").strip()

            m = method_txt.lower()
            if "transfer" in m:
                instr_type = "online"
            elif "cheque" in m:
                instr_type = "cross_cheque"
            else:
                instr_type = "cash_deposit_slip"

            settlement = {
                "mode": "refund_now",
                "method": method_txt,
                "bank_account_id": bank_id,
                "vendor_bank_account_id": vendor_bank_id,
                "instrument_type": instr_type,
                "instrument_no": instr_no,
                "clearing_state": self._clearing_state_fixed,
                "date": date_str,
            }

        # Controller expects `lines`; keep `items` for backward compatibility in case other callers rely on it
        payload = {
            "date": date_str,
            "lines": [
                {
                    "item_id": i["item_id"],
                    "qty_return": i["return_qty"],
                    "purchase_price": i["purchase_price"],
                    "item_discount": i["item_discount"],
                }
                for i in items
            ],
            "items": items,
            "settlement": settlement,
            "notes": (self.notes.text().strip() or None),
        }
        return payload

    def accept(self):
        p = self.get_payload()
        if p is None:
            return
        self._payload = p
        super().accept()

    def payload(self):
        return self._payload

    # ---------- validation / OK gating ----------
    def _validate(self):
        ok = True
        any_line = False
        for r in range(self.tbl.rowCount()):
            it_qty = self.tbl.item(r, self.COL_QTY_RETURN)
            if not it_qty:
                continue
            try:
                q = float(it_qty.text() or 0.0)
            except Exception:
                q = 0.0
            meta = self._meta_for_row(r)
            max_ret = float(meta.get("max_returnable") or 0.0)
            if q > 0:
                any_line = True
            if q < 0 or q > max_ret + 1e-9:
                ok = False
                break

        if not any_line:
            ok = False

        if ok and self.cmb_mode.currentText() == "Refund Now":
            total_val = 0.0
            for r in range(self.tbl.rowCount()):
                it_qty = self.tbl.item(r, self.COL_QTY_RETURN)
                if not it_qty:
                    continue
                try:
                    q = float(it_qty.text() or 0.0)
                except Exception:
                    q = 0.0
                meta = self._meta_for_row(r)
                total_val += max(0.0, q * float(meta.get("net_unit") or 0.0))
            if total_val <= 0.0:
                ok = False
            if self.cmb_company_acct.currentIndex() < 0:
                ok = False
            if not (self.txt_instr_no.text().strip()):
                ok = False

        btn_ok = self.buttons.button(QDialogButtonBox.Ok)
        if btn_ok:
            btn_ok.setEnabled(bool(ok))

```

inventory_management/modules/purchase/controller.py
```
from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Qt, QSortFilterProxyModel, QRegularExpression
import sqlite3, datetime
from typing import Optional

from ..base_module import BaseModule
from .view import PurchaseView
from .model import PurchasesTableModel
from .form import PurchaseForm
from .return_form import PurchaseReturnForm
from .payments import PurchasePaymentDialog
from ...database.repositories.purchases_repo import PurchasesRepo, PurchaseHeader, PurchaseItem
from ...database.repositories.vendors_repo import VendorsRepo
from ...database.repositories.products_repo import ProductsRepo
from ...database.repositories.purchase_payments_repo import PurchasePaymentsRepo
from ...database.repositories.vendor_advances_repo import VendorAdvancesRepo
from ...utils.ui_helpers import info
from ...utils.helpers import today_str


def new_purchase_id(conn: sqlite3.Connection, date_str: str) -> str:
    # prefix by selected business date
    d = date_str.replace("-", "")
    prefix = f"PO{d}-"
    row = conn.execute("SELECT MAX(purchase_id) AS m FROM purchases WHERE purchase_id LIKE ?", (prefix + "%",)).fetchone()
    if row and row["m"]:
        try:
            last = int(row["m"].split("-")[-1])
        except Exception:
            last = 0
    else:
        last = 0
    return f"{prefix}{last+1:04d}"


class PurchaseController(BaseModule):
    def __init__(self, conn: sqlite3.Connection, current_user: dict | None):
        self.conn = conn
        self.user = current_user
        self.view = PurchaseView()
        self.repo = PurchasesRepo(conn)
        self.payments = PurchasePaymentsRepo(conn)
        self.vadv = VendorAdvancesRepo(conn)
        self.vendors = VendorsRepo(conn)
        self.products = ProductsRepo(conn)
        self._wire()
        self._reload()

    def get_widget(self) -> QWidget:
        return self.view

    def _wire(self):
        self.view.btn_add.clicked.connect(self._add)
        self.view.btn_edit.clicked.connect(self._edit)
        # self.view.btn_del.clicked.connect(self._delete)
        self.view.btn_return.clicked.connect(self._return)
        self.view.btn_pay.clicked.connect(self._payment)
        self.view.search.textChanged.connect(self._apply_filter)

    def _build_model(self):
        rows = self.repo.list_purchases()
        self.base = PurchasesTableModel(rows)
        self.proxy = QSortFilterProxyModel(self.view)
        self.proxy.setSourceModel(self.base)
        self.proxy.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.proxy.setFilterKeyColumn(-1)
        self.view.tbl.setModel(self.proxy)
        self.view.tbl.resizeColumnsToContents()
        sel = self.view.tbl.selectionModel()
        try:
            sel.selectionChanged.disconnect(self._sync_details)
        except (TypeError, RuntimeError):
            pass
        sel.selectionChanged.connect(self._sync_details)

    def _reload(self):
        self._build_model()
        if self.proxy.rowCount() > 0:
            self.view.tbl.selectRow(0)
        else:
            self.view.details.set_data(None)
            self.view.items.set_rows([])

    def _apply_filter(self, text: str):
        self.proxy.setFilterRegularExpression(QRegularExpression(text))

    def _selected_row_dict(self) -> dict | None:
        idxs = self.view.tbl.selectionModel().selectedRows()
        if not idxs:
            return None
        src = self.proxy.mapToSource(idxs[0])
        return self.base.at(src.row())

    def _sync_details(self, *args):
        row = self._selected_row_dict()
        self.view.details.set_data(row)
        if row:
            self.view.items.set_rows(self.repo.list_items(row["purchase_id"]))
        else:
            self.view.items.set_rows([])

    # --- helper: returnable qty per item_id for a purchase ---
    def _returnable_map(self, purchase_id: str) -> dict[int, float]:
        sql = """
        SELECT
          pi.item_id,
          CAST(pi.quantity AS REAL) -
          COALESCE((
            SELECT SUM(CAST(it.quantity AS REAL))
            FROM inventory_transactions it
            WHERE it.transaction_type='purchase_return'
              AND it.reference_table='purchases'
              AND it.reference_id = pi.purchase_id
              AND it.reference_item_id = pi.item_id
          ), 0.0) AS returnable
        FROM purchase_items pi
        WHERE pi.purchase_id=?
        """
        rows = self.conn.execute(sql, (purchase_id,)).fetchall()
        return {int(r["item_id"]): float(r["returnable"]) for r in rows}

    # --- helper: fetch a payment and ensure it belongs to selected purchase ---
    def _get_payment(self, payment_id: int) -> Optional[dict]:
        row = self._selected_row_dict()
        if not row:
            return None
        sql = """
        SELECT *
        FROM purchase_payments
        WHERE payment_id=? AND purchase_id=?
        """
        r = self.conn.execute(sql, (payment_id, row["purchase_id"])).fetchone()
        # Normalize to plain dict so downstream code can safely use .get(...)
        return dict(r) if r is not None else None

    # --- helper: financials for purchase (for open-purchases adapter) ---
    def _fetch_purchase_financials(self, purchase_id: str) -> dict:
        """
        Returns: total_amount, paid_amount, advance_payment_applied, calculated_total_amount, remaining_due
        remaining_due = calculated_total_amount - paid_amount - advance_payment_applied (clamped ≥ 0)
        """
        row = self.conn.execute(
            """
            SELECT
              p.total_amount,
              COALESCE(p.paid_amount, 0.0)              AS paid_amount,
              COALESCE(p.advance_payment_applied, 0.0)  AS advance_payment_applied,
              COALESCE(pdt.calculated_total_amount, p.total_amount) AS calculated_total_amount
            FROM purchases p
            LEFT JOIN purchase_detailed_totals pdt ON pdt.purchase_id = p.purchase_id
            WHERE p.purchase_id = ?;
            """,
            (purchase_id,),
        ).fetchone()
        if not row:
            return {
                "total_amount": 0.0,
                "paid_amount": 0.0,
                "advance_payment_applied": 0.0,
                "calculated_total_amount": 0.0,
                "remaining_due": 0.0,
            }
        calc = float(row["calculated_total_amount"] or 0.0)
        paid = float(row["paid_amount"] or 0.0)
        adv = float(row["advance_payment_applied"] or 0.0)
        rem = max(0.0, calc - paid - adv)
        return {
            "total_amount": float(row["total_amount"] or 0.0),
            "paid_amount": paid,
            "advance_payment_applied": adv,
            "calculated_total_amount": calc,
            "remaining_due": rem,
        }

    # -------- CRUD --------
    def _add(self):
        dlg = PurchaseForm(self.view, vendors=self.vendors, products=self.products)
        if not dlg.exec():
            return
        p = dlg.payload()
        if not p:
            return

        pid = new_purchase_id(self.conn, p["date"])

        # Build header (totals will be recalculated inside repo.create_purchase; payment fields are enforced to unpaid/0)
        h = PurchaseHeader(
            purchase_id=pid,
            vendor_id=p["vendor_id"],
            date=p["date"],
            total_amount=p.get("total_amount", 0.0),
            order_discount=p.get("order_discount", 0.0),
            payment_status="unpaid",
            paid_amount=0.0,
            advance_payment_applied=0.0,
            notes=p.get("notes"),
            created_by=(self.user["user_id"] if self.user else None),
        )
        items = [
            PurchaseItem(
                None,
                pid,
                it["product_id"],
                it["quantity"],
                it["uom_id"],
                it["purchase_price"],
                it["sale_price"],
                it["item_discount"],
            )
            for it in p["items"]
        ]

        # 1) Create purchase (header + items + inventory with sequential txn_seq)
        self.repo.create_purchase(h, items)

        # 2) Optional initial payment
        #    Prefer the new nested contract if present; fall back to legacy flat fields for backward compatibility.
        ip = p.get("initial_payment")
        if isinstance(ip, dict) and float(ip.get("amount") or 0.0) > 0:
            try:
                self.payments.record_payment(
                    purchase_id=pid,
                    amount=float(ip["amount"]),
                    method=ip["method"],
                    bank_account_id=ip.get("bank_account_id"),
                    vendor_bank_account_id=ip.get("vendor_bank_account_id"),
                    instrument_type=ip.get("instrument_type"),
                    instrument_no=ip.get("instrument_no"),
                    instrument_date=ip.get("instrument_date"),
                    deposited_date=ip.get("deposited_date"),
                    cleared_date=ip.get("cleared_date"),
                    clearing_state=ip.get("clearing_state"),
                    ref_no=ip.get("ref_no"),
                    notes=ip.get("notes"),
                    date=ip.get("date") or p["date"],
                    created_by=(self.user["user_id"] if self.user else None),
                )
            except sqlite3.IntegrityError as e:
                info(
                    self.view,
                    "Payment not recorded",
                    f"Purchase {pid} was created, but the initial payment could not be saved:\n{e}",
                )
            except sqlite3.OperationalError as e:
                info(
                    self.view,
                    "Payment not recorded",
                    f"Purchase {pid} was created, but the initial payment hit a database error:\n{e}",
                )
        else:
            # Legacy flat fields path (kept to avoid breaking older forms/controllers)
            initial_paid = float(p.get("initial_payment") or 0.0)
            if initial_paid > 0:
                method = p.get("initial_method") or "Cash"
                bank_account_id = p.get("initial_bank_account_id")
                vendor_bank_account_id = p.get("initial_vendor_bank_account_id")

                instrument_type = p.get("initial_instrument_type")
                if not instrument_type:
                    if method == "Bank Transfer":
                        instrument_type = "online"
                    elif method == "Cheque":
                        instrument_type = "cross_cheque"
                    elif method == "Cash Deposit":
                        instrument_type = "cash_deposit"
                    else:
                        instrument_type = None

                instrument_no = p.get("initial_instrument_no")
                instrument_date = p.get("initial_instrument_date")
                deposited_date = p.get("initial_deposited_date")
                cleared_date = p.get("initial_cleared_date")
                clearing_state = p.get("initial_clearing_state")
                ref_no = p.get("initial_ref_no")
                pay_notes = p.get("initial_payment_notes")

                try:
                    self.payments.record_payment(
                        purchase_id=pid,
                        amount=initial_paid,
                        method=method,
                        bank_account_id=bank_account_id,
                        vendor_bank_account_id=vendor_bank_account_id if method in ("Bank Transfer", "Cheque", "Cash Deposit") else None,
                        instrument_type=instrument_type,
                        instrument_no=instrument_no,
                        instrument_date=instrument_date,
                        deposited_date=deposited_date,
                        cleared_date=cleared_date,
                        clearing_state=clearing_state,
                        ref_no=ref_no,
                        notes=pay_notes,
                        date=p["date"],
                        created_by=(self.user["user_id"] if self.user else None),
                    )
                except sqlite3.IntegrityError as e:
                    info(
                        self.view,
                        "Payment not recorded",
                        f"Purchase {pid} was created, but the initial payment could not be saved:\n{e}",
                    )
                except sqlite3.OperationalError as e:
                    info(
                        self.view,
                        "Payment not recorded",
                        f"Purchase {pid} was created, but the initial payment hit a database error:\n{e}",
                    )

        # 3) Optional initial vendor credit application
        init_credit = float(p.get("initial_credit_amount") or 0.0)
        if init_credit > 0:
            try:
                self.vadv.apply_credit_to_purchase(
                    vendor_id=p["vendor_id"],
                    purchase_id=pid,
                    amount=init_credit,
                    date=p["date"],
                    notes=p.get("initial_credit_notes"),
                    created_by=(self.user["user_id"] if self.user else None),
                )
            except sqlite3.IntegrityError as e:
                info(self.view, "Credit not applied", f"Purchase {pid} was created, but vendor credit could not be applied:\n{e}")
            except sqlite3.OperationalError as e:
                info(self.view, "Credit not applied", f"Purchase {pid} was created, but a database error occurred while applying credit:\n{e}")

        info(self.view, "Saved", f"Purchase {pid} created.")
        self._reload()

    def _edit(self):
        row = self._selected_row_dict()
        if not row:
            info(self.view, "Select", "Select a purchase to edit.")
            return
        # existing items + header
        items = self.repo.list_items(row["purchase_id"])
        init = {
            "vendor_id": row["vendor_id"],
            "date": row["date"],
            "order_discount": row["order_discount"],
            "notes": row.get("notes"),
            "items": [
                {
                    "product_id": it["product_id"],
                    "uom_id": it["uom_id"],
                    "quantity": it["quantity"],
                    "purchase_price": it["purchase_price"],
                    "sale_price": it["sale_price"],
                    "item_discount": it["item_discount"],
                }
                for it in items
            ],
        }
        dlg = PurchaseForm(self.view, vendors=self.vendors, products=self.products, initial=init)
        if not dlg.exec():
            return
        p = dlg.payload()
        if not p:
            return
        pid = row["purchase_id"]
        h = PurchaseHeader(
            purchase_id=pid,
            vendor_id=p["vendor_id"],
            date=p["date"],
            total_amount=p["total_amount"],
            order_discount=p["order_discount"],
            payment_status=row["payment_status"],
            paid_amount=row["paid_amount"],
            advance_payment_applied=row["advance_payment_applied"],
            notes=p["notes"],
            created_by=(self.user["user_id"] if self.user else None),
        )
        items = [
            PurchaseItem(
                None,
                pid,
                it["product_id"],
                it["quantity"],
                it["uom_id"],
                it["purchase_price"],
                it["sale_price"],
                it["item_discount"],
            )
            for it in p["items"]
        ]
        self.repo.update_purchase(h, items)
        info(self.view, "Saved", f"Purchase {pid} updated.")
        self._reload()

    def _delete(self):
        row = self._selected_row_dict()
        if not row:
            info(self.view, "Select", "Select a purchase to delete.")
            return
        self.repo.delete_purchase(row["purchase_id"])
        info(self.view, "Deleted", f'Purchase {row["purchase_id"]} removed.')
        self._reload()

    # -------- Returns --------
    def _return(self):
        row = self._selected_row_dict()
        if not row:
            info(self.view, "Select", "Select a purchase to return items from.")
            return

        pid = row["purchase_id"]
        items = self.repo.list_items(pid)

        # Compute returnable map and attach to rows (form can show/validate)
        returnable = self._returnable_map(pid)
        items_for_form = []
        for it in items:
            it2 = dict(it)
            it2["returnable"] = float(returnable.get(it["item_id"], 0.0))
            items_for_form.append(it2)

        dlg = PurchaseReturnForm(self.view, items_for_form)
        if not dlg.exec():
            return
        payload = dlg.payload()
        if not payload:
            return

        # map lines to include product_id + uom_id from original items
        by_id = {it["item_id"]: it for it in items}
        lines = []
        for ln in payload["lines"]:
            it = by_id.get(ln["item_id"])
            if not it:
                continue
            lines.append(
                {
                    "item_id": it["item_id"],
                    "product_id": it["product_id"],
                    "uom_id": it["uom_id"],
                    "qty_return": float(ln["qty_return"]),
                }
            )

        # Pass settlement info (refund/credit_note + instrument meta) straight to repo
        settlement = payload.get("settlement")

        try:
            self.repo.record_return(
                pid=pid,
                date=payload["date"],
                created_by=(self.user["user_id"] if self.user else None),
                lines=lines,
                notes=payload.get("notes"),
                settlement=settlement,
            )
        except (ValueError, sqlite3.IntegrityError, sqlite3.OperationalError) as e:
            info(self.view, "Return not recorded", f"Could not record return:\n{e}")
            return

        info(self.view, "Saved", "Return recorded.")
        self._reload()

    # -------- Vendor credit action (UI can wire this later) --------
    def apply_vendor_credit(self, *, amount: float, date: Optional[str] = None, notes: Optional[str] = None):
        """
        Apply existing vendor credit to the selected purchase.
        - Positive `amount` is required.
        - Does NOT touch header money fields; DB triggers roll up advance_payment_applied.

        Intended to be called from a future UI action (e.g. a button/menu).
        """
        row = self._selected_row_dict()
        if not row:
            info(self.view, "Select", "Select a purchase to apply vendor credit.")
            return

        try:
            amt = float(amount)
        except (TypeError, ValueError):
            info(self.view, "Invalid amount", "Enter a valid positive amount to apply as credit.")
            return

        if amt <= 0:
            info(self.view, "Invalid amount", "Amount must be greater than zero.")
            return

        when = date or today_str()
        try:
            self.vadv.apply_credit_to_purchase(
                vendor_id=int(row["vendor_id"]),
                purchase_id=row["purchase_id"],
                amount=amt,
                date=when,
                notes=notes,
                created_by=(self.user["user_id"] if self.user else None),
            )
        except sqlite3.IntegrityError as e:
            # Likely insufficient credit (trigger trg_vendor_advances_no_overdraw)
            info(self.view, "Credit not applied", f"Could not apply vendor credit:\n{e}")
            return
        except sqlite3.OperationalError as e:
            info(self.view, "Credit not applied", f"A database error occurred:\n{e}")
            return

        info(self.view, "Saved", f"Applied vendor credit of {amt:g} to {row['purchase_id']}.")
        self._reload()

    # -------- Payments (UPDATED to use Vendor money dialog) --------
    def _payment(self):
        """
        Record a payment (or refund) using PurchasePaymentsRepo.

        Preferred: open the vendor money dialog (mode="payment") and forward its payload to the repo.
        Fallback: keep the legacy amount-only dialog to avoid breaking existing flows.
        """
        row = self._selected_row_dict()
        if not row:
            info(self.view, "Select", "Select a purchase to record payment.")
            return

        purchase_id = str(row["purchase_id"])
        vendor_id = int(row.get("vendor_id") or 0)
        vendor_display = str(row.get("vendor_name") or vendor_id)

        # --- Preferred path: new vendor money dialog (lazy import) ---
        try:
            from ...vendor.payment_dialog import open_vendor_money_form  # type: ignore

            payload = open_vendor_money_form(
                mode="payment",
                vendor_id=vendor_id,
                purchase_id=purchase_id,  # allow the dialog to pick if you pass None
                defaults={
                    "list_company_bank_accounts": self._list_company_bank_accounts,
                    "list_vendor_bank_accounts": self._list_vendor_bank_accounts,
                    "list_open_purchases_for_vendor": self._list_open_purchases_for_vendor,
                    "vendor_display": vendor_display,
                },
            )
            if payload:
                try:
                    self.payments.record_payment(
                        purchase_id=str(payload.get("purchase_id") or purchase_id),
                        amount=float(payload.get("amount")),
                        method=payload.get("method"),
                        bank_account_id=payload.get("bank_account_id"),
                        vendor_bank_account_id=payload.get("vendor_bank_account_id"),
                        instrument_type=payload.get("instrument_type"),
                        instrument_no=payload.get("instrument_no"),
                        instrument_date=payload.get("instrument_date"),
                        deposited_date=payload.get("deposited_date"),
                        cleared_date=payload.get("cleared_date"),
                        clearing_state=payload.get("clearing_state"),
                        ref_no=payload.get("ref_no"),
                        notes=payload.get("notes"),
                        date=payload.get("date") or today_str(),
                        created_by=(self.user["user_id"] if self.user else None),
                    )
                except (TypeError, ValueError):
                    info(self.view, "Payment not recorded", "Incomplete form data returned from Vendor dialog.")
                    return
                except (sqlite3.IntegrityError, sqlite3.OperationalError) as e:
                    info(self.view, "Payment not recorded", f"Could not record payment:\n{e}")
                    return

                info(self.view, "Saved", "Payment recorded.")
                self._reload()
                return
        except Exception:
            # Fall through to legacy path
            pass

        # --- Fallback: legacy amount-only dialog (kept for compatibility) ---
        dlg = PurchasePaymentDialog(
            self.view,
            current_paid=float(row["paid_amount"]),
            total=float(row["total_amount"]),
        )
        if not dlg.exec():
            return
        amount = dlg.payload()
        if not amount:
            return

        # Legacy path always used Cash / posted; keep that behavior unchanged.
        method = "Cash"
        bank_account_id = None
        vendor_bank_account_id = None
        instrument_type = None
        instrument_no = None
        instrument_date = None
        deposited_date = None
        cleared_date = None
        clearing_state = None
        ref_no = None
        notes = None
        pay_date = today_str()

        try:
            self.payments.record_payment(
                purchase_id=purchase_id,
                amount=float(amount),
                method=method,
                bank_account_id=bank_account_id,
                vendor_bank_account_id=vendor_bank_account_id,
                instrument_type=instrument_type,
                instrument_no=instrument_no,
                instrument_date=instrument_date,
                deposited_date=deposited_date,
                cleared_date=cleared_date,
                clearing_state=clearing_state,
                ref_no=ref_no,
                notes=notes,
                date=pay_date,
                created_by=(self.user["user_id"] if self.user else None),
            )
        except (sqlite3.IntegrityError, sqlite3.OperationalError) as e:
            info(self.view, "Payment not recorded", f"Could not record payment:\n{e}")
            return

        info(self.view, "Saved", f"Transaction of {float(amount):g} recorded.")
        self._reload()

    # -------- Clearing endpoints (pending → cleared / bounced) --------
    def mark_payment_cleared(self, payment_id: int, *, cleared_date: Optional[str] = None, notes: Optional[str] = None):
        """
        Mark a pending payment as CLEARED.
        - Requires the payment to belong to the currently selected purchase.
        - Sets cleared_date to today if not provided.
        """
        pay = self._get_payment(payment_id)
        if not pay:
            info(self.view, "Not found", "Select a purchase and a valid payment to clear.")
            return
        if (pay.get("clearing_state") or "posted") != "pending":
            info(self.view, "Not allowed", "Only pending payments can be marked as cleared.")
            return

        when = cleared_date or today_str()
        try:
            changed = self.payments.update_clearing_state(
                payment_id=payment_id,
                clearing_state="cleared",
                cleared_date=when,
                notes=notes,
            )
            if not changed:
                info(self.view, "No change", "Payment was not updated.")
                return
        except (sqlite3.IntegrityError, sqlite3.OperationalError) as e:
            info(self.view, "Update failed", f"Could not mark payment cleared:\n{e}")
            return

        info(self.view, "Saved", f"Payment #{payment_id} marked as cleared.")
        self._reload()

    def mark_payment_bounced(self, payment_id: int, *, notes: Optional[str] = None):
        """
        Mark a pending payment as BOUNCED.
        - Requires the payment to belong to the currently selected purchase.
        - Does not set cleared_date.
        """
        pay = self._get_payment(payment_id)
        if not pay:
            info(self.view, "Not found", "Select a purchase and a valid payment to mark bounced.")
            return
        if (pay.get("clearing_state") or "posted") != "pending":
            info(self.view, "Not allowed", "Only pending payments can be marked as bounced.")
            return

        try:
            changed = self.payments.update_clearing_state(
                payment_id=payment_id,
                clearing_state="bounced",
                cleared_date=None,
                notes=notes,
            )
            if not changed:
                info(self.view, "No change", "Payment was not updated.")
                return
        except (sqlite3.IntegrityError, sqlite3.OperationalError) as e:
            info(self.view, "Update failed", f"Could not mark payment bounced:\n{e}")
            return

        info(self.view, "Saved", f"Payment #{payment_id} marked as bounced.")
        self._reload()

    # -------- Adapters for Vendor dialog defaults (lazy, safe) --------
    def _list_company_bank_accounts(self) -> list[dict]:
        """
        Returns [{id, name}] for company bank accounts.
        Lazy-imports a bank accounts repo if present. Safe empty list on failure.
        """
        try:
            from ...database.repositories.bank_accounts_repo import BankAccountsRepo  # type: ignore
            repo = BankAccountsRepo(self.conn)
            # Try common method names
            for attr in ("list_accounts", "list", "list_all", "all"):
                if hasattr(repo, attr):
                    rows = list(getattr(repo, attr)())
                    out = []
                    for r in rows:
                        d = dict(r)
                        _id = d.get("id") or d.get("account_id") or d.get("bank_account_id")
                        _name = d.get("name") or d.get("account_name") or d.get("title")
                        if _id is not None and _name is not None:
                            out.append({"id": int(_id), "name": str(_name)})
                    if out:
                        return out
        except Exception:
            pass
        return []

    def _list_vendor_bank_accounts(self, vendor_id: int) -> list[dict]:
        """
        Returns [{id, name}] for a vendor's bank accounts (if your app supports it).
        Safe empty list on failure or if repo not present.
        """
        try:
            from ...database.repositories.vendor_bank_accounts_repo import VendorBankAccountsRepo  # type: ignore
            repo = VendorBankAccountsRepo(self.conn)
            rows = []
            for attr in ("list_by_vendor", "list_for_vendor", "list"):
                if hasattr(repo, attr):
                    try:
                        rows = list(getattr(repo, attr)(vendor_id))
                    except TypeError:
                        # some repos use keyword arg
                        try:
                            rows = list(getattr(repo, attr)(vendor_id=vendor_id))
                        except Exception:
                            rows = []
                    break
            out = []
            for r in rows:
                d = dict(r)
                _id = d.get("id") or d.get("vendor_bank_account_id") or d.get("account_id")
                _name = d.get("name") or d.get("account_name") or d.get("title") or d.get("iban") or d.get("account_no")
                if _id is not None and _name is not None:
                    out.append({"id": int(_id), "name": str(_name)})
            return out
        except Exception:
            return []

    def _list_open_purchases_for_vendor(self, vendor_id: int) -> list[dict]:
        """
        Returns a list of open purchases for a vendor with remaining due > 0.
        Shape: {purchase_id, date, total, paid, remaining_due}
        """
        out: list[dict] = []
        try:
            cur = self.conn.execute(
                "SELECT purchase_id, date, total_amount AS total, COALESCE(paid_amount,0) AS paid, COALESCE(advance_payment_applied,0) AS adv "
                "FROM purchases WHERE vendor_id = ? ORDER BY date DESC, purchase_id DESC LIMIT 300;",
                (vendor_id,),
            )
            for row in cur.fetchall():
                pid = str(row["purchase_id"])
                fin = self._fetch_purchase_financials(pid)
                if fin["remaining_due"] > 1e-9:
                    out.append(
                        {
                            "purchase_id": pid,
                            "date": str(row["date"]),
                            "total": float(fin["calculated_total_amount"]),
                            "paid": float(fin["paid_amount"]),
                            "remaining_due": float(fin["remaining_due"]),
                        }
                    )
        except Exception:
            return []
        return out

```

inventory_management/modules/purchase/view.py
```
from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit, QLabel, QSplitter
from PySide6.QtCore import Qt
from ...widgets.table_view import TableView
from .details import PurchaseDetails
from .items import PurchaseItemsView

class PurchaseView(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        root = QVBoxLayout(self)

        # actions + search
        row = QHBoxLayout()
        self.btn_add = QPushButton("New")
        self.btn_edit = QPushButton("Edit")
        # self.btn_del = QPushButton("Delete")
        self.btn_return = QPushButton("Return")
        self.btn_pay = QPushButton("Payment")
        row.addWidget(self.btn_add); row.addWidget(self.btn_edit)#; row.addWidget(self.btn_del)
        row.addWidget(self.btn_return); row.addWidget(self.btn_pay)
        row.addStretch(1)
        self.search = QLineEdit(); self.search.setPlaceholderText("Search purchases (id, vendor, status)")
        row.addWidget(QLabel("Search:")); row.addWidget(self.search, 2)
        root.addLayout(row)

        split = QSplitter(Qt.Horizontal)
        left = QWidget(); from PySide6.QtWidgets import QVBoxLayout as V; l = V(left)
        self.tbl = TableView(); l.addWidget(self.tbl, 3)
        self.items = PurchaseItemsView(); l.addWidget(self.items, 2)
        split.addWidget(left)
        self.details = PurchaseDetails()
        split.addWidget(self.details)
        split.setStretchFactor(0, 3); split.setStretchFactor(1, 2)
        root.addWidget(split, 1)

```

inventory_management/modules/purchase/payments.py
```
from PySide6.QtWidgets import QDialog, QFormLayout, QDialogButtonBox, QLineEdit, QVBoxLayout, QLabel
from ...utils.validators import is_positive_number

class PurchasePaymentDialog(QDialog):
    def __init__(self, parent=None, current_paid: float = 0.0, total: float = 0.0):
        super().__init__(parent)
        self.setWindowTitle("Record Payment")
        self.amount = QLineEdit()
        self.amount.setPlaceholderText("Amount")
        self.lab_info = QLabel(f"Paid so far: {current_paid:g} / Total: {total:g}")

        lay = QVBoxLayout(self)
        form = QFormLayout()
        form.addRow("Amount*", self.amount)
        lay.addLayout(form)
        lay.addWidget(self.lab_info)

        self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        lay.addWidget(self.buttons)

        self._value = None

    def value(self) -> float | None:
        t = self.amount.text().strip()
        if not is_positive_number(t): return None
        return float(t)

    def accept(self):
        v = self.value()
        if v is None: return
        self._value = v
        super().accept()

    def payload(self): return self._value

```

inventory_management/modules/purchase/model.py
```
from PySide6.QtCore import QAbstractTableModel, Qt, QModelIndex
from ...utils.helpers import fmt_money

class PurchasesTableModel(QAbstractTableModel):
    HEADERS = ["ID", "Date", "Vendor", "Total", "Paid", "Status"]  # removed Notes
    def __init__(self, rows: list[dict]):
        super().__init__()
        self._rows = rows
    def rowCount(self, parent=QModelIndex()): return len(self._rows)
    def columnCount(self, parent=QModelIndex()): return len(self.HEADERS)
    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid(): return None
        r = self._rows[index.row()]
        if role in (Qt.DisplayRole, Qt.EditRole):
            c = index.column()
            mapping = [
                r["purchase_id"], r["date"], r["vendor_name"],
                fmt_money(r["total_amount"]), fmt_money(r["paid_amount"]),
                r["payment_status"]
            ]
            return mapping[c]
        return None
    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.HEADERS[section]
        return super().headerData(section, orientation, role)
    def at(self, row: int) -> dict:
        return self._rows[row]
    def replace(self, rows: list[dict]):
        self.beginResetModel()
        self._rows = rows
        self.endResetModel()

class PurchaseItemsModel(QAbstractTableModel):
    HEADERS = ["#", "Product", "Qty", "UoM", "Buy Price", "Sale Price", "Discount", "Line Total"]
    def __init__(self, rows: list[dict]):
        super().__init__()
        self._rows = rows
    def rowCount(self, parent=QModelIndex()): return len(self._rows)
    def columnCount(self, parent=QModelIndex()): return len(self.HEADERS)
    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid(): return None
        r = self._rows[index.row()]
        if role in (Qt.DisplayRole, Qt.EditRole):
            c = index.column()
            # Per-unit discount: line_total = qty * (purchase_price - item_discount)
            line_total = float(r["quantity"]) * (float(r["purchase_price"]) - float(r["item_discount"]))
            mapping = [
                r["item_id"], r["product_name"], f'{float(r["quantity"]):g}', r["unit_name"],
                fmt_money(r["purchase_price"]), fmt_money(r["sale_price"]),
                fmt_money(r["item_discount"]), fmt_money(line_total)
            ]
            return mapping[c]
        return None
    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.HEADERS[section]
        return super().headerData(section, orientation, role)
    def replace(self, rows: list[dict]):
        self.beginResetModel()
        self._rows = rows
        self.endResetModel()

```

inventory_management/modules/purchase/items.py
```
from PySide6.QtWidgets import QWidget, QVBoxLayout
from ...widgets.table_view import TableView
from .model import PurchaseItemsModel

class PurchaseItemsView(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.table = TableView()
        lay = QVBoxLayout(self)
        lay.addWidget(self.table, 1)
        self.model = PurchaseItemsModel([])
        self.table.setModel(self.model)

    def set_rows(self, rows: list[dict]):
        self.model.replace(rows)
        self.table.resizeColumnsToContents()

```

inventory_management/modules/purchase/details.py
```
from PySide6.QtWidgets import QWidget, QVBoxLayout, QGroupBox, QFormLayout, QLabel
from PySide6.QtCore import Qt
from ...utils.helpers import fmt_money

class PurchaseDetails(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        box = QGroupBox("Purchase Details")
        f = QFormLayout(box)
        self.lab_id = QLabel("-")
        self.lab_date = QLabel("-")
        self.lab_vendor = QLabel("-")
        self.lab_total = QLabel("-")
        self.lab_discount = QLabel("-")
        self.lab_paid = QLabel("-")
        self.lab_remain = QLabel("-")
        self.lab_status = QLabel("-")
        # Removed notes label as per update
        f.addRow("ID:", self.lab_id)
        f.addRow("Date:", self.lab_date)
        f.addRow("Vendor:", self.lab_vendor)
        f.addRow("Total:", self.lab_total)
        f.addRow("Order Discount:", self.lab_discount)
        f.addRow("Paid:", self.lab_paid)
        f.addRow("Remaining:", self.lab_remain)
        f.addRow("Status:", self.lab_status)
        # Removed notes row as per update
        root = QVBoxLayout(self)
        root.addWidget(box, 0)
        
    def set_data(self, row: dict | None):
        if not row:
            for w in (self.lab_id, self.lab_date, self.lab_vendor, self.lab_total,
                      self.lab_discount, self.lab_paid, self.lab_remain, self.lab_status):
                w.setText("-")
            return
            
        self.lab_id.setText(row["purchase_id"])
        self.lab_date.setText(row["date"])
        self.lab_vendor.setText(row["vendor_name"])
        self.lab_total.setText(fmt_money(row["total_amount"]))
        self.lab_discount.setText(f'{float(row["order_discount"]):g}')
        self.lab_paid.setText(fmt_money(row["paid_amount"]))
        remaining = float(row["total_amount"]) - float(row["paid_amount"])
        self.lab_remain.setText(fmt_money(remaining))
        self.lab_status.setText(row["payment_status"])
        # Notes are no longer displayed as per update
```

inventory_management/modules/purchase/return_credits.py
```

```

inventory_management/modules/purchase/return.py
```
from PySide6.QtWidgets import QDialog
# placeholder if you want a dedicated controller later; for now logic in PurchaseController

```

inventory_management/modules/vendor/form.py
```
from PySide6.QtWidgets import (
    QDialog, QFormLayout, QLineEdit, QPlainTextEdit, QDialogButtonBox, QVBoxLayout,
    QHBoxLayout, QPushButton, QLabel
)
from PySide6.QtCore import Signal
from ...utils.validators import non_empty


class VendorForm(QDialog):
    # emitted when user wants to manage bank accounts for this vendor
    manageBankAccounts = Signal(int)
    # emitted when user wants to grant credit to this vendor
    grantVendorCredit = Signal(int)

    def __init__(self, parent=None, initial: dict | None = None):
        super().__init__(parent)
        self.setWindowTitle("Vendor")
        self.setModal(True)

        # --- remember vendor_id (only present in edit mode) ---
        self._vendor_id = int(initial["vendor_id"]) if initial and initial.get("vendor_id") else None

        self.name = QLineEdit()
        self.contact = QPlainTextEdit()
        self.contact.setPlaceholderText("Phone, email, etc.")
        self.addr = QPlainTextEdit()
        self.addr.setPlaceholderText("Address (optional)")

        lay = QVBoxLayout(self)
        form = QFormLayout()
        form.addRow("Name*", self.name)
        form.addRow("Contact Info*", self.contact)
        form.addRow("Address", self.addr)
        lay.addLayout(form)

        # --- Small toolbar for operational actions (entry points) ---
        ops_bar = QHBoxLayout()
        ops_bar.addStretch(1)

        self.btn_manage_accounts = QPushButton("Manage Bank Accounts…")
        self.btn_grant_credit = QPushButton("Grant Credit…")

        # Disable when creating a new vendor (no id yet)
        enabled = self._vendor_id is not None
        self.btn_manage_accounts.setEnabled(enabled)
        self.btn_grant_credit.setEnabled(enabled)

        # Emit signals (controller will handle dialogs/DB work)
        self.btn_manage_accounts.clicked.connect(
            lambda: self.manageBankAccounts.emit(self._vendor_id)
        )
        self.btn_grant_credit.clicked.connect(
            lambda: self.grantVendorCredit.emit(self._vendor_id)
        )

        ops_bar.addWidget(self.btn_manage_accounts)
        ops_bar.addWidget(self.btn_grant_credit)
        lay.addLayout(ops_bar)

        # OK/Cancel buttons
        self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, parent=self)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        lay.addWidget(self.buttons)

        if initial:
            self.name.setText(initial.get("name", ""))
            self.contact.setPlainText(initial.get("contact_info", ""))
            self.addr.setPlainText(initial.get("address", "") or "")

        self._payload = None

    def set_vendor_id(self, vendor_id: int) -> None:
        """Enable operational actions once a vendor record exists (optional helper)."""
        self._vendor_id = int(vendor_id)
        self.btn_manage_accounts.setEnabled(True)
        self.btn_grant_credit.setEnabled(True)

    def get_payload(self) -> dict | None:
        if not non_empty(self.name.text()):
            self.name.setFocus(); return None
        if not non_empty(self.contact.toPlainText()):
            self.contact.setFocus(); return None
        return {
            "name": self.name.text().strip(),
            "contact_info": self.contact.toPlainText().strip(),
            "address": (self.addr.toPlainText().strip() or None)
        }

    def accept(self):
        p = self.get_payload()
        if p is None:
            return
        self._payload = p
        super().accept()

    def payload(self):
        return self._payload

```

inventory_management/modules/vendor/__init__.py
```

```

inventory_management/modules/vendor/controller.py
```
from PySide6.QtWidgets import QWidget, QDialog, QFormLayout, QDialogButtonBox, QLineEdit, QDateEdit, QVBoxLayout, QLabel, QComboBox
from PySide6.QtCore import Qt, QSortFilterProxyModel, QRegularExpression, QDate
import sqlite3
from typing import Optional, Any, Dict, List
from ..base_module import BaseModule
from .view import VendorView
from .form import VendorForm
from .model import VendorsTableModel
from ...database.repositories.vendors_repo import VendorsRepo
from ...database.repositories.vendor_advances_repo import VendorAdvancesRepo
from ...database.repositories.vendor_bank_accounts_repo import VendorBankAccountsRepo
from ...database.repositories.purchase_payments_repo import PurchasePaymentsRepo
from ...database.repositories.purchases_repo import PurchasesRepo
from ...utils import ui_helpers as uih
from ...utils.helpers import today_str

# Keep a module-level alias so tests that patch `vendor_controller.info`
# still capture messages, while calls ALSO go through `uih.info` so
# tests that patch `ui_helpers.info` work too.
def info(parent, title: str, text: str):
    return uih.info(parent, title, text)


class VendorController(BaseModule):
    def __init__(self, conn: sqlite3.Connection):
        self.conn = conn
        self.repo = VendorsRepo(conn)
        self.vadv = VendorAdvancesRepo(conn)
        self.vbank = VendorBankAccountsRepo(conn)  # <-- bank accounts repo
        self.ppay = PurchasePaymentsRepo(conn)     # payments repo for statement flow
        self.view = VendorView()
        self._wire()
        self._reload()

    def get_widget(self) -> QWidget:
        return self.view

    def _wire(self):
        self.view.btn_add.clicked.connect(self._add)
        self.view.btn_edit.clicked.connect(self._edit)
        # self.view.btn_del.clicked.connect(self._delete)
        self.view.search.textChanged.connect(self._apply_filter)

        # New money actions (guarded so we don't break older views)
        if hasattr(self.view, "btn_record_payment"):
            self.view.btn_record_payment.clicked.connect(self._on_record_payment)
        if hasattr(self.view, "btn_record_advance"):
            self.view.btn_record_advance.clicked.connect(self._on_record_advance_dialog)
        if hasattr(self.view, "btn_apply_advance"):
            self.view.btn_apply_advance.clicked.connect(self._on_apply_advance_dialog)
        if hasattr(self.view, "btn_update_clearing"):
            self.view.btn_update_clearing.clicked.connect(self._on_update_clearing)

        # Optional list buttons (if your view exposes them)
        if hasattr(self.view, "btn_list_vendor_payments"):
            self.view.btn_list_vendor_payments.clicked.connect(self._on_list_vendor_payments)
        if hasattr(self.view, "btn_list_purchase_payments"):
            self.view.btn_list_purchase_payments.clicked.connect(self._on_list_purchase_payments)
        if hasattr(self.view, "btn_list_pending_instruments"):
            self.view.btn_list_pending_instruments.clicked.connect(self._on_list_pending_instruments)

    def _build_model(self):
        rows = self.repo.list_vendors()
        self.base_model = VendorsTableModel(rows)
        self.proxy = QSortFilterProxyModel(self.view)
        self.proxy.setSourceModel(self.base_model)
        self.proxy.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.proxy.setFilterKeyColumn(-1)  # search across all columns
        self.view.table.setModel(self.proxy)
        self.view.table.resizeColumnsToContents()
        # IMPORTANT: selectionModel() is NEW after setModel; re-connect every time
        sel = self.view.table.selectionModel()
        try:
            sel.selectionChanged.disconnect(self._update_details)
        except (TypeError, RuntimeError):
            pass
        sel.selectionChanged.connect(self._update_details)

    def _reload(self):
        self._build_model()
        # auto-select first row so details populate immediately
        if self.proxy.rowCount() > 0:
            self.view.table.selectRow(0)
        else:
            self.view.details.clear()

    def _apply_filter(self, text: str):
        self.proxy.setFilterRegularExpression(QRegularExpression(text))

    def _selected_id(self) -> int | None:
        idxs = self.view.table.selectionModel().selectedRows()
        if not idxs:
            return None
        src = self.proxy.mapToSource(idxs[0])
        return self.base_model.at(src.row()).vendor_id

    def _current_vendor_row(self) -> dict | None:
        vid = self._selected_id()
        return self.repo.get(vid).__dict__ if vid else None

    def _update_details(self, *args):
        self.view.details.set_data(self._current_vendor_row())

    # ---------- Adapters used by dialogs (company bank, vendor bank, open purchases) ----------
    def _list_company_bank_accounts(self) -> List[Dict[str, Any]]:
        sql = """
        SELECT account_id AS id,
               COALESCE(label, bank_name || ' ' || account_no) AS name
        FROM company_bank_accounts
        WHERE is_active = 1
        ORDER BY name ASC;
        """
        try:
            rows = self.conn.execute(sql).fetchall()
            return [dict(r) for r in rows]
        except Exception:
            return []

    def _list_vendor_bank_accounts(self, vendor_id: int) -> List[Dict[str, Any]]:
        try:
            rows = self.vbank.list(vendor_id, active_only=True)
            out: List[Dict[str, Any]] = []
            for r in rows:
                out.append({
                    "id": int(r["vendor_bank_account_id"]),
                    "name": r.get("label") or (r.get("bank_name") or "") + " " + (r.get("account_no") or ""),
                })
            return out
        except Exception:
            return []

    def _open_purchases_for_vendor(self, vendor_id: int) -> list[dict]:
        """
        Returns purchases with positive remaining balance:
        balance = total_amount - paid_amount - advance_payment_applied
        """
        sql = """
        SELECT
            p.purchase_id,
            p.date,
            CAST(p.total_amount AS REAL)    AS total_amount,
            CAST(p.paid_amount AS REAL)     AS paid_amount,
            CAST(p.advance_payment_applied AS REAL) AS advance_payment_applied,
            (CAST(p.total_amount AS REAL) - CAST(p.paid_amount AS REAL) - CAST(p.advance_payment_applied AS REAL)) AS balance
        FROM purchases p
        WHERE p.vendor_id = ?
          AND (CAST(p.total_amount AS REAL) - CAST(p.paid_amount AS REAL) - CAST(p.advance_payment_applied AS REAL)) > 1e-9
        ORDER BY DATE(p.date) DESC, p.purchase_id DESC
        """
        return self.conn.execute(sql, (vendor_id,)).fetchall()

    def _list_open_purchases_for_vendor(self, vendor_id: int) -> List[Dict[str, Any]]:
        """
        Adapter for dialog: normalize keys to {purchase_id, doc_no, date, total, paid}
        """
        try:
            rows = self._open_purchases_for_vendor(vendor_id)
            out: List[Dict[str, Any]] = []
            for r in rows:
                total = float(r["total_amount"] or 0.0)
                paid = float(r["paid_amount"] or 0.0)
                out.append({
                    "purchase_id": r["purchase_id"],
                    "doc_no": r["purchase_id"],
                    "date": r["date"],
                    "total": total,
                    "paid": paid,
                })
            return out
        except Exception:
            return []

    # Public helper for UI to fetch open purchases of current vendor
    def list_open_purchases(self) -> list[dict]:
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return []
        return self._open_purchases_for_vendor(vid)

    # ---------- Helpers ----------
    def _purchase_belongs_to_vendor(self, purchase_id: str, vendor_id: int) -> bool:
        row = self.conn.execute(
            "SELECT vendor_id FROM purchases WHERE purchase_id=?;",
            (purchase_id,),
        ).fetchone()
        return bool(row) and int(row["vendor_id"]) == int(vendor_id)

    # ========================= Money actions (Dialogs + Repo) =========================

    def _on_record_payment(self):
        """
        Open vendor money dialog in 'payment' mode, then persist via PurchasePaymentsRepo.
        """
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return

        # Lazy import the new unified dialog
        try:
            from .payment_dialog import open_vendor_money_form  # type: ignore
        except Exception as e:
            info(self.view, "Unavailable", f"Vendor payment dialog is not available:\n{e}")
            return

        defaults = {
            "list_company_bank_accounts": self._list_company_bank_accounts,
            "list_vendor_bank_accounts": self._list_vendor_bank_accounts,
            "list_open_purchases_for_vendor": self._list_open_purchases_for_vendor,
            "today": today_str,
            "vendor_display": str(vid),
        }

        payload = open_vendor_money_form(
            mode="payment",
            vendor_id=vid,
            purchase_id=None,  # let user pick the purchase
            defaults=defaults,
        )
        if not payload:
            return

        purchase_id = payload.get("purchase_id")
        if not purchase_id:
            info(self.view, "Required", "Please select a purchase.")
            return

        if not self._purchase_belongs_to_vendor(purchase_id, vid):
            info(self.view, "Invalid", "Purchase does not belong to the selected vendor.")
            return

        try:
            pid = self.ppay.record_payment(
                purchase_id=str(purchase_id),
                amount=float(payload.get("amount", 0) or 0),
                method=str(payload.get("method") or ""),
                date=payload.get("date"),
                bank_account_id=payload.get("bank_account_id"),
                vendor_bank_account_id=payload.get("vendor_bank_account_id"),
                instrument_type=payload.get("instrument_type"),
                instrument_no=payload.get("instrument_no"),
                instrument_date=payload.get("instrument_date"),
                deposited_date=payload.get("deposited_date"),
                cleared_date=payload.get("cleared_date"),
                clearing_state=payload.get("clearing_state"),
                notes=payload.get("notes"),
                created_by=payload.get("created_by"),
            )
        except (ValueError, sqlite3.IntegrityError) as e:
            info(self.view, "Not saved", str(e))
            return

        info(self.view, "Saved", f"Payment #{pid} recorded.")
        self._reload()

    def _on_record_advance_dialog(self):
        """
        Open vendor money dialog in 'advance' mode, then persist via VendorAdvancesRepo.
        """
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return

        try:
            from .payment_dialog import open_vendor_money_form  # type: ignore
        except Exception as e:
            info(self.view, "Unavailable", f"Vendor money dialog is not available:\n{e}")
            return

        payload = open_vendor_money_form(
            mode="advance",
            vendor_id=vid,
            purchase_id=None,
            defaults={"vendor_display": str(vid), "today": today_str},
        )
        if not payload:
            return

        try:
            tx_id = self.vadv.grant_credit(
                vendor_id=vid,
                amount=float(payload.get("amount", 0) or 0),
                date=payload.get("date"),
                notes=payload.get("notes"),
                created_by=payload.get("created_by"),
                source_id=None,
            )
        except (ValueError, sqlite3.IntegrityError) as e:
            info(self.view, "Not saved", str(e))
            return

        info(self.view, "Saved", f"Advance #{tx_id} recorded.")
        self._reload()

    def _on_apply_advance_dialog(self):
        """
        Open vendor money dialog in 'apply_advance' mode, then persist via VendorAdvancesRepo.
        """
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return

        try:
            from .payment_dialog import open_vendor_money_form  # type: ignore
        except Exception as e:
            info(self.view, "Unavailable", f"Vendor money dialog is not available:\n{e}")
            return

        defaults = {
            "list_open_purchases_for_vendor": self._list_open_purchases_for_vendor,
            "today": today_str,
            "vendor_display": str(vid),
        }
        payload = open_vendor_money_form(
            mode="apply_advance",
            vendor_id=vid,
            purchase_id=None,
            defaults=defaults,
        )
        if not payload:
            return

        purchase_id = payload.get("purchase_id")
        amt = payload.get("amount")
        if not purchase_id or amt is None:
            info(self.view, "Required", "Please select a purchase and enter amount.")
            return

        if not self._purchase_belongs_to_vendor(purchase_id, vid):
            info(self.view, "Invalid", "Purchase does not belong to the selected vendor.")
            return

        try:
            tx_id = self.vadv.apply_credit_to_purchase(
                vendor_id=vid,
                purchase_id=str(purchase_id),
                amount=float(amt),
                date=payload.get("date"),
                notes=payload.get("notes"),
                created_by=payload.get("created_by"),
            )
        except (ValueError, sqlite3.IntegrityError) as e:
            info(self.view, "Not saved", str(e))
            return

        info(self.view, "Saved", f"Advance application #{tx_id} recorded.")
        self._reload()

    # ---------- Clearing state update ----------
    def _on_update_clearing(self):
        """
        Prompt for a payment_id, clearing_state, optional cleared_date & notes,
        and call PurchasePaymentsRepo.update_clearing_state(...).
        """
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return

        # Tiny inline prompt dialog to keep this file self-contained.
        class ClearingDialog(QDialog):
            def __init__(self, parent=None):
                super().__init__(parent)
                self.setWindowTitle("Update Clearing State")
                self._payload = None

                self.paymentId = QLineEdit()
                self.paymentId.setPlaceholderText("Payment ID (int)")
                self.stateCombo = QComboBox()
                self.stateCombo.addItems(["posted", "pending", "cleared", "bounced"])
                self.clearedDate = QDateEdit()
                self.clearedDate.setCalendarPopup(True)
                self.clearedDate.setDisplayFormat("yyyy-MM-dd")
                self.clearedDate.setDate(QDate.currentDate())
                self.notes = QLineEdit()
                self.notes.setPlaceholderText("Notes (optional)")

                form = QFormLayout()
                form.addRow("Payment ID*", self.paymentId)
                form.addRow("Clearing State*", self.stateCombo)
                form.addRow("Cleared Date", self.clearedDate)
                form.addRow("Notes", self.notes)

                btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
                btns.accepted.connect(self._on_ok)
                btns.rejected.connect(self.reject)

                lay = QVBoxLayout(self)
                lay.addLayout(form)
                lay.addWidget(btns)

            def _on_ok(self):
                pid_txt = self.paymentId.text().strip()
                if not pid_txt:
                    return
                try:
                    pid = int(pid_txt)
                except ValueError:
                    return
                state = self.stateCombo.currentText()
                date_str = self.clearedDate.date().toString("yyyy-MM-dd") if state == "cleared" else None
                self._payload = {
                    "payment_id": pid,
                    "clearing_state": state,
                    "cleared_date": date_str,
                    "notes": (self.notes.text().strip() or None),
                }
                self.accept()

            def payload(self):
                return self._payload

        dlg = ClearingDialog(self.view)
        if not dlg.exec():
            return
        data = dlg.payload()
        if not data:
            return

        try:
            updated = self.ppay.update_clearing_state(
                payment_id=int(data["payment_id"]),
                clearing_state=str(data["clearing_state"]),
                cleared_date=data.get("cleared_date"),
                notes=data.get("notes"),
            )
        except (ValueError, sqlite3.IntegrityError) as e:
            info(self.view, "Not updated", str(e))
            return

        if updated <= 0:
            info(self.view, "Not updated", "No payment updated.")
            return
        info(self.view, "Updated", "Payment clearing updated.")
        self._reload()

    # ---------- Lists / exports ----------
    def _on_list_vendor_payments(self):
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return
        # Minimal UX: just count/fetch; you can wire to a table dialog if you have one.
        rows = self.ppay.list_payments_for_vendor(vid, date_from=None, date_to=None)
        info(self.view, "Payments", f"Found {len(rows)} payment(s) for vendor.")

    def _on_list_purchase_payments(self):
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return
        # Tiny prompt for purchase id
        pid = self._prompt_text("Enter Purchase ID")
        if not pid:
            return
        rows = self.ppay.list_payments_for_purchase(pid)
        info(self.view, "Payments", f"Found {len(rows)} payment(s) for purchase {pid}.")

    def _on_list_pending_instruments(self):
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return
        rows = self.ppay.list_pending_instruments(vid)
        info(self.view, "Pending", f"Found {len(rows)} pending instrument(s).")

    def _prompt_text(self, title: str) -> Optional[str]:
        # very small inline line-edit prompt
        class _Prompt(QDialog):
            def __init__(self, parent=None, title="Enter"):
                super().__init__(parent)
                self.setWindowTitle(title)
                self._val = None
                self.line = QLineEdit()
                form = QFormLayout()
                form.addRow(QLabel(title), self.line)
                btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
                btns.accepted.connect(self._on_ok)
                btns.rejected.connect(self.reject)
                lay = QVBoxLayout(self)
                lay.addLayout(form)
                lay.addWidget(btns)

            def _on_ok(self):
                self._val = self.line.text().strip()
                self.accept()

            def value(self):
                return self._val

        dlg = _Prompt(self.view, title=title)
        if not dlg.exec():
            return None
        return dlg.value()

    # ---------- Statement orchestration ----------
    def build_vendor_statement(
        self,
        vendor_id: int,
        *,
        date_from: Optional[str] = None,
        date_to: Optional[str] = None,
        include_opening: bool = True,
        show_return_origins: bool = False,
    ) -> dict:
        """
        Build a vendor statement over a date range.
        Notes:
        - Purchase headers already reflect CLEARED-ONLY cash rollups (paid_amount).
        - Here, we also include ONLY payments whose clearing_state='cleared' so
          the statement reconciles with headers/aging.
        """
        # --- Opening balances (credit reduces payable) ---
        opening_credit = 0.0
        opening_payable = 0.0
        if include_opening and date_from:
            opening_credit = float(self.vadv.get_opening_balance(vendor_id, date_from))
            opening_payable -= opening_credit  # credit reduces what we owe

        rows: list[dict] = []

        # 1) Purchases (header rows only, date-filtered)
        prep = PurchasesRepo(self.conn)
        for p in prep.list_purchases_by_vendor(vendor_id, date_from, date_to):
            rows.append({
                "date": p["date"],
                "type": "Purchase",
                "doc_id": p["purchase_id"],
                "reference": {},
                "amount_effect": float(p["total_amount"]),  # increases payable
            })

        # 2) Cash/payments — CLEARED-ONLY
        for pay in self.ppay.list_payments_for_vendor(vendor_id, date_from, date_to):
            if str(pay["clearing_state"] or "").lower() != "cleared":
                continue  # ignore posted/pending/bounced
            amt = float(pay["amount"])
            row_type = "Cash Payment" if amt > 0 else "Refund"
            rows.append({
                "date": pay["date"],
                "type": row_type,
                "doc_id": pay["purchase_id"],
                "reference": {
                    "payment_id": pay["payment_id"],
                    "method": pay["method"],
                    "instrument_no": pay["instrument_no"],
                    "instrument_type": pay["instrument_type"],
                    "bank_account_id": pay["bank_account_id"],
                    "vendor_bank_account_id": pay["vendor_bank_account_id"],
                    "ref_no": pay["ref_no"],
                    "clearing_state": pay["clearing_state"],
                },
                # payments reduce payable; refunds are negative amounts and still reduce payable
                "amount_effect": (-abs(amt) if amt < 0 else -amt),
            })

        # 3) Credit ledger (already date-filtered)
        credit_note_rows_to_enrich: list[tuple[int, dict]] = []
        for a in self.vadv.list_ledger(vendor_id, date_from, date_to):
            amt = float(a["amount"])
            src_type = (a["source_type"] or "").lower()
            if src_type == "return_credit":
                row = {
                    "date": a["tx_date"],
                    "type": "Credit Note",
                    "doc_id": a["source_id"],
                    "reference": {"tx_id": a["tx_id"]},
                    "amount_effect": -amt,  # reduces payable
                }
                rows.append(row)
                if show_return_origins and a["source_id"]:
                    credit_note_rows_to_enrich.append((a["tx_id"], row))
            elif src_type == "applied_to_purchase":
                rows.append({
                    "date": a["tx_date"],
                    "type": "Credit Applied",
                    "doc_id": a["source_id"],
                    "reference": {"tx_id": a["tx_id"]},
                    "amount_effect": -abs(amt),  # amount stored negative => reduce payable by abs
                })
            else:
                # Fallback (treat other positive credits as reducing payable)
                rows.append({
                    "date": a["tx_date"],
                    "type": "Credit Note",
                    "doc_id": a["source_id"],
                    "reference": {"tx_id": a["tx_id"]},
                    "amount_effect": -amt,
                })

        # Optional enrichment: return origins (descriptive only)
        if show_return_origins and credit_note_rows_to_enrich:
            for _tx_id, row in credit_note_rows_to_enrich:
                pid = row.get("doc_id")
                if pid:
                    try:
                        lines = prep.list_return_values_by_purchase(pid)
                        if lines:
                            row.setdefault("reference", {})["lines"] = list(lines)
                    except Exception:
                        # Non-fatal: enrichment is optional
                        pass

        # 4) Sort and running balance (type order + stable tie-break)
        type_order = {"Purchase": 1, "Cash Payment": 2, "Refund": 3, "Credit Note": 4, "Credit Applied": 5}

        def tie_value(r: dict):
            ref = r.get("reference", {}) or {}
            return r.get("doc_id") or ref.get("payment_id") or ref.get("tx_id") or ""

        rows.sort(key=lambda r: (r["date"], type_order.get(r["type"], 9), tie_value(r)))

        # Running balance & totals
        balance = opening_payable
        totals = {"purchases": 0.0, "cash_paid": 0.0, "refunds": 0.0, "credit_notes": 0.0, "credit_applied": 0.0}
        out_rows: list[dict] = []
        for r in rows:
            balance += float(r["amount_effect"])
            rr = dict(r)
            rr["balance_after"] = balance
            out_rows.append(rr)
            if r["type"] == "Purchase":
                totals["purchases"] += abs(float(r["amount_effect"]))
            elif r["type"] == "Cash Payment":
                totals["cash_paid"] += abs(float(r["amount_effect"]))
            elif r["type"] == "Refund":
                totals["refunds"] += abs(float(r["amount_effect"]))
            elif r["type"] == "Credit Note":
                totals["credit_notes"] += abs(float(r["amount_effect"]))
            elif r["type"] == "Credit Applied":
                totals["credit_applied"] += abs(float(r["amount_effect"]))

        closing_balance = balance
        return {
            "vendor_id": vendor_id,
            "period": {"from": date_from, "to": date_to},
            "opening_credit": opening_credit,
            "opening_payable": opening_payable,
            "rows": out_rows,
            "totals": totals,
            "closing_balance": closing_balance,
        }

    # =========================
    # Vendor Bank Accounts API
    # (for future UI usage)
    # =========================
    def list_bank_accounts(self, active_only: bool = True) -> list[dict]:
        """List bank accounts for the currently selected vendor."""
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return []
        return self.vbank.list(vid, active_only=active_only)

    def create_bank_account(self, data: dict) -> Optional[int]:
        """Create a bank account for the selected vendor."""
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return None
        try:
            return self.vbank.create(vid, data)
        except (sqlite3.IntegrityError, sqlite3.OperationalError) as e:
            info(self.view, "Not saved", f"Could not create bank account:\n{e}")
            return None

    def update_bank_account(self, account_id: int, data: dict) -> bool:
        """Update a vendor bank account."""
        try:
            return self.vbank.update(account_id, data) > 0
        except (sqlite3.IntegrityError, sqlite3.OperationalError) as e:
            info(self.view, "Not saved", f"Could not update bank account:\n{e}")
            return False

    def deactivate_bank_account(self, account_id: int) -> bool:
        """Deactivate (or delete if unreferenced) a vendor bank account."""
        try:
            return self.vbank.deactivate(account_id) > 0
        except sqlite3.OperationalError as e:
            info(self.view, "Not saved", f"Could not deactivate bank account:\n{e}")
            return False

    def set_primary_bank_account(self, account_id: int) -> bool:
        """Mark an account as primary for the selected vendor."""
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor first.")
            return False
        try:
            return self.vbank.set_primary(vid, account_id) > 0
        except (sqlite3.IntegrityError, sqlite3.OperationalError) as e:
            info(self.view, "Not saved", f"Could not set primary account:\n{e}")
            return False

    # -------- Provider used by purchase payment flow --------
    def get_primary_vendor_bank_account(self, vendor_id: Optional[int] = None) -> Optional[dict]:
        """
        Return the default/primary bank account dict for a vendor (None if not present).
        Useful to pre-populate the purchase payment flow with a vendor's receiving account.
        """
        vid = vendor_id or self._selected_id()
        if not vid:
            return None
        accounts = self.vbank.list(vid, active_only=True)
        for acc in accounts:
            if int(acc.get("is_primary") or 0) == 1:
                return acc
        return None

    def get_primary_vendor_bank_account_id(self, vendor_id: Optional[int] = None) -> Optional[int]:
        """
        Return the vendor_bank_account_id of the primary account (or None).
        """
        acc = self.get_primary_vendor_bank_account(vendor_id)
        return int(acc["vendor_bank_account_id"]) if acc and acc.get("vendor_bank_account_id") is not None else None

    # CRUD
    def _add(self):
        form = VendorForm(self.view)
        # Connect new signals (form is in create mode; buttons disabled until a vendor exists)
        form.manageBankAccounts.connect(self._open_vendor_bank_accounts_dialog)
        form.grantVendorCredit.connect(self._open_grant_credit_dialog)
        if not form.exec():
            return
        payload = form.payload()
        if not payload:
            return
        vid = self.repo.create(**payload)
        info(self.view, "Saved", f"Vendor #{vid} created.")
        self._reload()

    def _edit(self):
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor to edit.")
            return
        current = self.repo.get(vid)
        form = VendorForm(self.view, initial=current.__dict__)
        # Connect new signals (enabled in edit mode because vendor_id is known)
        form.manageBankAccounts.connect(self._open_vendor_bank_accounts_dialog)
        form.grantVendorCredit.connect(self._open_grant_credit_dialog)
        if not form.exec():
            return
        payload = form.payload()
        if not payload:
            return
        self.repo.update(vid, **payload)
        info(self.view, "Saved", f"Vendor #{vid} updated.")
        self._reload()

    def _delete(self):
        vid = self._selected_id()
        if not vid:
            info(self.view, "Select", "Please select a vendor to delete.")
            return
        self.repo.delete(vid)
        info(self.view, "Deleted", f"Vendor #{vid} removed.")
        self._reload()

    # ---------- Signal handlers ----------
    def _open_vendor_bank_accounts_dialog(self, vendor_id: int):
        """Open the vendor bank accounts dialog (lazy import to keep dependencies optional)."""
        try:
            # Lazy import to avoid hard dependency if dialog isn't packaged everywhere
            from .bank_accounts_dialog import VendorBankAccountsDialog  # type: ignore
        except Exception as e:
            info(self.view, "Not available", f"Bank Accounts dialog is unavailable:\n{e}")
            return
        try:
            dlg = VendorBankAccountsDialog(self.view, conn=self.conn, vendor_id=int(vendor_id))
        except TypeError:
            # Fallback: try common alternative signatures
            try:
                dlg = VendorBankAccountsDialog(self.view, vendor_id=int(vendor_id))
            except Exception as e:
                info(self.view, "Error", f"Cannot open Bank Accounts dialog:\n{e}")
                return
        dlg.exec()
        # After managing accounts, details might change (e.g., primary flag)
        self._reload()

    def _open_grant_credit_dialog(self, vendor_id: int):
        """Tiny inline dialog to grant vendor credit."""
        class GrantCreditDialog(QDialog):
            def __init__(self, parent=None):
                super().__init__(parent)
                self.setWindowTitle("Grant Vendor Credit")
                self._payload = None
                self.amount = QLineEdit()
                self.amount.setPlaceholderText("Amount (> 0)")
                self.date = QDateEdit()
                self.date.setCalendarPopup(True)
                self.date.setDate(QDate.fromString(today_str(), "yyyy-MM-dd"))
                self.notes = QLineEdit()
                self.notes.setPlaceholderText("Notes (optional)")
                form = QFormLayout()
                form.addRow("Amount*", self.amount)
                form.addRow("Date*", self.date)
                form.addRow("Notes", self.notes)
                btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
                btns.accepted.connect(self._on_ok)
                btns.rejected.connect(self.reject)
                lay = QVBoxLayout(self)
                lay.addLayout(form)
                lay.addWidget(btns)

            def _on_ok(self):
                try:
                    amt = float(self.amount.text())
                except (TypeError, ValueError):
                    return
                if amt <= 0:
                    return
                self._payload = {
                    "amount": amt,
                    "date": self.date.date().toString("yyyy-MM-dd"),
                    "notes": (self.notes.text().strip() or None),
                }
                self.accept()

            def payload(self):
                return self._payload

        dlg = GrantCreditDialog(self.view)
        if not dlg.exec():
            return
        data = dlg.payload()
        if not data:
            return
        try:
            self.vadv.grant_credit(
                vendor_id=int(vendor_id),
                amount=float(data["amount"]),
                date=data["date"],
                notes=data.get("notes"),
                created_by=None,
                source_id=None,
            )
        except (sqlite3.IntegrityError, sqlite3.OperationalError) as e:
            info(self.view, "Not saved", f"Could not grant vendor credit:\n{e}")
            return
        info(self.view, "Saved", f"Granted vendor credit of {float(data['amount']):g}.")
        self._reload()

```

inventory_management/modules/vendor/payment_history_view.py
```
# inventory_management/modules/vendor/payment_history_view.py
from __future__ import annotations

from typing import Any, Dict, List, Optional

try:
    # Project-standard UI stack
    from PySide6.QtCore import Qt, QAbstractTableModel, QModelIndex
    from PySide6.QtWidgets import (
        QApplication,
        QDialog,
        QDialogButtonBox,
        QHBoxLayout,
        QLabel,
        QTableView,
        QTabWidget,
        QVBoxLayout,
        QWidget,
    )
except Exception:  # pragma: no cover
    raise


def _t(s: str) -> str:
    """i18n shim."""
    return s


# -----------------------------
# Minimal dict-backed table model
# -----------------------------
class _DictTableModel(QAbstractTableModel):
    """
    Simple model that takes a list[dict] and displays it as a table.
    Column order is determined by `columns` passed in; any missing values show as "".
    """

    def __init__(self, rows: List[Dict[str, Any]], columns: List[str], parent: Optional[QObject] = None):
        super().__init__(parent)
        self._rows = rows
        self._cols = columns

    # Qt model API
    def rowCount(self, parent: QModelIndex = QModelIndex()) -> int:  # type: ignore[override]
        return 0 if parent.isValid() else len(self._rows)

    def columnCount(self, parent: QModelIndex = QModelIndex()) -> int:  # type: ignore[override]
        return 0 if parent.isValid() else len(self._cols)

    def headerData(self, section: int, orientation: Qt.Orientation, role: int = Qt.DisplayRole):  # type: ignore[override]
        if role != Qt.DisplayRole:
            return None
        if orientation == Qt.Horizontal:
            return self._cols[section]
        return str(section + 1)

    def data(self, index: QModelIndex, role: int = Qt.DisplayRole):  # type: ignore[override]
        if not index.isValid():
            return None
        if role not in (Qt.DisplayRole, Qt.EditRole):
            return None
        row = self._rows[index.row()]
        key = self._cols[index.column()]
        val = row.get(key, "")
        if val is None:
            return ""
        # Format floats a bit nicer for display
        if isinstance(val, float):
            return f"{val:.2f}"
        return str(val)

    # Helpers
    def at(self, r: int) -> Dict[str, Any]:
        return self._rows[r]

    def rows(self) -> List[Dict[str, Any]]:
        return self._rows

    def columns(self) -> List[str]:
        return self._cols


# -----------------------------
# Window
# -----------------------------
class _VendorHistoryDialog(QDialog):
    """
    Thin, read-only viewer for vendor payments/advances/statement rows.

    Expected `history` shape (flexible):
      - Preferred (statement-style, as produced by controller.build_vendor_statement):
        {
          "vendor_id": int,
          "period": {"from": "YYYY-MM-DD"|None, "to": "YYYY-MM-DD"|None},
          "opening_credit": float,
          "opening_payable": float,
          "rows": [
            {
              "date": "YYYY-MM-DD",
              "type": "Purchase"|"Cash Payment"|"Refund"|"Credit Note"|"Credit Applied",
              "doc_id": str|None,
              "reference": {... arbitrary keys ...},
              "amount_effect": float,
              "balance_after": float
            },
            ...
          ],
          "totals": {...},
          "closing_balance": float
        }

      - Also tolerates a simpler payload with lists like history.get("payments"), history.get("advances").
        Those will be concatenated for display after a best-effort flatten.
    """

    def __init__(self, *, vendor_id: int, history: Dict[str, Any], parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.setWindowTitle(_t(f"Vendor History — #{vendor_id}"))
        self.setModal(True)
        self.resize(960, 560)

        self._vendor_id = int(vendor_id)
        self._history = history or {}

        outer = QVBoxLayout(self)

        # Header: period & headline numbers if present
        header = QWidget(self)
        hbox = QHBoxLayout(header)
        hbox.setContentsMargins(0, 0, 0, 0)

        period = self._history.get("period") or {}
        p_from = period.get("from")
        p_to = period.get("to")
        period_txt = _t("All Dates")
        if p_from or p_to:
            if not p_from:
                period_txt = _t(f"… to {p_to}")
            elif not p_to:
                period_txt = _t(f"{p_from} to …")
            else:
                period_txt = _t(f"{p_from} to {p_to}")

        opening_payable = self._safe_float(self._history.get("opening_payable"))
        opening_credit = self._safe_float(self._history.get("opening_credit"))
        closing_balance = self._safe_float(self._history.get("closing_balance"))

        lbl_period = QLabel(_t(f"Period: {period_txt}"))
        lbl_open = QLabel(_t(f"Opening Payable: {opening_payable:.2f}    Opening Credit: {opening_credit:.2f}"))
        lbl_close = QLabel(_t(f"Closing Balance: {closing_balance:.2f}") if closing_balance is not None else "")

        for w in (lbl_period, lbl_open, lbl_close):
            w.setStyleSheet("color: #444;")
            hbox.addWidget(w)
        hbox.addStretch(1)
        outer.addWidget(header)

        # Tabs
        tabs = QTabWidget(self)
        outer.addWidget(tabs, 1)

        # Transactions tab (statement rows if available, else merged fallback)
        tx_rows = self._build_tx_rows(self._history)
        tx_columns = self._choose_tx_columns(tx_rows)

        tx_table = QTableView(self)
        tx_model = _DictTableModel(tx_rows, tx_columns, self)
        tx_table.setModel(tx_model)
        tx_table.setAlternatingRowColors(True)
        tx_table.setSortingEnabled(True)
        tx_table.resizeColumnsToContents()

        tx_page = QWidget(self)
        tx_layout = QVBoxLayout(tx_page)
        tx_layout.addWidget(tx_table)
        tabs.addTab(tx_page, _t("Transactions"))

        # Totals tab if available
        totals = self._history.get("totals") or {}
        if totals:
            totals_rows, totals_cols = self._dict_to_rows_cols(totals)
            totals_table = QTableView(self)
            totals_model = _DictTableModel(totals_rows, totals_cols, self)
            totals_table.setModel(totals_model)
            totals_table.setAlternatingRowColors(True)
            totals_table.setSortingEnabled(True)
            totals_table.resizeColumnsToContents()

            totals_page = QWidget(self)
            t_layout = QVBoxLayout(totals_page)
            t_layout.addWidget(totals_table)
            tabs.addTab(totals_page, _t("Totals"))

        # Close button
        btns = QDialogButtonBox(QDialogButtonBox.Close, parent=self)
        btns.rejected.connect(self.reject)
        btns.accepted.connect(self.accept)
        # Map Close to accept for consistency
        close_btn = btns.button(QDialogButtonBox.Close)
        if close_btn:
            close_btn.clicked.connect(self.accept)
        outer.addWidget(btns)

    # -----------------------------
    # Row building / flattening
    # -----------------------------
    def _build_tx_rows(self, history: Dict[str, Any]) -> List[Dict[str, Any]]:
        rows: List[Dict[str, Any]] = []
        if isinstance(history.get("rows"), list):
            # Statement-style rows: flatten reference object
            for r in history["rows"]:
                base = {
                    "date": r.get("date"),
                    "type": r.get("type"),
                    "doc_id": r.get("doc_id"),
                    "amount_effect": self._safe_float(r.get("amount_effect")),
                    "balance_after": self._safe_float(r.get("balance_after")),
                }
                ref = r.get("reference") or {}
                flat = {**base, **self._flatten_reference(ref)}
                rows.append(flat)
            return rows

        # Fallback: merge payments & advances if present
        pays = history.get("payments") or []
        advs = history.get("advances") or []
        for p in pays:
            rows.append({
                "date": p.get("date"),
                "type": p.get("type") or "Cash Payment",
                "doc_id": p.get("purchase_id"),
                "amount_effect": -abs(self._safe_float(p.get("amount"), 0.0)),  # payments reduce payable
                "balance_after": None,
                **self._flatten_reference({
                    "payment_id": p.get("payment_id"),
                    "method": p.get("method"),
                    "instrument_no": p.get("instrument_no"),
                    "instrument_type": p.get("instrument_type"),
                    "bank_account_id": p.get("bank_account_id"),
                    "vendor_bank_account_id": p.get("vendor_bank_account_id"),
                    "ref_no": p.get("ref_no"),
                    "clearing_state": p.get("clearing_state"),
                }),
            })
        for a in advs:
            amt = self._safe_float(a.get("amount"), 0.0)
            src_type = (a.get("source_type") or "").lower()
            if src_type == "applied_to_purchase":
                rows.append({
                    "date": a.get("tx_date"),
                    "type": "Credit Applied",
                    "doc_id": a.get("source_id"),
                    "amount_effect": -abs(amt),
                    "balance_after": None,
                    "tx_id": a.get("tx_id"),
                })
            else:
                rows.append({
                    "date": a.get("tx_date"),
                    "type": "Credit Note",
                    "doc_id": a.get("source_id"),
                    "amount_effect": -amt,
                    "balance_after": None,
                    "tx_id": a.get("tx_id"),
                })
        return rows

    def _choose_tx_columns(self, rows: List[Dict[str, Any]]) -> List[str]:
        # Preferred column order; any extra keys appended at the end (stable)
        preferred = [
            "date",
            "type",
            "doc_id",
            "amount_effect",
            "balance_after",
            "payment_id",
            "method",
            "instrument_no",
            "instrument_type",
            "clearing_state",
            "ref_no",
            "bank_account_id",
            "vendor_bank_account_id",
            "tx_id",
        ]
        seen = {k for r in rows for k in r.keys()}
        cols = [c for c in preferred if c in seen]
        # Append any other discovered keys (deterministic order)
        extras = sorted(k for k in seen if k not in set(preferred))
        return cols + extras

    def _flatten_reference(self, ref: Dict[str, Any]) -> Dict[str, Any]:
        """Flatten nested `reference` dict into top-level displayable keys."""
        out: Dict[str, Any] = {}
        if not isinstance(ref, dict):
            return out
        for k, v in ref.items():
            out[str(k)] = v
        return out

    @staticmethod
    def _safe_float(v: Any, default: Optional[float] = None) -> Optional[float]:
        try:
            if v is None:
                return default
            return float(v)
        except (TypeError, ValueError):
            return default


# -----------------------------
# Public API
# -----------------------------
def open_vendor_history(*, vendor_id: int, history: Dict[str, Any]) -> None:
    """
    Open the vendor history window.

    Usage:
        payload = controller.build_vendor_statement(vendor_id, date_from, date_to)
        open_vendor_history(vendor_id=vid, history=payload)
    """
    app = QApplication.instance()
    owns_app = app is None
    if owns_app:
        app = QApplication([])

    dlg = _VendorHistoryDialog(vendor_id=int(vendor_id), history=history)
    dlg.exec()

    if owns_app:
        app.quit()

```

inventory_management/modules/vendor/grant_credit_dialog.py
```
from __future__ import annotations
import sqlite3
from typing import Optional

from PySide6.QtCore import QDate
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QDateEdit, QLabel,
    QDialogButtonBox, QMessageBox
)

from ...database.repositories.vendor_advances_repo import VendorAdvancesRepo
from ...utils.helpers import today_str
from ...utils.validators import is_positive_number


class GrantVendorCreditDialog(QDialog):
    """
    A tiny dialog to grant vendor credit (manual deposit/adjustment).
    Writes vendor_advances with source_type='deposit'.
    """
    def __init__(self, parent=None, *, conn: sqlite3.Connection, vendor_id: int, created_by: Optional[int] = None):
        super().__init__(parent)
        self.setWindowTitle("Grant Vendor Credit")
        self.conn = conn
        self.vendor_id = int(vendor_id)
        self.created_by = created_by
        self.repo = VendorAdvancesRepo(conn)
        self._payload = None

        # Header: current balance
        bal = 0.0
        try:
            bal = float(self.repo.get_balance(self.vendor_id))
        except Exception:
            bal = 0.0
        self.lab_balance = QLabel(f"Available credit: {bal:,.2f}")

        # Inputs
        self.txt_amount = QLineEdit()
        self.txt_amount.setPlaceholderText("Amount (e.g., 250)")

        self.dt_date = QDateEdit()
        self.dt_date.setCalendarPopup(True)
        self.dt_date.setDate(QDate.fromString(today_str(), "yyyy-MM-dd"))

        self.txt_notes = QLineEdit()

        form = QFormLayout()
        form.addRow(self.lab_balance)
        form.addRow("Amount*", self.txt_amount)
        form.addRow("Date*", self.dt_date)
        form.addRow("Notes", self.txt_notes)

        btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btns.accepted.connect(self.accept)
        btns.rejected.connect(self.reject)

        lay = QVBoxLayout(self)
        lay.addLayout(form)
        lay.addWidget(btns)

    def accept(self):
        amt_s = (self.txt_amount.text() or "").strip()
        if not is_positive_number(amt_s):
            QMessageBox.warning(self, "Invalid", "Enter a positive amount.")
            return
        amount = float(amt_s)
        date_str = self.dt_date.date().toString("yyyy-MM-dd")
        notes = (self.txt_notes.text() or "").strip() or None

        try:
            # Defaults to source_type='deposit' per your repo change
            self.repo.grant_credit(
                vendor_id=self.vendor_id,
                amount=amount,
                date=date_str,
                notes=notes,
                created_by=self.created_by
            )
        except sqlite3.IntegrityError as e:
            QMessageBox.warning(self, "Not saved", f"Could not grant credit:\n{e}")
            return
        except sqlite3.OperationalError as e:
            QMessageBox.warning(self, "Not saved", f"Database error:\n{e}")
            return

        self._payload = {"amount": amount, "date": date_str, "notes": notes}
        super().accept()

    def payload(self) -> Optional[dict]:
        return self._payload

```

inventory_management/modules/vendor/view.py
```
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit, QLabel, QSplitter, QFrame
)
from PySide6.QtCore import Qt
from ...widgets.table_view import TableView
from .details import VendorDetails


class VendorView(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        root = QVBoxLayout(self)

        # actions + search
        top = QHBoxLayout()
        self.btn_add = QPushButton("Add")
        self.btn_edit = QPushButton("Edit")
        # self.btn_del = QPushButton("Delete")

        # New: apply credit action (from vendor profile to an open purchase)
        self.btn_apply_credit = QPushButton("Apply Credit…")

        top.addWidget(self.btn_add)
        top.addWidget(self.btn_edit)
        # top.addWidget(self.btn_del)
        top.addWidget(self.btn_apply_credit)
        top.addStretch(1)

        self.search = QLineEdit()
        self.search.setPlaceholderText("Search vendors (name, id, contact, address)…")
        top.addWidget(QLabel("Search:"))
        top.addWidget(self.search, 2)
        root.addLayout(top)

        # table + right side split (details + bank accounts)
        split = QSplitter(Qt.Horizontal)

        # Left: vendors table
        self.table = TableView()
        split.addWidget(self.table)

        # Right: vertical split with details (top) and accounts (bottom)
        right = QSplitter(Qt.Vertical)

        # Top-right: vendor details
        self.details = VendorDetails()
        right.addWidget(self.details)

        # Bottom-right: bank accounts panel
        accounts_panel = QFrame()
        accounts_layout = QVBoxLayout(accounts_panel)
        accounts_header = QHBoxLayout()

        lbl_accounts = QLabel("Bank Accounts")
        lbl_accounts.setStyleSheet("font-weight: 600;")
        accounts_header.addWidget(lbl_accounts)
        accounts_header.addStretch(1)

        # Bank account actions
        self.btn_acc_add = QPushButton("Add Account")
        self.btn_acc_edit = QPushButton("Edit")
        self.btn_acc_deactivate = QPushButton("Deactivate")
        self.btn_acc_set_primary = QPushButton("Set Primary")
        accounts_header.addWidget(self.btn_acc_add)
        accounts_header.addWidget(self.btn_acc_edit)
        accounts_header.addWidget(self.btn_acc_deactivate)
        accounts_header.addWidget(self.btn_acc_set_primary)

        accounts_layout.addLayout(accounts_header)

        # Accounts table
        self.accounts_table = TableView()
        accounts_layout.addWidget(self.accounts_table, 1)

        right.addWidget(accounts_panel)

        # Sizing
        right.setStretchFactor(0, 1)  # details
        right.setStretchFactor(1, 1)  # accounts

        split.addWidget(right)
        split.setStretchFactor(0, 3)  # vendor list
        split.setStretchFactor(1, 2)  # right panel

        root.addWidget(split, 1)

```

inventory_management/modules/vendor/model.py
```
from PySide6.QtCore import QAbstractTableModel, Qt, QModelIndex

# Keep import for typed access when VendorsRepo returns dataclasses
try:
    from ...database.repositories.vendors_repo import Vendor  # type: ignore
except Exception:
    Vendor = object  # fallback typing if not available


def _get(obj, key, default=None):
    """Support both dataclass-like attrs and dict/sqlite3.Row access."""
    if obj is None:
        return default
    if isinstance(obj, dict):
        return obj.get(key, default)
    # sqlite3.Row behaves like a mapping but getattr also works for dataclasses
    try:
        return getattr(obj, key)
    except Exception:
        try:
            return obj[key]
        except Exception:
            return default


class VendorsTableModel(QAbstractTableModel):
    HEADERS = ["ID", "Name", "Contact", "Address"]

    def __init__(self, rows):
        super().__init__()
        self._rows = list(rows or [])

    def rowCount(self, parent=QModelIndex()):  # noqa: N802
        return len(self._rows)

    def columnCount(self, parent=QModelIndex()):  # noqa: N802
        return len(self.HEADERS)

    def data(self, index, role=Qt.DisplayRole):  # noqa: N802
        if not index.isValid():
            return None
        v = self._rows[index.row()]
        if role in (Qt.DisplayRole, Qt.EditRole):
            c = index.column()
            values = [
                _get(v, "vendor_id", ""),
                _get(v, "name", ""),
                _get(v, "contact_info", ""),
                _get(v, "address", "") or "",
            ]
            return values[c]
        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):  # noqa: N802
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.HEADERS[section]
        return super().headerData(section, orientation, role)

    def at(self, row: int):
        """Return the underlying row object (Vendor dataclass or dict)."""
        return self._rows[row]

    def replace(self, rows):
        self.beginResetModel()
        self._rows = list(rows or [])
        self.endResetModel()


class VendorBankAccountsTableModel(QAbstractTableModel):
    """
    Mirrors rows returned by VendorBankAccountsRepo.list(vendor_id, active_only=True).

    Expected fields per row:
      vendor_bank_account_id, bank_name, branch, account_number, ifsc_swift,
      account_type, is_primary, is_active
    """
    HEADERS = ["ID", "Bank", "Branch", "Account #", "IFSC/SWIFT", "Type", "Primary", "Active"]

    def __init__(self, rows):
        super().__init__()
        self._rows = list(rows or [])

    def rowCount(self, parent=QModelIndex()):  # noqa: N802
        return len(self._rows)

    def columnCount(self, parent=QModelIndex()):  # noqa: N802
        return len(self.HEADERS)

    def data(self, index, role=Qt.DisplayRole):  # noqa: N802
        if not index.isValid():
            return None
        r = self._rows[index.row()]
        if role in (Qt.DisplayRole, Qt.EditRole):
            c = index.column()
            is_primary = _get(r, "is_primary", 0)
            is_active = _get(r, "is_active", 1)
            values = [
                _get(r, "vendor_bank_account_id", ""),
                _get(r, "bank_name", ""),
                _get(r, "branch", ""),
                _get(r, "account_number", ""),
                _get(r, "ifsc_swift", ""),
                _get(r, "account_type", ""),
                "Yes" if int(is_primary or 0) == 1 else "No",
                "Yes" if int(is_active or 0) == 1 else "No",
            ]
            return values[c]
        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):  # noqa: N802
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.HEADERS[section]
        return super().headerData(section, orientation, role)

    def at(self, row: int) -> dict:
        """Return the underlying row dict/sqlite3.Row for the given index."""
        return self._rows[row]

    def replace(self, rows):
        self.beginResetModel()
        self._rows = list(rows or [])
        self.endResetModel()

```

inventory_management/modules/vendor/details.py
```
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QGroupBox, QFormLayout

class VendorDetails(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        box = QGroupBox("Vendor Details")
        f = QFormLayout(box)
        self.lab_id = QLabel("-")
        self.lab_name = QLabel("-")
        self.lab_contact = QLabel("-")
        self.lab_address = QLabel("-")
        self.lab_address.setWordWrap(True)
        f.addRow("ID:", self.lab_id)
        f.addRow("Name:", self.lab_name)
        f.addRow("Contact:", self.lab_contact)
        f.addRow("Address:", self.lab_address)

        root = QVBoxLayout(self)
        root.addWidget(box, 1)

    def clear(self):
        self.lab_id.setText("-")
        self.lab_name.setText("-")
        self.lab_contact.setText("-")
        self.lab_address.setText("-")

    def set_data(self, vendor: dict | None):
        if not vendor:
            self.clear(); return
        self.lab_id.setText(str(vendor["vendor_id"]))
        self.lab_name.setText(vendor["name"] or "")
        self.lab_contact.setText(vendor["contact_info"] or "")
        self.lab_address.setText(vendor.get("address") or "")

```

inventory_management/modules/vendor/bank_accounts_dialog.py
```
from __future__ import annotations
import sqlite3
from typing import Optional

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, QPushButton,
    QMessageBox, QDialogButtonBox, QFormLayout, QLineEdit, QCheckBox
)

from ...database.repositories.vendor_bank_accounts_repo import VendorBankAccountsRepo


class AccountEditDialog(QDialog):
    """Add/Edit a single vendor bank account (no 'primary' toggle here)."""
    def __init__(self, parent=None, *, initial: Optional[dict] = None):
        super().__init__(parent)
        self.setWindowTitle("Bank Account")
        self._payload = None

        self.txt_label = QLineEdit()
        self.txt_bank = QLineEdit()
        self.txt_acc  = QLineEdit()
        self.txt_iban = QLineEdit()
        self.txt_rout = QLineEdit()
        self.chk_active = QCheckBox("Active")
        self.chk_active.setChecked(True)

        form = QFormLayout()
        form.addRow("Label*", self.txt_label)
        form.addRow("Bank", self.txt_bank)
        form.addRow("Account No", self.txt_acc)
        form.addRow("IBAN", self.txt_iban)
        form.addRow("Routing No", self.txt_rout)
        form.addRow("", self.chk_active)

        btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        btns.accepted.connect(self.accept)
        btns.rejected.connect(self.reject)

        lay = QVBoxLayout(self)
        lay.addLayout(form)
        lay.addWidget(btns)

        if initial:
            self.txt_label.setText(initial.get("label", "") or "")
            self.txt_bank.setText(initial.get("bank_name", "") or "")
            self.txt_acc.setText(initial.get("account_no", "") or "")
            self.txt_iban.setText(initial.get("iban", "") or "")
            self.txt_rout.setText(initial.get("routing_no", "") or "")
            self.chk_active.setChecked(bool(initial.get("is_active", 1)))

    def accept(self):
        label = (self.txt_label.text() or "").strip()
        if not label:
            QMessageBox.warning(self, "Required", "Label is required.")
            return
        self._payload = {
            "label": label,
            "bank_name": (self.txt_bank.text() or "").strip() or None,
            "account_no": (self.txt_acc.text() or "").strip() or None,
            "iban": (self.txt_iban.text() or "").strip() or None,
            "routing_no": (self.txt_rout.text() or "").strip() or None,
            "is_active": 1 if self.chk_active.isChecked() else 0,
        }
        super().accept()

    def payload(self) -> Optional[dict]:
        return self._payload


class VendorBankAccountsDialog(QDialog):
    """
    Manage a vendor's bank accounts:
      - List: Label, Bank, Account/IBAN, Primary, Active
      - Add/Edit
      - Activate/Deactivate
      - Make Primary (force flip: clear others, set one)
    """
    COLS = ["#", "Label", "Bank", "Account / IBAN", "Primary", "Active"]

    def __init__(self, parent=None, *, conn: sqlite3.Connection, vendor_id: int):
        super().__init__(parent)
        self.setWindowTitle("Vendor Bank Accounts")
        self.conn = conn
        self.vendor_id = int(vendor_id)
        self.repo = VendorBankAccountsRepo(conn)

        # Table
        self.tbl = QTableWidget(0, len(self.COLS))
        self.tbl.setHorizontalHeaderLabels(self.COLS)
        self.tbl.verticalHeader().setVisible(False)
        self.tbl.setSelectionBehavior(self.tbl.SelectRows)
        self.tbl.setEditTriggers(self.tbl.NoEditTriggers)
        self.tbl.setColumnWidth(0, 40)
        self.tbl.setColumnWidth(1, 220)
        self.tbl.setColumnWidth(2, 140)
        self.tbl.setColumnWidth(3, 220)
        self.tbl.setColumnWidth(4, 80)
        self.tbl.setColumnWidth(5, 80)

        # Buttons
        btns = QHBoxLayout()
        self.btn_add = QPushButton("Add")
        self.btn_edit = QPushButton("Edit")
        self.btn_toggle = QPushButton("Deactivate")
        self.btn_primary = QPushButton("Make Primary")
        btns.addWidget(self.btn_add)
        btns.addWidget(self.btn_edit)
        btns.addWidget(self.btn_toggle)
        btns.addWidget(self.btn_primary)
        btns.addStretch(1)

        # Close
        bb = QDialogButtonBox(QDialogButtonBox.Close)
        bb.rejected.connect(self.reject)
        bb.accepted.connect(self.accept)  # in case you ever flip to OK|Close

        lay = QVBoxLayout(self)
        lay.addWidget(self.tbl, 1)
        lay.addLayout(btns)
        lay.addWidget(bb)

        # Wire
        self.btn_add.clicked.connect(self._add)
        self.btn_edit.clicked.connect(self._edit)
        self.btn_toggle.clicked.connect(self._toggle_active)
        self.btn_primary.clicked.connect(self._make_primary)

        self._reload()

    def _reload(self):
        rows = self.conn.execute("""
            SELECT vendor_bank_account_id, label, bank_name, account_no, iban, routing_no,
                   is_primary, is_active
            FROM vendor_bank_accounts
            WHERE vendor_id=?
            ORDER BY is_active DESC, is_primary DESC, label
        """, (self.vendor_id,)).fetchall()

        self.tbl.setRowCount(0)
        for i, r in enumerate(rows, start=1):
            row = self.tbl.rowCount()
            self.tbl.insertRow(row)

            id_item = QTableWidgetItem(str(i))
            id_item.setData(Qt.UserRole, int(r["vendor_bank_account_id"]))
            self.tbl.setItem(row, 0, id_item)

            self.tbl.setItem(row, 1, QTableWidgetItem(r["label"] or ""))
            self.tbl.setItem(row, 2, QTableWidgetItem(r["bank_name"] or ""))

            acc_line = (r["account_no"] or "").strip()
            if r["iban"]:
                acc_line = (acc_line + " | " if acc_line else "") + r["iban"]
            self.tbl.setItem(row, 3, QTableWidgetItem(acc_line or ""))

            self.tbl.setItem(row, 4, QTableWidgetItem("Yes" if r["is_primary"] else "No"))
            act = bool(r["is_active"])
            self.tbl.setItem(row, 5, QTableWidgetItem("Active" if act else "Inactive"))

        self._update_toggle_label()

    def _selected_id(self) -> Optional[int]:
        idxs = self.tbl.selectionModel().selectedRows()
        if not idxs:
            return None
        it = self.tbl.item(idxs[0].row(), 0)
        return int(it.data(Qt.UserRole)) if it else None

    def _update_toggle_label(self):
        idxs = self.tbl.selectionModel().selectedRows()
        if not idxs:
            self.btn_toggle.setText("Deactivate")
            return
        row = idxs[0].row()
        active_text = self.tbl.item(row, 5).text()
        self.btn_toggle.setText("Deactivate" if active_text == "Active" else "Activate")

    # ---- Actions ----
    def _add(self):
        dlg = AccountEditDialog(self)
        if not dlg.exec():
            return
        data = dlg.payload()
        if not data:
            return
        try:
            self.repo.create(self.vendor_id, data)
        except sqlite3.IntegrityError as e:
            # likely duplicate (vendor_id, label) unique hit or 'one primary' check
            QMessageBox.warning(self, "Not saved", f"Could not add account:\n{e}")
            return
        self._reload()

    def _edit(self):
        acc_id = self._selected_id()
        if not acc_id:
            QMessageBox.information(self, "Select", "Select an account to edit.")
            return
        row = self.conn.execute("""
            SELECT * FROM vendor_bank_accounts WHERE vendor_bank_account_id=? AND vendor_id=?
        """, (acc_id, self.vendor_id)).fetchone()
        if not row:
            QMessageBox.warning(self, "Not found", "Account not found.")
            return

        init = {
            "label": row["label"], "bank_name": row["bank_name"], "account_no": row["account_no"],
            "iban": row["iban"], "routing_no": row["routing_no"], "is_active": row["is_active"]
        }
        dlg = AccountEditDialog(self, initial=init)
        if not dlg.exec():
            return
        data = dlg.payload()
        if not data:
            return

        try:
            # Prefer repo.update if available; else direct SQL
            if hasattr(self.repo, "update"):
                self.repo.update(acc_id, data)
            else:
                with self.conn:
                    self.conn.execute("""
                        UPDATE vendor_bank_accounts
                           SET label=?, bank_name=?, account_no=?, iban=?, routing_no=?, is_active=?
                         WHERE vendor_bank_account_id=? AND vendor_id=?
                    """, (data["label"], data["bank_name"], data["account_no"], data["iban"], data["routing_no"],
                          int(data["is_active"]), acc_id, self.vendor_id))
        except sqlite3.IntegrityError as e:
            QMessageBox.warning(self, "Not saved", f"Could not update account:\n{e}")
            return

        self._reload()

    def _toggle_active(self):
        acc_id = self._selected_id()
        if not acc_id:
            QMessageBox.information(self, "Select", "Select an account to activate/deactivate.")
            return
        row = self.conn.execute("""
            SELECT is_active FROM vendor_bank_accounts WHERE vendor_bank_account_id=? AND vendor_id=?
        """, (acc_id, self.vendor_id)).fetchone()
        if not row:
            return
        new_flag = 0 if int(row["is_active"]) else 1
        with self.conn:
            self.conn.execute("""
                UPDATE vendor_bank_accounts SET is_active=? WHERE vendor_bank_account_id=? AND vendor_id=?
            """, (new_flag, acc_id, self.vendor_id))
        self._reload()

    def _make_primary(self):
        acc_id = self._selected_id()
        if not acc_id:
            QMessageBox.information(self, "Select", "Select an account to make primary.")
            return
        # Force-flip primary in one transaction to satisfy the partial-unique constraint
        try:
            with self.conn:
                self.conn.execute(
                    "UPDATE vendor_bank_accounts SET is_primary=0 WHERE vendor_id=?", (self.vendor_id,)
                )
                self.conn.execute(
                    "UPDATE vendor_bank_accounts SET is_primary=1 WHERE vendor_bank_account_id=? AND vendor_id=?",
                    (acc_id, self.vendor_id)
                )
        except sqlite3.IntegrityError as e:
            QMessageBox.warning(self, "Not updated", f"Could not make primary:\n{e}")
            return
        self._reload()

    # keep the toggle button label in sync with selection
    def showEvent(self, e):
        super().showEvent(e)
        self.tbl.selectionModel().selectionChanged.connect(lambda *_: self._update_toggle_label())

```

inventory_management/modules/vendor/payment_dialog.py
```
# inventory_management/modules/vendor/payment_dialog.py
from __future__ import annotations

from typing import Callable, Optional, Literal

try:
    # Project standard: PySide6
    from PySide6.QtCore import Qt, QDate
    from PySide6.QtGui import QIntValidator, QKeySequence
    from PySide6.QtWidgets import (
        QApplication,
        QComboBox,
        QDateEdit,
        QDialog,
        QDialogButtonBox,
        QDoubleSpinBox,
        QFormLayout,
        QHBoxLayout,
        QLabel,
        QLineEdit,
        QMessageBox,
        QPlainTextEdit,
        QPushButton,
        QVBoxLayout,
        QWidget,
        QStackedWidget,
        QTabBar,
    )
except Exception:  # pragma: no cover
    raise


# -----------------------------
# i18n shim
# -----------------------------
def _t(s: str) -> str:
    return s


# -----------------------------
# Canonical constants & matrices
# -----------------------------
METHODS = [
    "Cash",
    "Bank Transfer",
    "Card",
    "Cheque",
    "Cash Deposit",
    "Other",
]

INSTRUMENT_TYPES = [
    "online",
    "cross_cheque",
    "cash_deposit",
    "pay_order",
    "other",
]

CLEARING_STATES = ["posted", "pending", "cleared", "bounced"]

METHOD_TO_FORCED_INSTRUMENT = {
    "Cash": "other",
    "Bank Transfer": "online",
    "Card": "other",
    "Cheque": "cross_cheque",
    "Cash Deposit": "cash_deposit",
    "Other": "other",
}

METHOD_TO_DEFAULT_CLEARING = {
    "Cash": "posted",
    "Bank Transfer": "posted",
    "Card": "posted",
    "Cheque": "pending",
    "Cash Deposit": "pending",
    "Other": "posted",
}

METHODS_REQUIRE_BANK = {"Bank Transfer", "Cheque", "Cash Deposit"}
METHODS_REQUIRE_INSTR_NO = {"Bank Transfer", "Cheque", "Cash Deposit"}


# -----------------------------
# Public API
# -----------------------------
def open_vendor_money_form(
    *,
    mode: Literal["payment", "advance", "apply_advance"],
    vendor_id: int,
    purchase_id: Optional[str] = None,
    defaults: dict | None = None,
) -> dict | None:
    """
    Unified money-out dialog for vendors with three modes:
      - "payment": capture vendor payment/refund → payload for PurchasePaymentsRepo.record_payment(...)
      - "advance": record vendor advance (prepayment) → payload for VendorAdvancesRepo.grant_credit(...)
      - "apply_advance": apply advance to a purchase → payload for VendorAdvancesRepo.apply_credit_to_purchase(...)
    """
    app = QApplication.instance()
    owns_app = app is None
    if owns_app:
        app = QApplication([])

    dlg = _VendorMoneyDialog(mode=mode, vendor_id=int(vendor_id), purchase_id=purchase_id, defaults=defaults or {})
    result = dlg.exec()
    payload = dlg.payload() if result == QDialog.Accepted else None

    if owns_app:
        app.quit()
    return payload


# -----------------------------
# Dialog implementation
# -----------------------------
class _VendorMoneyDialog(QDialog):
    """
    One dialog with three pages:
      - Payment (enforces bank/instrument/clearing rules)
      - Record Advance
      - Apply Advance
    Produces repo-shaped payloads.
    """

    PAGE_PAYMENT = 0
    PAGE_ADVANCE = 1
    PAGE_APPLY = 2

    def __init__(self, *, mode: str, vendor_id: int, purchase_id: Optional[str], defaults: dict) -> None:
        super().__init__(None)
        self.setWindowTitle(_t("Vendor Money"))
        self.setModal(True)

        # Common state
        self._payload: Optional[dict] = None
        self._vendor_id = int(vendor_id)
        self._locked_purchase_id = str(purchase_id) if purchase_id is not None else None
        self._defaults = defaults or {}

        # Adapters (all optional)
        self._list_company_bank_accounts: Optional[Callable[[], list]] = self._defaults.get("list_company_bank_accounts")
        self._list_vendor_bank_accounts: Optional[Callable[[int], list]] = self._defaults.get("list_vendor_bank_accounts")
        self._list_open_purchases_for_vendor: Optional[Callable[[int], list]] = self._defaults.get("list_open_purchases_for_vendor")
        self._today: Optional[Callable[[], str]] = self._defaults.get("today")

        # Prefills (payment page)
        self._prefill_method: Optional[str] = self._defaults.get("method")
        self._prefill_amount: Optional[float] = self._defaults.get("amount")
        self._prefill_date: Optional[str] = self._defaults.get("date")
        self._prefill_company_bank_id: Optional[int] = self._defaults.get("bank_account_id")
        self._prefill_vendor_bank_id: Optional[int] = self._defaults.get("vendor_bank_account_id")
        self._prefill_instrument_type: Optional[str] = self._defaults.get("instrument_type")
        self._prefill_instrument_no: Optional[str] = self._defaults.get("instrument_no")
        self._prefill_instrument_date: Optional[str] = self._defaults.get("instrument_date")
        self._prefill_deposited_date: Optional[str] = self._defaults.get("deposited_date")
        self._prefill_clearing_state: Optional[str] = self._defaults.get("clearing_state")
        self._prefill_cleared_date: Optional[str] = self._defaults.get("cleared_date")
        self._prefill_notes: Optional[str] = self._defaults.get("notes")
        self._prefill_created_by: Optional[int] = self._defaults.get("created_by")
        self._vendor_display: Optional[str] = self._defaults.get("vendor_display")

        self._build_ui()

        initial = {
            "payment": self.PAGE_PAYMENT,
            "advance": self.PAGE_ADVANCE,
            "apply_advance": self.PAGE_APPLY,
        }.get(mode, self.PAGE_PAYMENT)
        self.pageStack.setCurrentIndex(initial)
        self.tabBar.setCurrentIndex(initial)
        self._sync_window_title()

        # Load data & prefills
        self._load_purchases()
        self._load_company_banks()
        self._load_vendor_banks()
        self._apply_prefills_payment()
        self._lock_purchase_if_needed()
        self._on_method_changed()
        self._update_hint()
        self._validate_live_payment()
        self._validate_live_advance()
        self._validate_live_apply()

    # ---------- Layout ----------
    def _build_ui(self) -> None:
        outer = QVBoxLayout(self)

        # Tabs + stacked pages
        self.tabBar = QTabBar()
        self.tabBar.addTab(_t("Payment"))
        self.tabBar.addTab(_t("Record Advance"))
        self.tabBar.addTab(_t("Apply Advance"))
        self.tabBar.currentChanged.connect(self._on_tab_changed)
        outer.addWidget(self.tabBar)

        self.pageStack = QStackedWidget()
        outer.addWidget(self.pageStack, 1)

        # Payment page
        self.page_payment = QWidget()
        self._build_payment_page(self.page_payment)
        self.pageStack.addWidget(self.page_payment)

        # Record advance page
        self.page_advance = QWidget()
        self._build_advance_page(self.page_advance)
        self.pageStack.addWidget(self.page_advance)

        # Apply advance page
        self.page_apply = QWidget()
        self._build_apply_page(self.page_apply)
        self.pageStack.addWidget(self.page_apply)

        # Hint / Error / Buttons
        self.hintLabel = QLabel("")
        self.hintLabel.setWordWrap(True)
        self.hintLabel.setStyleSheet("color:#666;")
        outer.addWidget(self.hintLabel)

        self.errorLabel = QLabel("")
        self.errorLabel.setStyleSheet("color:#b00020;")
        outer.addWidget(self.errorLabel)

        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        self.saveBtn: QPushButton = self.buttonBox.button(QDialogButtonBox.Save)
        self.cancelBtn: QPushButton = self.buttonBox.button(QDialogButtonBox.Cancel)
        self.saveBtn.setDefault(True)
        self.saveBtn.setShortcut(QKeySequence("Alt+S"))
        self.cancelBtn.setShortcut(QKeySequence("Alt+C"))
        self.saveBtn.clicked.connect(self._on_save)
        self.cancelBtn.clicked.connect(self.reject)
        outer.addWidget(self.buttonBox)

    # ---------- Payment page ----------
    def _build_payment_page(self, page: QWidget) -> None:
        form = QFormLayout(page)

        # Purchase picker
        self.purchasePicker = QComboBox()
        self.purchaseRemainingLabel = QLabel("")
        row = QWidget()
        h = QHBoxLayout(row)
        h.addWidget(self.purchasePicker, 1)
        h.addWidget(self.purchaseRemainingLabel, 0, Qt.AlignRight)
        lbl_purchase = QLabel(_t("Purchase"))
        lbl_purchase.setBuddy(self.purchasePicker)
        form.addRow(lbl_purchase, row)

        # Vendor label
        self.vendorLabel = QLabel(_t("Vendor: ") + (str(self._vendor_display or self._vendor_id)))
        form.addRow(QLabel(""), self.vendorLabel)

        # Method
        self.methodCombo = QComboBox()
        for m in METHODS:
            self.methodCombo.addItem(m)
        form.addRow(QLabel(_t("Method")), self.methodCombo)

        # Amount
        self.amountEdit = QDoubleSpinBox()
        self.amountEdit.setDecimals(2)
        self.amountEdit.setRange(-1_000_000_000.0, 1_000_000_000.0)
        self.amountEdit.setSingleStep(1.0)
        lbl_amount = QLabel(_t("Amount"))
        lbl_amount.setBuddy(self.amountEdit)
        form.addRow(lbl_amount, self.amountEdit)

        # Date
        self.dateEdit = QDateEdit()
        self.dateEdit.setCalendarPopup(True)
        self.dateEdit.setDisplayFormat("yyyy-MM-dd")
        self.dateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Date")), self.dateEdit)

        # Company bank
        self.companyBankCombo = QComboBox()
        lbl_cbank = QLabel(_t("Company Bank"))
        lbl_cbank.setBuddy(self.companyBankCombo)
        form.addRow(lbl_cbank, self.companyBankCombo)

        # Vendor bank (optional; for reconciliation/reference)
        self.vendorBankCombo = QComboBox()
        self.vendorBankCombo.addItem("", None)  # blank
        lbl_vbank = QLabel(_t("Vendor Bank (optional)"))
        lbl_vbank.setBuddy(self.vendorBankCombo)
        form.addRow(lbl_vbank, self.vendorBankCombo)

        # Instrument type
        self.instrumentTypeCombo = QComboBox()
        for t in INSTRUMENT_TYPES:
            self.instrumentTypeCombo.addItem(t)
        form.addRow(QLabel(_t("Instrument Type")), self.instrumentTypeCombo)

        # Instrument no
        self.instrumentNoEdit = QLineEdit()
        lbl_insno = QLabel(_t("Instrument No"))
        lbl_insno.setBuddy(self.instrumentNoEdit)
        form.addRow(lbl_insno, self.instrumentNoEdit)

        # Instrument date
        self.instrumentDateEdit = QDateEdit()
        self.instrumentDateEdit.setCalendarPopup(True)
        self.instrumentDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.instrumentDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Instrument Date")), self.instrumentDateEdit)

        # Deposited date
        self.depositedDateEdit = QDateEdit()
        self.depositedDateEdit.setCalendarPopup(True)
        self.depositedDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.depositedDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Deposited Date")), self.depositedDateEdit)

        # Clearing state
        self.clearingStateCombo = QComboBox()
        for s in CLEARING_STATES:
            self.clearingStateCombo.addItem(s)
        form.addRow(QLabel(_t("Clearing State")), self.clearingStateCombo)

        # Cleared date
        self.clearedDateEdit = QDateEdit()
        self.clearedDateEdit.setCalendarPopup(True)
        self.clearedDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.clearedDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Cleared Date")), self.clearedDateEdit)

        # Notes / Created by
        self.notesEdit = QPlainTextEdit()
        self.notesEdit.setPlaceholderText(_t("Optional notes"))
        self.notesEdit.setFixedHeight(80)
        form.addRow(QLabel(_t("Notes")), self.notesEdit)

        self.createdByEdit = QLineEdit()
        self.createdByEdit.setValidator(QIntValidator())
        form.addRow(QLabel(_t("Created By")), self.createdByEdit)

        # Track labels for required asterisks
        self._label_map = {
            self.companyBankCombo: lbl_cbank,
            self.instrumentNoEdit: lbl_insno,
            self.amountEdit: lbl_amount,
        }

        # Wire
        self.purchasePicker.currentIndexChanged.connect(self._update_remaining)
        self.methodCombo.currentIndexChanged.connect(self._on_method_changed)
        self.clearingStateCombo.currentIndexChanged.connect(self._on_clearing_changed)
        self.amountEdit.valueChanged.connect(self._validate_live_payment)
        self.companyBankCombo.currentIndexChanged.connect(self._validate_live_payment)
        self.instrumentNoEdit.textChanged.connect(self._validate_live_payment)
        self.instrumentTypeCombo.currentIndexChanged.connect(self._validate_live_payment)
        self.clearedDateEdit.dateChanged.connect(self._validate_live_payment)

    # ---------- Record Advance page ----------
    def _build_advance_page(self, page: QWidget) -> None:
        form = QFormLayout(page)

        # Vendor label
        self.vendorLabel2 = QLabel(_t("Vendor: ") + (str(self._vendor_display or self._vendor_id)))
        form.addRow(QLabel(""), self.vendorLabel2)

        # Amount (>0)
        self.advAmountEdit = QDoubleSpinBox()
        self.advAmountEdit.setDecimals(2)
        self.advAmountEdit.setRange(0.0, 1_000_000_000.0)
        self.advAmountEdit.setSingleStep(1.0)
        form.addRow(QLabel(_t("Amount *")), self.advAmountEdit)

        # Date
        self.advDateEdit = QDateEdit()
        self.advDateEdit.setCalendarPopup(True)
        self.advDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.advDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Date")), self.advDateEdit)

        # Notes / Created by
        self.advNotesEdit = QPlainTextEdit()
        self.advNotesEdit.setPlaceholderText(_t("Optional notes"))
        self.advNotesEdit.setFixedHeight(80)
        form.addRow(QLabel(_t("Notes")), self.advNotesEdit)

        self.advCreatedByEdit = QLineEdit()
        self.advCreatedByEdit.setValidator(QIntValidator())
        form.addRow(QLabel(_t("Created By")), self.advCreatedByEdit)

        # Wire
        self.advAmountEdit.valueChanged.connect(self._validate_live_advance)

    # ---------- Apply Advance page ----------
    def _build_apply_page(self, page: QWidget) -> None:
        form = QFormLayout(page)

        # Purchase picker (or preselected)
        self.applyPurchasePicker = QComboBox()
        lbl_purchase2 = QLabel(_t("Purchase *"))
        lbl_purchase2.setBuddy(self.applyPurchasePicker)
        form.addRow(lbl_purchase2, self.applyPurchasePicker)

        # Remaining due
        self.applyRemainingLabel = QLabel("")
        form.addRow(QLabel(_t("Remaining Due")), self.applyRemainingLabel)

        # Amount (>0)
        self.applyAmountEdit = QDoubleSpinBox()
        self.applyAmountEdit.setDecimals(2)
        self.applyAmountEdit.setRange(0.0, 1_000_000_000.0)
        self.applyAmountEdit.setSingleStep(1.0)
        form.addRow(QLabel(_t("Amount *")), self.applyAmountEdit)

        # Date
        self.applyDateEdit = QDateEdit()
        self.applyDateEdit.setCalendarPopup(True)
        self.applyDateEdit.setDisplayFormat("yyyy-MM-dd")
        self.applyDateEdit.setDate(QDate.currentDate())
        form.addRow(QLabel(_t("Date")), self.applyDateEdit)

        # Notes / Created by
        self.applyNotesEdit = QPlainTextEdit()
        self.applyNotesEdit.setPlaceholderText(_t("Optional notes"))
        self.applyNotesEdit.setFixedHeight(80)
        form.addRow(QLabel(_t("Notes")), self.applyNotesEdit)

        self.applyCreatedByEdit = QLineEdit()
        self.applyCreatedByEdit.setValidator(QIntValidator())
        form.addRow(QLabel(_t("Created By")), self.applyCreatedByEdit)

        # Wire
        self.applyPurchasePicker.currentIndexChanged.connect(self._update_apply_remaining)
        self.applyAmountEdit.valueChanged.connect(self._validate_live_apply)

    # ---------- Tab events ----------
    def _on_tab_changed(self, idx: int) -> None:
        self.pageStack.setCurrentIndex(idx)
        self._sync_window_title()
        self._update_hint()
        self._validate_live_payment()
        self._validate_live_advance()
        self._validate_live_apply()

    def _sync_window_title(self) -> None:
        titles = {
            self.PAGE_PAYMENT: _t("Record Vendor Payment"),
            self.PAGE_ADVANCE: _t("Record Vendor Advance"),
            self.PAGE_APPLY: _t("Apply Vendor Advance to Purchase"),
        }
        self.setWindowTitle(titles.get(self.pageStack.currentIndex(), _t("Vendor Money")))

    # ---------- Data loaders ----------
    def _load_purchases(self) -> None:
        rows: list[dict] = []
        try:
            if self._list_open_purchases_for_vendor:
                rows = list(self._list_open_purchases_for_vendor(self._vendor_id))
        except Exception:
            rows = []

        # Payment picker
        if hasattr(self, "purchasePicker"):
            self.purchasePicker.clear()
            for r in rows:
                pid = str(r.get("purchase_id", ""))
                doc = str(r.get("doc_no", pid))
                date = str(r.get("date", ""))
                total = float(r.get("total", 0.0))
                paid = float(r.get("paid", 0.0))
                rem = total - paid
                self.purchasePicker.addItem(f"{doc} — {date} — Total {total:.2f} Paid {paid:.2f} Rem {rem:.2f}", r)
            self._update_remaining()

        # Apply picker
        if hasattr(self, "applyPurchasePicker"):
            self.applyPurchasePicker.clear()
            for r in rows:
                pid = str(r.get("purchase_id", ""))
                doc = str(r.get("doc_no", pid))
                date = str(r.get("date", ""))
                total = float(r.get("total", 0.0))
                paid = float(r.get("paid", 0.0))
                rem = total - paid
                self.applyPurchasePicker.addItem(f"{doc} — {date} — Total {total:.2f} Paid {paid:.2f} Rem {rem:.2f}", r)
            self._update_apply_remaining()

    def _load_company_banks(self) -> None:
        if not hasattr(self, "companyBankCombo"):
            return
        self.companyBankCombo.clear()
        self.companyBankCombo.addItem("", None)
        rows: list[dict] = []
        try:
            if self._list_company_bank_accounts:
                rows = list(self._list_company_bank_accounts())
        except Exception:
            rows = []
        for a in rows:
            self.companyBankCombo.addItem(str(a.get("name", "")), int(a.get("id")))

        # Preselect
        if self._prefill_company_bank_id is not None:
            for i in range(self.companyBankCombo.count()):
                if self.companyBankCombo.itemData(i) == self._prefill_company_bank_id:
                    self.companyBankCombo.setCurrentIndex(i)
                    break

    def _load_vendor_banks(self) -> None:
        if not hasattr(self, "vendorBankCombo"):
            return
        self.vendorBankCombo.clear()
        self.vendorBankCombo.addItem("", None)
        rows: list[dict] = []
        try:
            if self._list_vendor_bank_accounts:
                rows = list(self._list_vendor_bank_accounts(self._vendor_id))
        except Exception:
            rows = []
        for a in rows:
            # some adapters may not coerce id to int — try safely
            try:
                vid = int(a.get("id"))
            except Exception:
                vid = a.get("id")
            self.vendorBankCombo.addItem(str(a.get("name", "")), vid)

        # Preselect
        if self._prefill_vendor_bank_id is not None:
            for i in range(self.vendorBankCombo.count()):
                if self.vendorBankCombo.itemData(i) == self._prefill_vendor_bank_id:
                    self.vendorBankCombo.setCurrentIndex(i)
                    break

    def _lock_purchase_if_needed(self) -> None:
        if self._locked_purchase_id is None:
            return
        # Payment page
        for i in range(self.purchasePicker.count()):
            data = self.purchasePicker.itemData(i)
            if isinstance(data, dict) and str(data.get("purchase_id", "")) == self._locked_purchase_id:
                self.purchasePicker.setCurrentIndex(i)
                break
        else:
            placeholder = {"purchase_id": self._locked_purchase_id, "doc_no": self._locked_purchase_id, "date": "", "total": 0.0, "paid": 0.0}
            self.purchasePicker.addItem(self._locked_purchase_id, placeholder)
            self.purchasePicker.setCurrentIndex(self.purchasePicker.count() - 1)
        self.purchasePicker.setEnabled(False)

        # Apply page
        for i in range(self.applyPurchasePicker.count()):
            data = self.applyPurchasePicker.itemData(i)
            if isinstance(data, dict) and str(data.get("purchase_id", "")) == self._locked_purchase_id:
                self.applyPurchasePicker.setCurrentIndex(i)
                self.applyPurchasePicker.setEnabled(False)
                break

    # ---------- Prefills (payment page) ----------
    def _apply_prefills_payment(self) -> None:
        if self._prefill_method in METHODS:
            self.methodCombo.setCurrentIndex(METHODS.index(self._prefill_method))

        if isinstance(self._prefill_amount, (int, float)):
            self.amountEdit.setValue(float(self._prefill_amount))

        if self._prefill_date:
            self._set_date_from_str(self.dateEdit, self._prefill_date)
        elif self._today:
            self._set_date_from_str(self.dateEdit, self._today())

        if self._prefill_instrument_type in INSTRUMENT_TYPES:
            self.instrumentTypeCombo.setCurrentIndex(INSTRUMENT_TYPES.index(self._prefill_instrument_type))

        if self._prefill_instrument_no:
            self.instrumentNoEdit.setText(str(self._prefill_instrument_no))

        if self._prefill_instrument_date:
            self._set_date_from_str(self.instrumentDateEdit, self._prefill_instrument_date)
        if self._prefill_deposited_date:
            self._set_date_from_str(self.depositedDateEdit, self._prefill_deposited_date)

        if self._prefill_clearing_state in CLEARING_STATES:
            self.clearingStateCombo.setCurrentIndex(CLEARING_STATES.index(self._prefill_clearing_state))

        if self._prefill_cleared_date:
            self._set_date_from_str(self.clearedDateEdit, self._prefill_cleared_date)

        if self._prefill_notes:
            self.notesEdit.setPlainText(str(self._prefill_notes))

        if self._prefill_created_by is not None:
            self.createdByEdit.setText(str(self._prefill_created_by))

    # ---------- Signals / UX (payment) ----------
    def _on_method_changed(self) -> None:
        method = self.methodCombo.currentText()

        # Force/default instrument type
        forced = METHOD_TO_FORCED_INSTRUMENT.get(method)
        if forced in INSTRUMENT_TYPES:
            self.instrumentTypeCombo.setCurrentIndex(INSTRUMENT_TYPES.index(forced))

        # Default clearing state
        default_clear = METHOD_TO_DEFAULT_CLEARING.get(method, "posted")
        if default_clear in CLEARING_STATES:
            self.clearingStateCombo.setCurrentIndex(CLEARING_STATES.index(default_clear))

        # Bank requirement (company)
        needs_bank = method in METHODS_REQUIRE_BANK
        self.companyBankCombo.setEnabled(needs_bank)
        self._set_required_label(self.companyBankCombo, needs_bank)
        if method == "Cash":
            self.companyBankCombo.setCurrentIndex(0)  # blank

        # Instrument number required?
        req_inst = method in METHODS_REQUIRE_INSTR_NO
        self._set_required_label(self.instrumentNoEdit, req_inst)

        # UX focus
        if needs_bank:
            self.companyBankCombo.setFocus()
        elif req_inst:
            self.instrumentNoEdit.setFocus()
        else:
            self.amountEdit.setFocus()

        self._update_hint()
        self._validate_live_payment()

    def _on_clearing_changed(self) -> None:
        state = self.clearingStateCombo.currentText()
        enable_cd = state == "cleared"
        self.clearedDateEdit.setEnabled(enable_cd)
        if not enable_cd:
            self._clear_date(self.clearedDateEdit)
        self._validate_live_payment()

    def _update_hint(self) -> None:
        idx = self.pageStack.currentIndex()
        hint = ""
        if idx == self.PAGE_PAYMENT:
            method = self.methodCombo.currentText()
            if method == "Cash":
                hint = _t("Negative amounts allowed. Company bank must be blank. Instrument no optional.")
            elif method == "Bank Transfer":
                hint = _t("Outgoing only (>0). Company bank required. Instrument type 'online'. Instrument no required.")
            elif method == "Cheque":
                hint = _t("Outgoing only (>0). Company bank required. Type 'cross_cheque'. Cheque no required.")
            elif method == "Cash Deposit":
                hint = _t("Outgoing only (>0). Company bank required. Type 'cash_deposit'. Deposit slip no required.")
            elif method in ("Card", "Other"):
                hint = _t("Outgoing only (>0). Bank optional. Instrument no optional.")
        elif idx == self.PAGE_ADVANCE:
            hint = _t("Record a positive vendor advance (prepayment). No method or bank needed here.")
        elif idx == self.PAGE_APPLY:
            hint = _t("Apply available advance to an open purchase. Amount must not exceed vendor credit or remaining due.")
        self.hintLabel.setText(hint)

    def _update_remaining(self) -> None:
        data = self.purchasePicker.currentData()
        if isinstance(data, dict):
            total = float(data.get("total", 0.0))
            paid = float(data.get("paid", 0.0))
            rem = total - paid
            self.purchaseRemainingLabel.setText(_t(f"Remaining: ${rem:.2f}"))
        else:
            self.purchaseRemainingLabel.setText("")

    # ---------- Apply page helpers ----------
    def _update_apply_remaining(self) -> None:
        data = self.applyPurchasePicker.currentData()
        if isinstance(data, dict):
            total = float(data.get("total", 0.0))
            paid = float(data.get("paid", 0.0))
            rem = total - paid
            self.applyRemainingLabel.setText(f"{rem:.2f}")
        else:
            self.applyRemainingLabel.setText("")

    # ---------- Validation (payment) ----------
    def _validate_live_payment(self) -> None:
        if self.pageStack.currentIndex() != self.PAGE_PAYMENT:
            return
        ok, msg = self._validate_payment()
        self.errorLabel.setText(msg or "")
        self.saveBtn.setEnabled(ok)

    def _validate_payment(self) -> tuple[bool, Optional[str]]:
        # 1) Purchase present
        p = self.purchasePicker.currentData()
        if not isinstance(p, dict) or not str(p.get("purchase_id", "")):
            return False, _t("Please select a purchase for this payment.")

        # 2) Method supported
        method = self.methodCombo.currentText()
        if method not in METHODS:
            return False, _t("Payment method is not supported.")

        # 3) Amount sign/zero
        amount = float(self.amountEdit.value())
        if abs(amount) < 1e-9:
            return False, _t("Amount cannot be zero.")
        if amount < 0 and method != "Cash":
            return False, _t("Refunds (negative amounts) are only allowed with the Cash method.")

        # 4) Bank rules
        cbank_id = self._current_company_bank_id()
        if method == "Cash":
            if cbank_id is not None:
                return False, _t("Company bank must be empty when method is Cash.")
        elif method in METHODS_REQUIRE_BANK and cbank_id is None:
            return False, _t("Company bank account is required for this method.")

        # 5) Instrument type enforcement
        instype = self.instrumentTypeCombo.currentText()
        if instype not in INSTRUMENT_TYPES:
            return False, _t("Payment method is not supported.")
        forced = METHOD_TO_FORCED_INSTRUMENT.get(method)
        if method in ("Bank Transfer", "Cheque", "Cash Deposit") and instype != forced:
            if method == "Bank Transfer":
                return False, _t("Instrument type must be 'online' for Bank Transfer.")
            if method == "Cheque":
                return False, _t("Instrument type must be 'cross_cheque' for Cheque.")
            if method == "Cash Deposit":
                return False, _t("Instrument type must be 'cash_deposit' for Cash Deposit.")

        # 6) Instrument number requirement
        inst_no = self.instrumentNoEdit.text().strip()
        if method in METHODS_REQUIRE_INSTR_NO and not inst_no:
            return False, _t("Please enter instrument/reference number.")

        # 7) Clearing state & dates
        state = self.clearingStateCombo.currentText()
        if state == "cleared":
            if not self._has_date(self.clearedDateEdit):
                return False, _t("Please select a cleared date.")

        # 8) Date format safety
        for de in (self.dateEdit, self.instrumentDateEdit, self.depositedDateEdit, self.clearedDateEdit):
            if self._has_date(de):
                s = de.date().toString("yyyy-MM-dd")
                if len(s) != 10:
                    return False, _t("Please enter dates in YYYY-MM-DD.")

        return True, None

    # ---------- Validation (advance) ----------
    def _validate_live_advance(self) -> None:
        if self.pageStack.currentIndex() != self.PAGE_ADVANCE:
            return
        ok, msg = self._validate_advance()
        self.errorLabel.setText(msg or "")
        self.saveBtn.setEnabled(ok)

    def _validate_advance(self) -> tuple[bool, Optional[str]]:
        amt = float(self.advAmountEdit.value())
        if amt <= 0.0:
            return False, _t("Amount must be greater than zero.")
        return True, None

    # ---------- Validation (apply) ----------
    def _validate_live_apply(self) -> None:
        if self.pageStack.currentIndex() != self.PAGE_APPLY:
            return
        ok, msg = self._validate_apply()
        self.errorLabel.setText(msg or "")
        self.saveBtn.setEnabled(ok)

    def _validate_apply(self) -> tuple[bool, Optional[str]]:
        data = self.applyPurchasePicker.currentData()
        if not isinstance(data, dict) or not str(data.get("purchase_id", "")):
            return False, _t("Please select a purchase to apply the advance.")

        amt = float(self.applyAmountEdit.value())
        if amt <= 0.0:
            return False, _t("Amount must be greater than zero.")

        # Client-side bound against remaining due if present in picker rows
        try:
            total = float(data.get("total", 0.0))
            paid = float(data.get("paid", 0.0))
            remaining = total - paid
            if amt - remaining > 1e-9:
                return False, _t("Amount exceeds remaining due for the selected purchase.")
        except Exception:
            pass

        return True, None

    # ---------- Save ----------
    def _on_save(self) -> None:
        idx = self.pageStack.currentIndex()
        if idx == self.PAGE_PAYMENT:
            ok, msg = self._validate_payment()
            if not ok:
                self._warn(msg)
                return
            self._payload = self._build_payload_payment()
        elif idx == self.PAGE_ADVANCE:
            ok, msg = self._validate_advance()
            if not ok:
                self._warn(msg)
                return
            self._payload = self._build_payload_advance()
        elif idx == self.PAGE_APPLY:
            ok, msg = self._validate_apply()
            if not ok:
                self._warn(msg)
                return
            self._payload = self._build_payload_apply()

        self.accept()

    def payload(self) -> Optional[dict]:
        return self._payload

    # ---------- Helpers ----------
    def _warn(self, msg: Optional[str]) -> None:
        self.errorLabel.setText(msg or "")
        QMessageBox.warning(self, _t("Cannot Save"), msg or _t("Please correct the highlighted fields."))

    def _current_company_bank_id(self) -> Optional[int]:
        data = self.companyBankCombo.currentData()
        return int(data) if isinstance(data, int) else None

    def _current_vendor_bank_id(self) -> Optional[int]:
        data = self.vendorBankCombo.currentData()
        # vendor bank may not always be int-typed
        try:
            return int(data)
        except Exception:
            return data if data is not None else None

    def _set_required_label(self, widget: QWidget, required: bool) -> None:
        label = getattr(self, "_label_map", {}).get(widget)
        if not label:
            return
        base = label.text().rstrip(" *")
        label.setText(base + (" *" if required else ""))

    def _set_date_from_str(self, edit: QDateEdit, s: str) -> None:
        try:
            y, m, d = map(int, s.split("-"))
            edit.setDate(QDate(y, m, d))
        except Exception:
            pass

    def _has_date(self, edit: QDateEdit) -> bool:
        return True  # QDateEdit always has a date unless using special values

    def _clear_date(self, edit: QDateEdit) -> None:
        edit.setDate(QDate.currentDate())

    # ---------- Build payloads ----------
    def _build_payload_payment(self) -> dict:
        pdata = self.purchasePicker.currentData() or {}

        def date_or_none(edit: QDateEdit) -> Optional[str]:
            if edit.isEnabled():
                return edit.date().toString("yyyy-MM-dd")
            return None

        payload = {
            "purchase_id": str(pdata.get("purchase_id")),
            "amount": float(self.amountEdit.value()),
            "method": self.methodCombo.currentText(),
            "date": self.dateEdit.date().toString("yyyy-MM-dd"),
            "bank_account_id": self._current_company_bank_id(),
            "vendor_bank_account_id": self._current_vendor_bank_id(),
            "instrument_type": self.instrumentTypeCombo.currentText() or None,
            "instrument_no": (self.instrumentNoEdit.text().strip() or None),
            "instrument_date": date_or_none(self.instrumentDateEdit),
            "deposited_date": date_or_none(self.depositedDateEdit),
            "clearing_state": self.clearingStateCombo.currentText() or None,
            "cleared_date": (self.clearedDateEdit.date().toString("yyyy-MM-dd") if self.clearedDateEdit.isEnabled() else None),
            "notes": (self.notesEdit.toPlainText().strip() or None),
            "created_by": (int(self.createdByEdit.text()) if self.createdByEdit.text().strip() else None),
        }
        return payload

    def _build_payload_advance(self) -> dict:
        payload = {
            "vendor_id": self._vendor_id,
            "amount": float(self.advAmountEdit.value()),
            "date": self.advDateEdit.date().toString("yyyy-MM-dd"),
            "notes": (self.advNotesEdit.toPlainText().strip() or None),
            "created_by": (int(self.advCreatedByEdit.text()) if self.advCreatedByEdit.text().strip() else None),
        }
        return payload

    def _build_payload_apply(self) -> dict:
        pdata = self.applyPurchasePicker.currentData() or {}
        payload = {
            "vendor_id": self._vendor_id,
            "purchase_id": str(pdata.get("purchase_id")),
            "amount": float(self.applyAmountEdit.value()),
            "date": self.applyDateEdit.date().toString("yyyy-MM-dd"),
            "notes": (self.applyNotesEdit.toPlainText().strip() or None),
            "created_by": (int(self.applyCreatedByEdit.text()) if self.applyCreatedByEdit.text().strip() else None),
        }
        return payload

```

