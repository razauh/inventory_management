Problem Location 
  1: File: /home/pc/Desktop/inventory_management/database/schema.py

  Issue Description
  The problem exists in the product_uoms table definition, which has a foreign key constraint with ON DELETE CASCADE:

    1 CREATE TABLE IF NOT EXISTS product_uoms (
    2     product_uom_id INTEGER PRIMARY KEY AUTOINCREMENT,
    3     product_id     INTEGER NOT NULL,
    4     uom_id         INTEGER NOT NULL,
    5     is_base        INTEGER NOT NULL DEFAULT 0 CHECK (is_base IN (0,1)),
    6     factor_to_base NUMERIC NOT NULL,
    7     UNIQUE(product_id, uom_id),
    8     FOREIGN KEY (product_id) REFERENCES products(product_id) ON DELETE CASCADE,  -- ‚Üê THE ISSUE
    9     FOREIGN KEY (uom_id)     REFERENCES uoms(uom_id)
   10 );

  Root Cause
  While the database includes a trigger trg_block_delete_used_uom_map that prevents direct deletion of UoM mappings that have been used in
  transactions, this trigger is bypassed when the deletion happens through the CASCADE mechanism from the parent products table.

  The trigger only fires when someone explicitly deletes from the product_uoms table, but does NOT fire when the deletion occurs due to cascade
  deletion from the products table.

  When a product is deleted (either directly via the application or bypassing it via direct database operations), all associated UoM mappings are
  deleted via the CASCADE, regardless of whether those UoM mappings were used in transactions.

  Impact
  After cascade deletion:
   1. Historical transactions that were recorded with specific UoM mappings lose their conversion factors
   2. Queries using COALESCE(factor_to_base, 1.0) would default to a factor of 1.0
   3. This causes incorrect calculations for historical data (e.g., treating 1 dozen as 1 unit instead of 12 units)

  Solution
  The foreign key constraint should be changed from ON DELETE CASCADE to ON DELETE RESTRICT or ON DELETE NO ACTION to prevent the product from being
  deleted when there are dependent UoM mappings that have been used in transactions.

  There is already application-level logic in ProductsRepo._product_is_referenced() to prevent product deletion when it has references, but this is
  bypassed if someone operates directly on the database. The database-level constraint should enforce this protection as well.


-------------------------------------------

